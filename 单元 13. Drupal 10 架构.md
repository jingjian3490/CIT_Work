要理解 Drupal 10 的编程架构，有必要了解 Drupal 的站点构建（Site Building）。在 Drupal 10 站点构建专家课程中，我们学习了 Drupal 10 架构的主要组件：核心、模块、实体和字段、内容类型、区块、菜单、主题、用户和权限等。如果你对这些概念有疑问，建议你先复习《Drupal 10 站点构建专家》一书的内容。

在本课程中，我们将深入探讨 Drupal 10 的架构和功能，从编程的角度出发。在本单元中，我们将介绍 Drupal 架构的一些重要元素。我们还会了解文件和文件夹的结构，以及 Drupal 的工作流程，从接收到页面加载请求到生成并发送响应到浏览器的全过程。

作为对前几单元所学内容的复习，我们将看到一些在 Drupal 核心中使用面向对象编程（OOP）的示例。

## 单元内容
- 13.1 Drupal 的安装要求
- 13.2 Drupal 架构
- 13.3 文件结构
- 13.4 Drupal 10 的工作流程
- 13.5 Drupal 中的面向对象编程（OOP）
- 13.6 Drupal API
- 13.7 系统表
# 13.1 Drupal 的安装要求

## Drupal 的版本系统
从 Drupal 8 开始，为了方便维护和扩展功能，Drupal 改变了版本控制系统。与 Drupal 7 不同，在 Drupal 10 中，每个版本都有双重编号，如 10.x.y。

在 10.x.1、10.x.2、10.x.3 等版本之间，只会修正错误和安全漏洞，不会添加新功能。这个模型与之前的 Drupal 版本类似。

每 6 个月会发布一个新的主要版本（如 10.1、10.2、10.3 等），这些版本会引入新功能，同时尽量保持 API 的兼容性。

这种新系统允许在不等待 Drupal 11 的情况下，将新功能集成到核心中。由于 Drupal 10 在不断发展，技术要求也可能会在不同版本之间有所变化。

## Web 服务器要求
所有 Drupal 的安装要求可以在以下链接查看：
[https://www.drupal.org/docs/system-requirements](https://www.drupal.org/docs/system-requirements)

Drupal 10 可以安装并运行在任何支持 PHP 8.1 或更高版本的 Web 服务器上（目前也兼容 PHP 8.2）。

Drupal 是用 PHP 开发的，扩展其功能的模块也必须用这种语言开发。因此，学习或事先了解 PHP 对于跟随本课程是至关重要的，这也是我们在前几单元深入学习 PHP 的原因之一。

最常用且出于安全原因推荐的 Web 服务器是 Apache 2.x，它可以安装在 Linux、OS X 或 Windows 上。

在安装过程中，Drupal 会检查 Web 服务器是否满足最低运行要求。报告的要求错误需要修正才能继续安装。典型的配置问题包括：

- 需要 Apache 的 mod_rewrite 扩展，用于清洁 URL。
- PHP 的 register_globals 指令必须关闭（register_globals: off）。
- PHP 的 safe_mode 指令必须关闭（safe_mode: off）。
- Drupal 8 使用 PDO（PHP Data Objects）扩展，因此必须在服务器上安装并正确运行。
- 一些必需的 PHP 扩展包括：CURL、fileinfo、pdo、tokenizer。完整列表可以在 [https://www.drupal.org/docs/system-requirements/php-requirements](https://www.drupal.org/docs/system-requirements/php-requirements) 查看。
- Drupal 10 核心需要至少 64 MB 的内存，但根据安装的附加模块，这个数量需要增加。建议在项目中使用至少 256 MB 的内存。请注意，这只是单个 Drupal 实例所需的内存，而不是服务器的总内存。生产服务器上的总可用内存将取决于网站的并发访问量。
- 脚本的执行时间（max_execution_time）至少应为 30 秒。实际上，这个时间通常会增加到 60/90 秒。这取决于安装的附加模块以及它们可能需要的时间，特别是在管理任务中。
- 磁盘空间的需求很难估计，因为不仅仅是代码（核心和贡献模块）占用空间，还包括用户上传的文件、图片、备份等。可以先预留至少 200MB 的空间，随着门户的使用会逐步增加。

详细的 PHP 要求可以在这里查看：
[https://www.drupal.org/docs/system-requirements/php-requirements](https://www.drupal.org/docs/system-requirements/php-requirements)

如果你想了解在其他 Web 服务器（如 Nginx 或 Microsoft IIS）上安装 Drupal 10 的要求，请参阅以下链接：
[https://www.drupal.org/docs/system-requirements/web-server-requirements](https://www.drupal.org/docs/system-requirements/web-server-requirements)
## 数据库服务器

Drupal 支持不同的数据库管理系统，如 MySQL、MariaDB、SQLite 和 PostgreSQL。这是通过一个数据库抽象层实现的，该层将 Drupal 提供的通用指令转换为每个数据库的特定指令。这样可以在不更改 Drupal 或开发模块代码的情况下更换数据库管理系统。

Drupal 8 支持的数据库版本如下：
- MySQL 5.7.8 或更高版本。
- MariaDB 10.3.7 或更高版本。
- Percona Server 5.7.8 或更高版本。
- PostgreSQL 12 或更高版本。
- SQLite 3.26 或更高版本。

虽然 Drupal 10 支持这些数据库，但在安装贡献模块时需要注意兼容性。最常用和测试最多的数据库是 MySQL 和 MariaDB。

在本课程中，我们将使用 MariaDB 数据库，但正如我们之前提到的，查询将通过抽象层进行，因此所学内容对其他数据库同样适用。

有关数据库的具体要求，请参阅：
[https://www.drupal.org/docs/system-requirements/database-server-requirements](https://www.drupal.org/docs/system-requirements/database-server-requirements)

## Web 浏览器

Drupal 10 兼容所有使用 CSS 和 JavaScript 的现代浏览器。请注意，我们所说的兼容性是指核心的兼容性，安装的贡献模块可能会影响这种兼容性。

Drupal 10 支持最新版本的 Google Chrome、Firefox、Safari、Microsoft Edge、Opera 等。

你可以在以下链接了解更多关于浏览器要求的信息：
[https://www.drupal.org/docs/system-requirements/browser-requirements](https://www.drupal.org/docs/system-requirements/browser-requirements)
# 13.2 Drupal 架构

### Drupal 10 站点构建专家

要理解 Drupal 10 的编程（后端）架构，有必要了解 Drupal 的站点构建。在 Drupal 10 站点构建专家课程中，我们学习了 Drupal 10 架构的主要组件：核心、模块、实体和字段、内容类型、区块、菜单、主题、用户和权限等。如果你对这些概念有疑问，建议你复习《Drupal 10 站点构建专家》一书的内容。

在本课程中，我们将深入探讨 Drupal 10 的架构和功能，从编程的角度出发。

### Drupal 10 中的 Symfony

首先你需要知道的是，Drupal 10 并不是建立在 Symfony 之上的。从 Drupal 8 开始，Drupal 只是引入了 Symfony 的一些组件，但并没有使用整个框架。

因此，了解 Symfony 有助于我们理解 Drupal 10 的某些部分如何工作，但这还不够，因为 Drupal 10 也包含了一些与 Symfony 无关的自有库。同样，深入了解 Drupal 10 也不会让我们对 Symfony 框架有完整的认识。

Drupal 所需的 Symfony 组件可以在 Drupal 安装的 `/core/composer.json` 文件中查看 [F13.2a]。在这个文件中，我们可以看到所需的组件及其对应的版本。

```json
{
  "name": "drupal/core",
  "description": "Drupal is an open source content management platform powering millions of websites and applications.",
  "type": "drupal-core",
  "license": "GPL-2.0-or-later",
  "require": {
    "ext-date": "*",
    "php": ">=8.1.0",
    "symfony/console": "^6.2",
    "symfony/dependency-injection": "^6.2",
    "symfony/event-dispatcher": "^6.2",
    "symfony/http-foundation": "^6.2",
    "symfony/http-kernel": "^6.2",
    "symfony/mime": "^6.2",
    "symfony/routing": "^6.2",
    "symfony/serializer": "^6.2",
    "symfony/validator": "^6.2",
    "symfony/process": "^6.2",
    "symfony/polyfill-iconv": "^1.26",
    "symfony/yaml": "^6.2",
    "twig/twig": "^3.4.3",
    "doctrine/annotations": "^1.13"
  }
}
```
F13.2a `/core/composer.json` 中 Drupal 10 所需的 Symfony 组件。

安装完成后，`/composer.lock` 文件将显示每个组件的已安装版本 [F13.2b]。

```json
{
  "name": "symfony/routing",
  "version": "v6.2.5",
  "source": {
    "type": "git",
    "url": "https://github.com/symfony/routing.git",
    "reference": "589bd742d5d03c192c8521911680fe88f61712fe"
  }
}
```
F13.2b `/composer.lock` 中已安装的 Symfony 组件。

### Drupal 10 使用的 Symfony 版本

在 Drupal 10 中使用的是 Symfony 6.2 版本。这个版本可能会在未来的 Drupal 10 版本中更新。

在 Symfony 的单元（10 和 11）中，我们直接安装了最新的可用版本。
### Drupal 10 中的面向对象编程（POO）

Drupal 10 在 PHP 中广泛使用面向对象编程（POO）。总体而言，Drupal 10 中实现的所有功能都是围绕类、接口、抽象类和 traits 展开的。这种方法同样适用于我们开发的模块。

因此，在开始 Drupal 10 后端编程之前，拥有扎实的 POO 基础是至关重要的。

如果你对 PHP 编程有疑问，请复习第 5 到第 7 单元的内容。

### DrupalKernel

`DrupalKernel` 类是 Drupal 的核心。它负责执行核心并构建服务容器，这个容器可以被系统中安装的任何模块使用。我们将在 13.3 节中详细讨论这个类。

### 依赖注入和服务容器

我们在 11.5 节已经学习了什么是服务容器以及如何使用依赖注入。Drupal 10 提供了一个服务容器，可以被核心和贡献模块使用。这些模块也可以注册自己的服务，这些服务同样对其他模块可用。

可以在以下链接查看 Drupal 服务容器中可用的完整服务列表：
[https://api.drupal.org/api/drupal/services](https://api.drupal.org/api/drupal/services)

### 插件

插件是一些提供特定功能的特殊类。例如，区块是通过插件构建的。

### YAML

我们在 11.2 节学习了 YAML 数据序列化格式。在 Drupal 10 中，YAML 文件用于在文件中存储配置。许多配置会被转移到数据库中，因此 YAML 文件作为安装的基础，同时也用作配置的导入/导出文件。

YAML 文件用于存储配置、定义路由、菜单链接、服务等。

### 注释

我们在 11.3 节介绍了 Symfony 的注释组件。这些是具有特定格式的注释，不仅用于生成类的文档，有时还提供配置值。例如，我们将在插件注册中看到注释的使用。

### 路由系统

路由系统基于 YAML 文件来注册路由及其对应的 URL，并通过控制器类生成每个路由的输出。正如我们将看到的，路由是 Drupal 架构中的一个基本元素。

### 缓存

缓存是 Drupal 中一个非常重要的部分，用于优化应用程序的性能。基本上，它基于存储消耗大量资源的重复操作的结果。这样，当再次请求相同的操作时，不需要重复操作，因为我们已经计算出结果并可以直接提供。

虽然我们在模块中创建的许多元素将被自动缓存，但我们也会学习如何为我们的模块编写特定的缓存逻辑。
### 模板

在 Drupal 10 中，使用的模板系统是 Twig，这也是 Symfony 使用的模板引擎。模板是定义用于显示特定元素（如页面、区块、标题等）的 HTML 代码的文件。这样，PHP 代码只需要处理变量及其相应的值，而内容的展示部分则交由模板来完成。

与 Drupal 7 及之前版本使用的 PHPTemplate 引擎的主要区别在于，Twig 不使用 PHP，因此无法在模板中插入“垃圾”代码（或只是位置不当的代码）。模板因此能够专注于内容的展示，而无法插入编程逻辑。

此外，由于不包含 PHP 代码，Twig 模板对没有编程知识的用户（如设计师和排版人员）更加友好，避免了他们在修改 PHP 代码片段时可能引发的错误。

### 状态变量

状态变量是用于存储与核心或模块（无论是贡献的还是开发的）相关的可变信息的一种方式。这些信息是可变的，仅与系统的当前状态相关，可以删除或重置而不会影响系统的运行和配置。例如，最后一次执行 cron 的日期是一个可变的值，存储在状态变量中。

### 配置

配置是与模块相关的永久信息。例如，站点的默认国家和时区存储在配置对象中。正如我们之前所讨论的，配置从 YAML 文件中读取，但存储在数据库中以便于访问。

配置可以重新导出到 YAML 文件中，以便在不同环境之间导入/导出。

### Drupal API

Drupal API 为我们提供了编写 Drupal 程序和理解其运行所需的所有信息。

Drupal API 可以在以下地址找到：
[https://api.drupal.org/api/drupal/10](https://api.drupal.org/api/drupal/10)

访问 API 时，我们会看到一系列主题或话题，其中包含特定的文档。务必确保我们查看的是合适版本的 Drupal 文档 [F13.2c]。

此外，查询核心中可用的类、函数和其他元素也非常有用。所有代码都有文档说明，相关元素之间也有链接，因此 API 成为浏览 Drupal 代码的一个有力工具。
### 模块

模块为 Drupal 核心提供了额外的功能。Drupal 核心是通过模块构建的，这些模块遵循与贡献模块或我们自己开发的模块相同的开发指南。由于所有模块都使用相同的 API，核心代码是我们可以在模块中重用的重要示例来源。

### 钩子（Hooks）

钩子是从早期版本的 Drupal 继承下来的部分，当时还没有广泛使用面向对象编程。尽管钩子在未来的 Drupal 版本中可能会逐渐消失，但实际上在 Drupal 10 中仍然存在大量钩子，因此我们需要了解并在必要时使用它们。

钩子是模块实现的一些具有特定目的的函数，用于与核心或其他模块通信。当 Drupal 需要从已安装的模块中收集某些信息时，它会调用这些钩子。每个模块通过其钩子函数提供信息，系统则根据收集到的所有信息进行操作。

可以在以下链接查看 Drupal 10 中仍在使用的钩子：
[https://api.drupal.org/api/drupal/core!core.api.php/group/hooks/10](https://api.drupal.org/api/drupal/core!core.api.php/group/hooks/10)

### 实体和字段

实体的概念及其关联字段在 Drupal 6 中引入。实体是系统中许多元素（如内容、用户、分类术语等）的通用概念。由于共享相同的实体基础，某些功能将对所有这些元素可用，前提是它们希望实现这些功能。最明显的例子是添加字段的能力，以及相应的“管理字段”、“管理表单显示”和“管理显示”部分。

实体通过 Entity API 进行编程，如我们稍后将看到的，字段通过 Field API 进行编程。在 Drupal 10 中，我们的目标是编写更多类型的实体，而不是更多类型的内容。

与早期版本相比，另一个重要的变化是添加某些类型的字段到实体的方式。现在许多类型的字段被定义为实体，并作为实体引用字段添加。

### 内容或节点

内容管理系统必须允许管理和管理希望通过互联网分发的内容。Drupal 将站点内容存储在节点中。因此，节点构成了 Drupal 网站中基本的信息元素。

节点是一种用于显示静态内容的特定实体类型。正如我们所知，Drupal 可以处理具有不同类型字段的内容类型，这些字段不仅允许关联文本，还允许关联多媒体文件和一般结构化信息（日期、数字、列表等）。

内容具有系统 URL，形式为 `node/x`，其中 `x` 对应节点的内部 ID。

在 Drupal 中，节点是一种特定的实体类型。因此，它们共享许多实体的功能，但也包含特定的功能。

### 评论

评论被定义为一种独立的实体，可以有自己的评论类型。评论作为一种实体引用字段（类型为评论）与内容或其他实体关联。

### 用户、角色和权限

另一个重要的元素类型是用户。与用户相关的信息存储在数据库中，并在各种过程中使用：认证、偏好、权限等。用户是一种具有特定功能的实体类型。

正如我们在站点构建课程中所学，Drupal 使用角色策略来管理权限。用户可以被分配多个角色，而角色又可以被分配权限。在我们的模块中，我们将定义特定的权限，并根据这些权限在代码中添加访问控制。
### 表单

Drupal 10 的表单 API（Form API）与之前版本中使用的非常相似。表单仍然表示为嵌套数组，具有一系列特定的键来确定其配置。正如我们将看到的，创建表单页面的方式有所变化，通过特定的构造类来实现。表单的验证和提交也非常相似，但使用了构造类的方法。

表单仍然是管理模块配置的不可或缺的工具。

### 数组和可渲染元素

可渲染数组（render array）是一个最终会转换为 HTML 的数组。这个转换为 HTML 或最终输出的过程称为渲染。

可渲染数组具有特定结构，其中指定了元素类型、值、使用的模板等，所有这些都是为了生成最终的 HTML 输出。

表单元素是可渲染元素的一个子集。在这种情况下，每个元素的最终输出是表示该表单字段的 HTML 代码。

我们所谈到的 HTML 输出，可以由模板（twig）或主题函数确定。在第 27 和 28 单元中，我们将进一步扩展这些概念。
# 13.3 文件结构

接下来，我们将解释通过 Composer 安装 Drupal 10 时的文件夹和文件结构（使用推荐的项目结构）。

在第一级目录中，我们可以看到以下文件夹和文件 [F13.3a]：

```plaintext
 web
 vendor [第三方库]
 composer.json
 composer.lock
```

F13.3a Drupal 文件

Drupal 的文件和文件夹结构（第一级）

- `/web`：包含核心模块和其他文件。我们将在下面详细介绍其内容。
- `/vendor`：包含 Drupal 分发版中的第三方库（composer、doctrine、symfony 组件、twig 等）。
- `composer.json` 和 `composer.lock` 文件由 Composer 用于管理依赖项。

`web` 文件夹进一步分为以下子文件夹和文件 [F13.3b]：

```plaintext
 web
  core [Drupal 核心]
  libraries [额外的库]
  modules [额外的模块]
    contrib [推荐用于存放贡献模块的文件夹]
    custom [推荐用于存放自定义模块的文件夹]
  profiles [额外的安装配置文件]
  sites [站点特定文件]
    default
      files
      default.settings.php
      settings.php [主要配置文件]
  themes [额外的主题]
  .htaccess
  autoload.php
  index.php
  robots.txt
  update.php
```

F13.3b Drupal 文件
Drupal 的文件和文件夹结构（`/web` 内部）

- `/core`：包含核心模块和其他文件。我们将在下面详细介绍其内容。
- `/libraries`：该文件夹最初未创建。我们将在这里添加贡献模块所需的额外库。通常是 JavaScript 库（例如，colorbox）。
- `/modules`：包含贡献和自定义模块。建议将其内容组织到两个子文件夹中：
  - `/modules/contrib`：用于贡献模块。
  - `/modules/custom`：用于开发的自定义模块。
- `/profiles`：额外的安装配置文件，贡献或自定义。
- `/sites`：站点特定的模块、主题和文件。通常，我们只会使用 `/sites/default/files` 文件夹来存放站点的公共文件。
- `/themes`：贡献主题、自定义主题和子主题。

在 `/web` 目录中，我们还可以找到以下文件：

- `.htaccess` 文件在 Apache 中使用，以应用 Web 服务器的特定配置，从而确保 Drupal 正常运行。
- `autoload.php` 文件包含类的自动加载组件。
- `index.php` 文件是系统的入口点。当我们加载网站页面时，总是调用 `index.php`。我们将在下一节中了解 Drupal 的工作原理。
- `robots.txt` 文件用于指示搜索引擎机器人哪些文件夹或文件不应被索引，就像在任何 Web 服务器上一样。
- `update.php` 文件用于在系统或已安装模块更新后更新数据库。
- 还包括一些帮助和信息文件，以文本格式（.txt）存储，例如：
  - `LICENSE.txt`：包含关于 GNU 版本 2 许可证的信息，这是 Drupal 分发所使用的许可证。
  - `README.txt`：包含 Drupal 的一般帮助信息。
## 核心文件和文件夹结构

在 `core` 文件夹中，我们可以看到以下文件夹和文件结构 [F13.3c]：

```plaintext
 core [Drupal 核心]
  assets
  config
  includes
  lib
  misc
  modules [核心模块]
  profiles [核心安装配置文件]
    minimal
    standard
    testing
  scripts
  tests
  themes [核心主题]
  vendor
  authorize.php
  CHANGELOG.txt
  composer.json
  core.api.php
  core.libraries.php
  core.services.php
  globals.api.php
  install.php
  rebuild.php [外部缓存重建]
```

F13.3c 核心文件
Drupal 10 核心文件和文件夹结构

- `/core/assets/vendor`：核心使用的外部库（如 jQuery、CKEditor、Modernizr 等）。
- `/core/config`：YAML 配置文件。
- `/core/includes`：包含一组以 `.inc` 扩展名的 PHP 文件形式的库，这些文件包括系统较低级别的常用函数（如 `database.inc`、`module.inc`、`form.inc` 等）。
- `/core/lib`：Drupal 核心类。
- `/core/misc`：核心使用的前端库（JavaScript）。还包括 Drupal 使用的图标。
- `/core/modules`：核心模块。绝对不要直接修改这些模块，也不要在此文件夹中添加其他模块。
- `/core/profiles`：核心安装配置文件。Drupal 可以初始安装为标准模式（standard）或简化版（minimal），后者仅包含 Drupal 运行所需的最少模块。
- `/core/scripts`：包含不直接被 Drupal 使用但可以从命令行使用的额外工具。例如，`password-hash.sh` 脚本可以从原始密码（纯文本）生成编码密码。
- `/core/tests`：核心测试。
- `/core/themes`：核心主题。

`/core` 文件夹中的一些文件：

- `/core/authorize.php`：此脚本用于内部授权文件操作。例如，它用于从界面更新模块。
- `/core/composer.json`：Composer 用于核心依赖项的信息。
- `/core/core.api.php`：包含帮助文档的文件。
- `/core/core.libraries.yml`：记录核心库的配置文件。
- `/core/core.services.yml`：记录核心服务的配置文件。
- `/core/globals.api.php`：定义全局变量。
- `/core/install.php`：安装时的入口点。
- `/core/rebuild.php`：即使站点无法运行，也允许重建 Drupal 缓存。

还包括一些帮助和信息文件，以文本格式（.txt）存储，例如：

- `/core/CHANGELOG.txt`：记录每个 Drupal 版本引入的更改历史。
- `/core/INSTALL.mysql.txt`、`/core/INSTALL.pgsql.txt` 和 `/core/INSTALL.sqlite`：提供在不同数据库引擎中创建数据库和所需权限的帮助。
- `/core/INSTALL.txt`：逐步描述如何安装 Drupal。
- `/core/LICENSE.txt`：包含关于 GNU 版本 2 许可证的信息，这是 Drupal 分发所使用的许可证。
- `/core/MAINTAINERS.txt`：列出负责维护 Drupal 的人员。
- `/core/UPDATE.txt`：逐步描述如何将 Drupal 更新到新版本。
# 13.4 Drupal 10 的运行机制

## 核心执行步骤

为了理解 Drupal 核心的工作原理，我们将逐步执行，概述哪些功能被执行以及它们的执行顺序。

请参考第 1.3 节关于如何使用 NetBeans 和 Xdebug 从远程服务器进行调试的内容。请注意，您需要创建一个指向站点根目录的新项目（例如，`/home/usuario/public_html/be/be1`）。

### 1. `index.php`

Drupal 的执行从 `index.php` 开始，这是响应（response）所有站点页面请求（request）的文件。

F13.4a 核心逐步执行
Drupal 的执行从 `index.php` 开始

要开始逐步调试，我们可以在 `use` 语句之后的第一行代码上设置一个断点 。
![[Pasted image 20240613144120.png]]我们将在调试模式下运行项目，然后使用逐步执行按钮跳到下一行代码或进入函数以分析其内容。以下是 Phpstorm 中调试按钮的功能回顾：
- **Resume Program (继续程序)**
    - 继续执行程序直到下一个断点。
- **Step Over (单步执行)**
    - 执行下一行代码，如果当前行是函数调用，则整个函数会被当作一个单步执行。
- **Step Into (步入)**
    - 进入函数内部，逐行调试函数内部的代码。
- **Force Step Into (强制步入)**
    - 强制进入某些不会自动步入的代码（例如一些库函数）。
- **Step Out (步出)**
    - 退出当前函数，返回到调用该函数的地方。
### 2. 创建 Drupal 内核

从 `index.php` 创建 `DrupalKernel` 类型的 `$kernel` 对象：

```php
$kernel = new DrupalKernel('prod', $autoloader);
```

我们可以进入（F7），到达 `DrupalKernel` 类的构造方法（文件位于 `/core/lib/Drupal/Core/DrupalKernel.php`）。构造函数为内核分配了一些属性，例如正在运行的环境（`$this->environment = 'prod'`），负责类自动加载的类，以及应用程序的根目录（`$this->root`）。

![[Pasted image 20240613151207.png]]

您可以在以下链接查看 `DrupalKernel` 类的属性和方法：
[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!DrupalKernel.php/class/DrupalKernel/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!DrupalKernel.php/class/DrupalKernel/10)
### 2. 创建 `$request` 对象

我们回到 `index.php` 创建 `Request` 类型的 `$request` 对象 。正如我们在第 11.4 节中所看到的，Symfony 的 HTTPFoundation 组件提供了 HTTP 通信（Request/Response）所需的方法。在这一点上，正在创建 `Request` 对象（位于 `\vendor\symfony\http-foundation\Request.php`），通常使用 `Request::createFromGlobals()` 方法来创建。

该方法从 PHP 的超全局变量（`$_GET`、`$_POST`、`$_SERVER`、`$_COOKIE` 等）中生成 `Request` 对象。

[https://github.com/symfony/http-foundation/blob/6.2/Request.php](https://github.com/symfony/http-foundation/blob/6.2/Request.php)

### 3. 调用 `DrupalKernel::handle()` 方法

`DrupalKernel::handle()` 方法负责处理 `Request` 并将其转换为 `Response`。我们将进入该函数，逐步查看其执行的操作。

```php
$response = $kernel->handle($request);
```

[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!DrupalKernel.php/function/DrupalKernel::handle/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!DrupalKernel.php/function/DrupalKernel::handle/10)

### 4. 初始化 PHP 环境 (`DrupalKernel::bootEnvironment()`)

初始化一个安全的 PHP 环境，强制某些 PHP 指令具有特定值。
![[Pasted image 20240613155144.png]]

在 `DrupalKernel::bootEnvironment` 中还执行以下操作：

- 加载 `/core/includes/bootstrap.inc` 库，其中包含启动和安装系统时使用的常量和函数。例如，在这里设置了 PHP 的最低版本和所需的最低内存（根据 Drupal 类中定义的常量）。

```php
const DRUPAL_MINIMUM_PHP = \Drupal::MINIMUM_PHP;
const DRUPAL_MINIMUM_PHP_MEMORY_LIMIT = \Drupal::MINIMUM_PHP_MEMORY_LIMIT;
```

- 初始化 Drupal 的错误和异常处理程序。

```php
// 设置 Drupal 自定义错误处理程序。
set_error_handler('_drupal_error_handler');
set_exception_handler('_drupal_exception_handler');
```

[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!DrupalKernel.php/function/DrupalKernel::bootEnvironment/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!DrupalKernel.php/function/DrupalKernel::bootEnvironment/10)

### 5. 初始化设置 (`DrupalKernel::initializeSettings()`)

接下来，从 `DrupalKernel::handle()` 调用 `DrupalKernel::initializeSettings()` 方法。

```php
$this->initializeSettings($request);
```

在此方法中执行以下操作：

- 设置站点路径（`$this->sitePath`）。
- 调用 `Settings::initialize()`，该方法执行以下操作：
  - 包含站点配置文件 `settings.php`。
  - 初始化数据库。请记住，数据库访问数据在 `settings.php` 文件中。
  - 使用 `settings.php` 文件中的配置初始化 `Settings` 对象。
- 进行安全检查以防止通过 HTTP 头部的攻击（`settings.php` 文件中的 `trusted_host_patterns` 参数）。如果未通过此验证，则返回错误并停止站点的执行。

[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!DrupalKernel.php/function/DrupalKernel::initializeSettings/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!DrupalKernel.php/function/DrupalKernel::initializeSettings/10)

### 6. 重定向到 `/core/install.php`

检查 Drupal 是否已安装。如果没有安装，则将用户重定向到安装页面 `/core/install.php`。

### 7. 初始化内核 (`DrupalKernel::boot()`)

在初始化内核时，也初始化服务容器。

```php
// Initialize the container.
$this->initializeContainer();
```

[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!DrupalKernel.php/function/DrupalKernel::boot/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!DrupalKernel.php/function/DrupalKernel::boot/10)

### 8. 其他操作

我们继续在 `DrupalKernel::handle()` 方法中，从这里执行其他操作以生成 `response` 对象。

```php
$response = $this->getHttpKernel()->handle($request, $type, $catch);
```

例如，在 `DrupalKernel::preHandle()` 方法中，执行以下操作：

- 加载核心的 include (.inc) 文件。
- 加载所有活动模块。
- 注册 "stream wrappers"（如 `public://`、`private://`、`temp://` 等）。
- 初始化一些全局变量。

```php
public function preHandle(Request $request) {
  $this->loadLegacyIncludes();
  // Load all enabled modules.
  $this->container->get('module_handler')->loadAll();
  // Register stream wrappers.
  $this->container->get('stream_wrapper_manager')->register();
  // Initialize legacy request globals.
  $this->initializeRequestGlobals($request);
  // Put the request on the stack.
  $this->container->get('request_stack')->push($request);
  // Set the allowed protocols.
  UrlHelper::setAllowedProtocols($this->container->getParameter('filter_protocols'));
  // Override of Symfony's MIME type guesser singleton.
  MimeTypeGuesser::registerWithSymfonyGuesser($this->container);
  $this->prepared = TRUE;
}
```

然后初始化会话，并在 `DrupalKernel::handleRaw()` 方法中调用请求路由的控制器方法。例如，如果我们正在加载一个节点（`/node/1`），用于显示该节点的控制器方法是 `NodeViewController::view`。

[https://api.drupal.org/api/drupal/core!modules!node!src!Controller!NodeViewController.php/class/NodeViewController/10](https://api.drupal.org/api/drupal/core!modules!node!src!Controller!NodeViewController.php/class/NodeViewController/10)

### 9. 获取 `Response` 对象

在完成对 `DrupalKernel::handle()` 方法的调用（步骤 4 到 9）后，我们已经有一个包含所有信息的 `response` 对象，用于呈现请求的页面。

```php
$response = $kernel->handle($request);
```

### 10. 发送 `Response` 对象

接下来，发送 `Response` 对象，包括头部和内容。

```php
$response->send();
```

### 11. 结束 `Request/Response` 过程

过程以调用 `DrupalKernel::terminate()` 方法结束。

```php
$kernel->terminate($request, $response);
```
## 通过事件进行通信

在第 11.4 节中，我们简要介绍了使用 `EventDispatcher` 组件通过事件进行通信。Drupal 10 使用 Symfony 的内核事件，==具体如下==：

- **KernelEvents::CONTROLLER**：当找到与 `Request` 相关的控制器时发生此事件。
- **KernelEvents::EXCEPTION**：当发生未捕获的异常时发生此事件。
- **KernelEvents::FINISH_REQUEST**：当为 `Request` 生成 `Response` 时发生此事件。
- **KernelEvents::REQUEST**：在 `Request` 处理开始时发生此事件。
- **KernelEvents::RESPONSE**：当创建 `Response` 对象时发生此事件。
- **KernelEvents::TERMINATE**：在发送 `Response` 对象后发生此事件。
- **KernelEvents::VIEW**：当控制器未返回 `Response` 对象时发生此事件。

正如我们所见，任何模块都可以订阅一个事件，告诉 `EventDispatcher` 要订阅哪个事件以及当该事件发生时要执行哪个函数或方法。

不仅核心定义事件，任何模块都可以定义自己的事件，允许其他模块在特定点与其交互。事件定义在名为 `模块Events.php` 的文件中。例如，在模块的库中可以找到：

- `/core/lib/Drupal/Core/Config/ConfigEvents.php`
- `/core/lib/Drupal/Core/Entity/EntityTypeEvents.php`
- `/core/lib/Drupal/Core/Render/RenderEvents.php`
- `/core/lib/Drupal/Core/Routing/RoutingEvents.php`
- ...

您可以在以下链接查看核心中所有可用的事件：
[https://api.drupal.org/api/drupal/core!core.api.php/group/events/10](https://api.drupal.org/api/drupal/core!core.api.php/group/events/10)

例如，在 `EntityTypeEvents.php` 中定义了以下事件：

- **EntityTypeEvents::CREATE**：当创建新的实体类型时触发此事件。
- **EntityTypeEvents::UPDATE**：当编辑现有实体类型时触发此事件。
- **EntityTypeEvents::DELETE**：当删除实体类型时触发此事件。

当这些事件中的任何一个被触发时，订阅了这些事件的模块的函数也会被执行，允许在该时刻进行操作。
## Hooks

Hooks 类似于事件，但编程方式相对不太优化。您可以在以下链接查看仍在 Drupal 10 中使用的 hooks：

[https://api.drupal.org/api/drupal/core!core.api.php/group/hooks/10](https://api.drupal.org/api/drupal/core!core.api.php/group/hooks/10)

例如，`hook_user_login()` 在用户登录系统后立即执行。

[https://api.drupal.org/api/drupal/core!modules!user!user.api.php/function/hook_user_login/10](https://api.drupal.org/api/drupal/core!modules!user!user.api.php/function/hook_user_login/10)

任何模块都可以通过创建一个具有 API 中指定参数的函数来实现这个 hook，其名称将是 `module_user_login()`。例如：

- 用户模块实现：`users_user_login($account) { }`
- 自定义模块实现：`mimodulo_user_login($account) { }`
- 示例模块实现：`example_user_login($account) { }`

当用户登录系统时，系统会查询哪些模块实现了 `hook_user_login`，并逐个执行这些函数。

## 服务容器

Drupal 架构中的另一个重要元素是服务容器（见第 11.5 节）。访问 Drupal 服务容器的一种方式是通过全局类 `\Drupal`：

[https://api.drupal.org/api/drupal/core!lib!Drupal.php/class/Drupal/10](https://api.drupal.org/api/drupal/core!lib!Drupal.php/class/Drupal/10)

例如，如果我们想访问当前用户，以检查其是否具有特定权限，可以使用以下代码：

```php
if (\Drupal::currentUser()->hasPermission('administer nodes')) {
  //...
}
```

或者直接调用 `current_user` 服务：

```php
if (\Drupal::service('current_user')->hasPermission('administer nodes')) {
  //...
}
```

服务容器提供了大量可从模块中使用的服务：

[https://api.drupal.org/api/drupal/services](https://api.drupal.org/api/drupal/services)

此外，贡献模块和自定义模块可以添加自己的服务，使其可供其他模块使用。
# 13.5 面向对象编程（POO）在 Drupal 中的应用

Drupal 10 广泛使用了面向对象编程（POO）。在本节中，我们将看到核心中使用继承、接口、traits 和其他与 POO 相关的元素的一些示例。如果对这些概念有疑问，请回顾第 7 和第 8 单元。
## 命名空间

命名空间用于将相关元素分组。在下面的示例中，我们在命名空间 `Drupal\Component\Utility` 中创建了 `Unicode` 类。

文件：`/core/lib/Drupal/Component/Utility/Unicode.php`

```php
<?php
namespace Drupal\Component\Utility;

/**
 * 提供与 Unicode 相关的转换和操作。
 */
class Unicode {
  // 类的具体实现
}
```

`use` 语句告诉系统将使用哪些命名空间。虽然这不是一个真正的 include，但实际上非常类似。自动加载组件会自动加载类，但在每个脚本中，我们通过 `use` 语句指明将使用哪些类及其命名空间。

如果我们想知道上面的 `Unicode` 类在哪里被使用，我们需要搜索包含 `use` 该类的文件：

```php
use Drupal\Component\Utility\Unicode;
```

例如：

```php
<?php
// 文件：/core/lib/Drupal/Core/Database/Driver/mysql/Connection.php
namespace Drupal\Core\Database\Driver\mysql;

use Drupal\Core\Database\DatabaseExceptionWrapper;
use Drupal\Core\Database\Database;
use Drupal\Core\Database\DatabaseNotFoundException;
use Drupal\Core\Database\TransactionCommitFailedException;
use Drupal\Core\Database\DatabaseException;
use Drupal\Core\Database\Connection as DatabaseConnection;
use Drupal\Component\Utility\Unicode;

/**
 * MySQL 实现的 \Drupal\Core\Database\Connection。
 */
class Connection extends DatabaseConnection {
  // 类的具体实现
}
```

在上面的代码中，我们看到使用了其他类，并引用了它们的命名空间和类名。

例如，`Drupal\Core\Database\Database` 引用了命名空间 `Drupal\Core\Database` 中的 `Database` 类。

命名空间与物理文件之间的关系可以在文件 `/vendor/composer/autoload_psr4.php` 中找到。例如：

```php
<?php
'Drupal\\Driver\\' => [$baseDir . '/drivers/lib/Drupal/Driver'],
'Drupal\\Core\\' => [$baseDir . '/core/lib/Drupal/Core'],
'Drupal\\Component\\' => [$baseDir . '/core/lib/Drupal/Component'],
```

在我们的示例中，命名空间 `Drupal\Component\Utility` 对应的物理路径是 `/core/lib/Drupal/Component/Utility`。

在核心模块中，命名空间与模块的 `src` 文件夹有对应关系：

```plaintext
namespace Drupal\comment -> /core/modules/comment/src
namespace Drupal\block\Controller -> /core/modules/block/src/Controller
```

在贡献模块中，命名空间也与模块的 `src` 文件夹对应，无论模块代码在哪里。例如：

```plaintext
namespace Drupal\ctools\Form -> /modules/contrib/ctools/src/Form
namespace Drupal\forcontu_pages\Controller -> /modules/custom/forcontu_pages/src/Controller
```

更多关于命名空间的信息，请参考：
[https://www.drupal.org/docs/develop/coding-standards/namespaces](https://www.drupal.org/docs/develop/coding-standards/namespaces)
## 类的定义与继承

#### 无继承的类定义示例

```php
<?php
// 文件：/core/lib/Drupal/Component/Utility/Unicode.php
namespace Drupal\Component\Utility;

/**
 * 提供与 Unicode 相关的转换和操作。
 */
class Unicode {
  // 类的具体实现
}
```

#### 继承或扩展其他类的示例

如果扩展的类不在同一个命名空间中，则需要使用 `use` 语句引入。

```php
<?php
namespace Drupal\Core\Command;

use Symfony\Component\Console\Command\Command;

class DbCommandBase extends Command {
  // 类的具体实现
}
```

## 抽象类

抽象类示例
```php
<?php
// 文件：/core/lib/Drupal/Core/Controller/FormController.php
namespace Drupal\Core\Controller;

/**
 * 表单中间控制器的通用基类。
 */
abstract class FormController {
  // 抽象类的具体实现
}
```

由于抽象类不能被实例化，其他类必须扩展它才能使用它。在下面的代码中，==因为子类与父类在同一个命名空间==（`Drupal\Core\Controller`）中，所以不需要添加 `use` 语句。

```php
<?php
// 文件：/core/lib/Drupal/Core/Controller/HtmlFormController.php
namespace Drupal\Core\Controller;

/**
 * 用于作为主要页面主体的表单包装控制器。
 */
class HtmlFormController extends FormController {
  // 类的具体实现
}
```
## 接口的实现

接口定义了一组空方法，类在实现这些接口时必须实现这些方法。

在下面的示例中，定义了 `SerializationInterface` 接口。

```php
<?php
// 文件：/core/lib/Drupal/Component/Serialization/SerializationInterface.php
namespace Drupal\Component\Serialization;

/**
 * 定义序列化格式的接口。
 */
interface SerializationInterface {
  /**
   * 将数据编码为序列化格式。
   *
   * @param mixed $data
   *   要编码的数据。
   *
   * @return string
   *   编码后的数据。
   */
  public static function encode($data);

  /**
   * 从序列化格式解码数据。
   *
   * @param string $raw
   *   要解码的原始数据字符串。
   *
   * @return mixed
   *   解码后的数据。
   */
  public static function decode($raw);

  /**
   * 获取此序列化格式的文件扩展名。
   *
   * @return string
   *   文件扩展名，不带前导点。
   */
  public static function getFileExtension();
}
```

一个类通过 `implements` 关键字实现接口：

```php
<?php
namespace Drupal\Component\Serialization;

/**
 * JSON 的默认序列化实现。
 *
 * @ingroup third_party
 */
class Json implements SerializationInterface {
  // 实现接口中的方法
  public static function encode($data) {
    return json_encode($data);
  }

  public static function decode($raw) {
    return json_decode($raw, true);
  }

  public static function getFileExtension() {
    return 'json';
  }
}
```

一个类可以同时扩展另==一个==类并实现==一个或多个==接口：

```php
<?php
// 文件：/core/lib/Drupal/Core/Condition/ConditionManager.php
namespace Drupal\Core\Condition;

use Drupal\Component\Plugin\CategorizingPluginManagerInterface;
use Drupal\Core\Executable\ExecutableManagerInterface;
use Drupal\Core\Plugin\DefaultPluginManager;

//...
class ConditionManager extends DefaultPluginManager implements
  ExecutableManagerInterface, CategorizingPluginManagerInterface {
  // 类的具体实现
}
```
## Traits

Trait 类似于抽象类，因为它定义了自己的方法和属性，并且像抽象类一样，==不能被实例化==。它的目的是将特定功能分组，就像一个库一样，以便其他类可以使用。

一个常用的例子是翻译函数 `t()`，现在它被作为 `StringTranslationTrait` 的方法包含进来。

```php
<?php
// 文件：/core/lib/Drupal/Core/StringTranslation/StringTranslationTrait.php
namespace Drupal\Core\StringTranslation;

trait StringTranslationTrait {
  protected $stringTranslation;

  protected function t($string, array $args = [], array $options = []) {
    return new TranslatableMarkup($string, $args, $options, $this->getStringTranslation());
  }

  // 其他方法...
}
```

要在类中使用一个 trait，可以在类中使用 `use` 语句。一旦包含了 trait，trait 中的所有方法都会像类自身的方法一样可用。

```php
<?php
// 文件：/core/lib/Drupal/Core/Datetime/DateFormatter.php
namespace Drupal\Core\Datetime;

use Drupal\Core\StringTranslation\StringTranslationTrait;

class DateFormatter implements DateFormatterInterface {
  use StringTranslationTrait;

  // 类的具体实现...
  public function someMethod() {
    $string = $this->t('0 seconds');
  }
}
```

其他核心中的 traits：

- **ToStringTrait**
  [https://api.drupal.org/api/drupal/core!lib!Drupal!Component!Utility!ToStringTrait.php/trait/ToStringTrait/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Component!Utility!ToStringTrait.php/trait/ToStringTrait/10)

- **MarkupTrait**
  [https://api.drupal.org/api/drupal/core!lib!Drupal!Component!Render!MarkupTrait.php/trait/MarkupTrait/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Component!Render!MarkupTrait.php/trait/MarkupTrait/10)

- **RedirectDestinationTrait**
  [https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Routing!RedirectDestinationTrait.php/trait/RedirectDestinationTrait/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Routing!RedirectDestinationTrait.php/trait/RedirectDestinationTrait/10)
# 13.6 Drupal API

Drupal API 的所有版本都可以在以下链接访问：
[https://api.drupal.org/api/drupal](https://api.drupal.org/api/drupal)

进入 API 后，我们会看到一系列主题或话题，其中包含具体的文档。查询核心中可用的类、函数和其他元素也非常有用。所有代码都有文档说明，相关元素都有链接，因此 API 成为浏览 Drupal 代码的工具。

以下展示了一个 API 页面，记录了核心中的一个类。我们来看看可以找到哪些类型的信息：

#### 示例：API 文档页面（部分 1）
![[Pasted image 20240614103220.png]]

1. **选择 Drupal 版本**：在这一点上，确保我们在正确的 Drupal 版本中是很重要的。一个有趣的事情是我们可以验证该类是否在下一个版本的 Drupal 中可用并且是否相同，即使它还在开发中。
2. **描述和帮助**：提供类的描述和使用帮助。
3. **层次结构**：显示与其他元素的关系（继承、接口、traits 等）。
4. **另见**：显示相关链接。

#### 示例：API 文档页面（部分 2）
![[Pasted image 20240614112134.png]]
5. **相关主题**：链接到相关主题。通常链接到这个页面中的主题：[https://www.drupal.org/docs/drupal-apis](https://www.drupal.org/docs/drupal-apis)
6. **“X 个文件声明使用…”**：从这里可以访问使用该类、方法、函数等的文件。这对我们==作为示例代码非常有用==。
7. **文件**：链接到包含该类的文件。
8. **命名空间**：命名空间和源代码。允许我们查看同一命名空间中可用的其他元素。
9. **类的属性和方法列表**：包括一组过滤器以便于搜索。

请记住，这些元素中的许多都链接到其他元素，这使我们能够通过 API 浏览并发现更详细的信息。