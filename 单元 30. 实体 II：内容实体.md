
在本单元中，我们将学习如何创建内容实体和字段。
### 单元内容

30.1 内容实体
30.2 创建自定义内容类型
30.3 自定义字段
30.4 实体主题化
30.5 分类法编程
30.6 实体验证
30.7 路由访问和实体操作
30.8 实体子类型类（bundle class）
30.9 使用控制台

# 30.1 内容实体

我们再次推荐使用 Drush Generate 来生成内容实体类型的骨架。定义内容实体所需的文件数量多于配置实体，如果尝试从零开始创建，容易出错。

作为示例，我们将创建一个名为 `Message`（消息）的内容实体类型，ID 为 `forcontu_entities_message`。该实体允许站点用户之间发送消息。实体将具有多个 bundle，因此可以定义不同类型的消息。为了简化，实体不可翻译，也不支持消息的修订版本。

每个消息将具有以下属性：
- 收件人（user_to）：引用站点用户。
- 主题（subject）：文本，限制为 100 个字符。
- 内容（content）：长文本。
- 已读（is_read）：布尔类型字段，接受 FALSE（未读）和 TRUE（已读）值。此属性不可由用户填写。

我们将逐步查看创建实体所需的文件。请参阅本单元的最后一部分以了解如何使用 Drush Generate 创建实体。

### Message 实体类

在第一步中，我们将创建接口和实现实体的类。

接口扩展 `ContentEntityInterface`、`EntityChangedInterface` 和 `EntityOwnerInterface`。根据其他特性，还可以扩展其他接口。

在接口中，我们声明实体字段的 `get` 和 `set` 方法。与配置实体不同，内容实体的附加属性将定义为字段（基础字段）。稍后我们将看到具体实现。

不要忘记适当地注释这些方法。通常，我们会在接口中添加注释，并在实现该接口的类中继承这些注释。

文件：`src/Entity/MessageInterface.php`

```php
<?php
namespace Drupal\forcontu_entities\Entity;

use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\Core\Entity\EntityChangedInterface;
use Drupal\user\EntityOwnerInterface;

/**
 * Provides an interface for defining Message entities.
 *
 * @ingroup forcontu_entities
 */
interface MessageInterface extends ContentEntityInterface, EntityChangedInterface, EntityOwnerInterface {
  // Add get/set methods for your configuration properties here.

  /**
   * Gets the Message type.
   *
   * @return string
   *   The Message type.
   */
  public function getType();

  /**
   * Gets the Message subject.
   *
   * @return string
   *   Subject of the Message.
   */
  public function getSubject();

  /**
   * Sets the Message subject.
   *
   * @param string $subject
   *   The Message subject.
   *
   * @return \Drupal\forcontu_entities\Entity\MessageInterface
   *   The called Message entity.
   */
  public function setSubject($subject);

  /**
   * Gets the Message creation timestamp.
   *
   * @return int
   *   Creation timestamp of the Message.
   */
  public function getCreatedTime();

  /**
   * Sets the Message creation timestamp.
   *
   * @param int $timestamp
   *   The Message creation timestamp.
   *
   * @return \Drupal\forcontu_entities\Entity\MessageInterface
   *   The called Message entity.
   */
  public function setCreatedTime($timestamp);

  /**
   * Returns the Message published status indicator.
   *
   * Unpublished Message are only visible to restricted users.
   *
   * @return bool
   *   TRUE if the Message is published.
   */
  public function isPublished();

  /**
   * Sets the published status of a Message.
   *
   * @param bool $published
   *   TRUE to set this Message to published, FALSE to set it to unpublished.
   *
   * @return \Drupal\forcontu_entities\Entity\MessageInterface
   *   The called Message entity.
   */
  public function setPublished($published);

  /**
   * Gets the To user id.
   *
   * @return int
   *   The user id.
   */
  public function getUserToId();

  /**
   * Sets the To user id.
   *
   * @param int $uid
   *   To user id.
   *
   * @return $this
   */
  public function setUserToId($uid);

  /**
   * Gets the To user object.
   *
   * @return UserInterface
   *   The user object.
   */
  public function getUserTo();

  /**
   * Sets the To user object.
   *
   * @param string $account
   *   The user object.
   *
   * @return $this
   */
  public function setUserTo(UserInterface $account);

  /**
   * Gets the Content.
   *
   * @return string
   *   Message content.
   */
  public function getContent();

  /**
   * Sets the message's content.
   *
   * @param string $content
   *   Message's content.
   *
   * @return $this
   */
  public function setContent($content);

  /**
   * Returns the Message read indicator.
   *
   * @return bool
   */
  public function isRead();

  /**
   * Sets the read status of a Message.
   *
   * @param bool $read
   *   TRUE to set this Message to read.
   *
   * @return $this
   */
  public function setRead($read);
}
```

接下来，我们实现 `Message` 类，该类扩展 `ContentEntityBase` 并实现上述接口。请记住，虽然实体类型的系统名称或 ID 包含模块名称作为前缀，但类名不需要这样做。

类具有注解格式的注释头，在 `@ContentEntityType` 指令中定义实体的属性。

文件：`src/Entity/Message.php`（注解）

```php
<?php
namespace Drupal\forcontu_entities\Entity;

use Drupal\Core\Entity\EntityStorageInterface;
use Drupal\Core\Field\BaseFieldDefinition;
use Drupal\Core\Entity\ContentEntityBase;
use Drupal\Core\Entity\EntityChangedTrait;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\user\UserInterface;

/**
 * Defines the Message entity.
 *
 * @ingroup forcontu_entities
 *
 * @ContentEntityType(
 *   id = "forcontu_entities_message",
 *   label = @Translation("Message"),
 *   bundle_label = @Translation("Message type"),
 *   handlers = {
 *     "view_builder" = "Drupal\Core\Entity\EntityViewBuilder",
 *     "list_builder" = "Drupal\forcontu_entities\MessageListBuilder",
 *     "views_data" = "Drupal\forcontu_entities\Entity\MessageViewsData",
 *     "form" = {
 *       "default" = "Drupal\forcontu_entities\Form\MessageForm",
 *       "add" = "Drupal\forcontu_entities\Form\MessageForm",
 *       "edit" = "Drupal\forcontu_entities\Form\MessageForm",
 *       "delete" = "Drupal\forcontu_entities\Form\MessageDeleteForm",
 *     },
 *     "access" = "Drupal\forcontu_entities\MessageAccessControlHandler",
 *     "route_provider" = {
 *       "html" = "Drupal\forcontu_entities\MessageHtmlRouteProvider",
 *     },
 *   },
 *   base_table = "forcontu_entities_message",
 *   admin_permission = "administer message entities",
 *   entity_keys = {
 *     "id" = "id",
 *     "bundle" = "type",
 *     "label" = "subject",
 *     "uuid" = "uuid",
 *     "uid" = "user_id",
 *     "langcode" = "langcode",
 *     "status" = "status",
 *   },
 *   links = {
 *     "canonical" = "/admin/structure/forcontu_entities_message/{forcontu_entities_message}",
 *     "add-page" = "/admin/structure/forcontu_entities_message/add",
 *     "add-form" = "/admin/structure/forcontu_entities_message/add/{forcontu_entities_message_type}",
 *     "edit-form" = "/admin/structure/forcontu_entities_message/{forcontu_entities_message}/edit",
 *     "delete-form" = "/admin/structure/forcontu_entities_message/{forcontu_entities_message}/delete",
 *     "collection" = "/admin/structure/forcontu_entities_message",
 *   },
 *   bundle_entity_type = "forcontu_entities_message_type",
 *   field_ui_base_route = "entity.forcontu_entities_message_type.edit_form"
 * )
 */
```

在 `@ContentEntityType` 中，我们定义了以下属性：
- `base_table`：用于存储 Message 类型实体的表名。
- `bundle_label`：此实体的 bundle 类型标签。
- 在 `entity_keys` 中：
  - `bundle` = `type`：bundle 的内部名称为 `type`，因此我们将创建消息类型。这类似于内容类型，其中 bundle 也标识为 `type`。
  - ==`label` = `subject`：每个消息的标签对应于 `subject` 字段（消息主题）==。这是我们在使用 Drush Generate 生成文件后唯一更改的地方。
- `bundle_entity_type`：存储 bundle 信息的配置实体类型名称。

在同一文件中，我们定义 `Message` 类，指明其属性和接口要求的方法。与配置实体不同，附加属性不会在此处作为属性添加。

文件：`src/Entity/Message.php`（类）

```php
class Message extends ContentEntityBase implements MessageInterface {
  use EntityChangedTrait;

  /**
   * {@inheritdoc}
   */
  public static function preCreate(EntityStorageInterface $storage_controller, array &$values) {
    parent::preCreate($storage_controller, $values);
    $values += [
      'user_id' => \Drupal::currentUser()->id(),
    ];
  }

  public function getType() {
    return $this->bundle();
  }

  public function getSubject() {
    return $this->get('subject')->value;
  }

  public function setSubject($subject) {
    $this->set('subject', $subject);
    return $this;
  }

  public function getCreatedTime() {
    return $this->get('created')->value;
  }

  public function setCreatedTime($timestamp) {
    $this->set('created', $timestamp);
    return $this;
  }

  public function getOwner() {
    return $this->get('user_id')->entity;
  }

  public function getOwnerId() {
    return $this->get('user_id')->target_id;
  }

  public function setOwnerId($uid) {
    $this->set('user_id', $uid);
    return $this;
  }

  public function setOwner(UserInterface $account) {
    $this->set('user_id', $account->id());
    return $this;
  }

  public function isPublished() {
    return (bool) $this->getEntityKey('status');
  }

  public function setPublished($published) {
    $this->set('status', $published ? TRUE : FALSE);
    return $this;
  }

  public function getUserToId() {
    return $this->get('user_to')->target_id;
  }

  public function setUserToId($uid) {
    $this->set('user_to', $uid);
    return $this;
  }

  public function getUserTo() {
    return $this->get('user_to')->entity;
  }

  public function setUserTo(UserInterface $account) {
    $this->set('user_to', $account->id());
    return $this;
  }

  public function getContent() {
    return $this->get('content')->value;
  }

  public function setContent($content) {
    $this->set('content', $content);
    return $this;
  }

  public function isRead() {
    return (bool) $this->getEntityKey('is_read');
  }

  public function setRead($read) {
    $this->set('is_read', $read ? TRUE : FALSE);
    return $this;
  }

  // ...
```

在 `baseFieldDefinitions()` 方法中，我们定义实体的基础字段。这些字段虽然构建为 Field API 字段，但用户无法通过“管理字段”界面修改。它们是直接存储在实体基础表（`forcontu_entities_message`）中的基础字段。

文件：`src/Entity/Message.php`（字段）

```php
public static function baseFieldDefinitions(EntityTypeInterface $entity_type) {
  $fields = parent::baseFieldDefinitions($entity_type);

  $fields['user_id'] = BaseFieldDefinition::create('entity_reference')
    ->setLabel(t('Authored by'))
    ->setDescription(t('The user ID of author of the Message entity.'))
    ->setRevisionable(TRUE)
    ->setSetting('target_type', 'user')
    ->setSetting('handler', 'default')
    ->setTranslatable(TRUE)
    // setDisplayOptions 是不必要的，因为可以在页面中修改
    ->setDisplayOptions('view', [
      'label' => 'hidden',
      'type' => 'author',
      'weight' => 0,
    ])
    ->setDisplayOptions('form', [
      'type' => 'entity_reference_autocomplete',
      'weight' => 5,
      'settings' => [
        'match_operator' => 'CONTAINS',
        'size' => '60',
        'autocomplete_type' => 'tags',
        'placeholder' => '',
      ],
    ])
    ->setDisplayConfigurable('form', TRUE)
    ->setDisplayConfigurable('view', TRUE);

  $fields['user_to'] = BaseFieldDefinition::create('entity_reference')
    ->setLabel(t('To'))
    ->setDescription(t('The user ID of the Message recipient.'))
    ->setRevisionable(TRUE)
    ->setSetting('target_type', 'user')
    ->setSetting('handler', 'default')
    ->setTranslatable(TRUE)
    ->setDisplayOptions('view', [
      'label' => 'To',
      'type' => 'author',
      'weight' => 0,
    ])
    ->setDisplayOptions('form', [
      'type' => 'entity_reference_autocomplete',
      'weight' => 5,
      'settings' => [
        'match_operator' => 'CONTAINS',
        'size' => '60',
        'autocomplete_type' => 'tags',
        'placeholder' => '',
      ],
    ])
    ->setDisplayConfigurable('form', TRUE)
    ->setDisplayConfigurable('view', TRUE);

  $fields['subject'] = BaseFieldDefinition::create('string')
    ->setLabel(t('Subject'))
    ->setDescription(t('The subject of the Message entity.'))
    ->setSettings([
      'max_length' => 100,
      'text_processing' => 0,
    ])
    ->setDefaultValue('')
    ->setDisplayOptions('view', [
      'label' => 'above',
      'type' => 'string',
      'weight' => -4,
    ])
    ->setDisplayOptions('form', [
      'type' => 'string_textfield',
      'weight' => -4,
    ])
    ->setDisplayConfigurable('form', TRUE)
    ->setDisplayConfigurable('view', TRUE);

  $fields['content'] = BaseFieldDefinition::create('text_long')
    ->setLabel(t('Content'))
    ->setDescription(t('The content of the Message'))
    ->setTranslatable(TRUE)
    ->setDisplayOptions('view', [
      'label' => 'hidden',
      'type' => 'text_default',
      'weight' => 0,
    ])
    ->setDisplayConfigurable('view', TRUE)
    ->setDisplayOptions('form', [
      'type' => 'text_textfield',
      'weight' => 0,
    ])
    ->setDisplayConfigurable('form', TRUE);

  $fields['is_read'] = BaseFieldDefinition::create('boolean')
    ->setLabel(t('Read'))
    ->setDescription(t('A boolean indicating whether the Message is read.'))
    ->setDefaultValue(FALSE);

  $fields['status'] = BaseFieldDefinition::create('boolean')
    ->setLabel(t('Publishing status'))
    ->setDescription(t('A boolean indicating whether the Message is published.'))
    ->setDefaultValue(TRUE);

  $fields['created'] = BaseFieldDefinition::create('created')
    ->setLabel(t('Created'))
    ->setDescription(t('The time that the entity was created.'));

  $fields['changed'] = BaseFieldDefinition::create('changed')
    ->setLabel(t('Changed'))
    ->setDescription(t('The time that the entity was last edited.'));

  return $fields;
}
```

我们添加的字段包括：
- `user_to`：类型为 `entity_reference`，目标实体类型为 `user`。
- `subject`：类型为 `string`，限制为 100 个字符。
- `content`：类型为 `text_long`。
- `is_read`：布尔类型字段，指示消息是否已读。

注意：在为字段命名时要小心，特别是使用英文时。这些名称将成为基础表中的列名，如果使用 MySQL 保留字，生成的查询可能会出错。请参阅 MySQL 保留字列表：
[https://dev.mysql.com/doc/refman/5.7/en/keywords.html](https://dev.mysql.com/doc/refman/5.7/en/keywords.html)

更多关于字段定义的信息，请参阅：
[https://www.drupal.org/docs/drupal-apis/entity-api/defining-and-using-content-entity-field-definitions](https://www.drupal.org/docs/drupal-apis/entity-api/defining-and-using-content-entity-field-definitions)

#### PS ==关于字段设置==
```PHP
  $fields['user_id'] = BaseFieldDefinition::create('entity_reference')
    ->setLabel(t('Authored by'))
    ->setDescription(t('The user ID of author of the Message entity.'))
    ->setRevisionable(TRUE)
    ->setSetting('target_type', 'user')
    ->setSetting('handler', 'default')
    ->setTranslatable(TRUE)
    // setDisplayOptions 是不必要的，因为可以在页面中修改
    ->setDisplayOptions('view', [
      'label' => 'hidden',
      'type' => 'author',
      'weight' => 0,
    ])
    ->setDisplayOptions('form', [
      'type' => 'entity_reference_autocomplete',
      'weight' => 5,
      'settings' => [
        'match_operator' => 'CONTAINS',
        'size' => '60',
        'autocomplete_type' => 'tags',
        'placeholder' => '',
      ],
    ])
    ->setDisplayConfigurable('form', TRUE)
    ->setDisplayConfigurable('view', TRUE);
```
1.  ==setDisplayOptions== 是不必要的，因为可以在页面中修改
![[Pasted image 20240625145224.png]]

2. ==setDisplayOptions== 和 ==setDisplayConfigurable== 方法的第一个参数代表的含义：

==form== 代表的是实体的 `Manage format display` 的设置，`setDisplayOptions` 中的设置体现在管理员创建实体的页面，但可以在`Manage format display` 页面修改。可以修改的前提是 `setDisplayConfigurable` 方法的第二个参数设置为 `true`，如果设置为 `false`，该字段的将不会显示在`Manage format display` 页面.
![[Pasted image 20240625145518.png]]

==view== 代表的是实体的 `Manage display` 的设置，`setDisplayOptions` 中的设置体现在前端展示的页面，但可以在`Manage format display` 页面修改。可以修改的前提是 `setDisplayConfigurable` 方法的第二个参数设置为 `true`，如果设置为 `false`，该字段的将不会显示在`Manage display` 页面，同时前端页面也不会显示了。
![[Pasted image 20240625150006.png]]

### 路由和菜单链接的定义

我们已经讨论了两种可能的方法：静态路由和动态路由。这里我们再次使用 Drush Generate 生成的方法。

链接（links）通过注解（Annotation）在 `Message` 类中定义。路由提供者类在实体的处理程序中设置（也在注解中）：

```php
"route_provider" = {
  "html" = "Drupal\forcontu_entities\MessageHtmlRouteProvider",
}
```

查看由 Drush Generate 生成的文件 `src/MessageHtmlRouteProvider.php`。原则上我们不需要对该文件进行任何修改。如果我们想更改路由，可以在实体的注解定义中进行。

以下文件定义了与实体管理相关的菜单链接、操作链接和选项卡：
- `forcontu_entities.links.menu.yml`
- `forcontu_entities.links.task.yml`
- `forcontu_entities.links.action.yml`

### 实体控制类

现在我们需要定义允许管理 `Message` 类型实体的页面。回到实体注解定义中的 `handlers` 部分，查看需要创建的类。

我们从列出已创建实体的页面开始（`src/MessageListBuilder.php`）。在 `buildHeader()` 方法中定义表头，在 `buildRow()` 方法中构建每一行，指明每列的值。表单元素的名称必须与实体属性的名称一致。

此外，我们注入了 `date.formatter` 服务，用于处理日期格式。为此，我们创建了 `__construct()` 和 `createInstance` 方法。在注入额外服务之前，请复习命名规则和必需参数。这些必需参数由父类的构造函数决定。

在表中，我们添加了 `From`、`To`、`Subject`（重用 `Name`）和 `Created` 字段。要获取这些值，我们使用 `Message` 类中定义的方法。`label()` 方法是一个继承方法，返回实体的标签。在我们的例子中，该值对应于 `subject`，如注解定义中所述。

文件：`src/MessageListBuilder.php`

```php
<?php
namespace Drupal\forcontu_entities;

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityListBuilder;
use Drupal\Core\Routing\LinkGeneratorTrait;
use Drupal\Core\Url;
use Drupal\Core\Datetime\DateFormatterInterface;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Entity\EntityStorageInterface;

/**
 * Defines a class to build a listing of Message entities.
 *
 * @ingroup forcontu_entities
 */
class MessageListBuilder extends EntityListBuilder {
  use LinkGeneratorTrait;
  protected $dateFormatter;

  public function __construct(EntityTypeInterface $entity_type, EntityStorageInterface $storage, DateFormatterInterface $date_formatter) {
    parent::__construct($entity_type, $storage);
    $this->dateFormatter = $date_formatter;
  }

  /**
   * {@inheritdoc}
   */
  public static function createInstance(ContainerInterface $container, EntityTypeInterface $entity_type) {
    return new static(
      $entity_type,
      $container->get('entity_type.manager')->getStorage($entity_type->id()),
      $container->get('date.formatter')
    );
  }

  /**
   * {@inheritdoc}
   */
  public function buildHeader() {
    $header['id'] = $this->t('Message ID');
    $header['from'] = $this->t('From');
    $header['to'] = $this->t('To');
    $header['subject'] = $this->t('Subject');
    $header['created'] = $this->t('Created');

    return $header + parent::buildHeader();
  }

  /**
   * {@inheritdoc}
   */
  public function buildRow(EntityInterface $entity) {
    /* @var $entity \Drupal\forcontu_entities\Entity\Message */

    $row['id'] = $entity->id();
    $row['from'] = $entity->getOwner()->getAccountName();
    $row['to'] = $entity->getUserTo()->getAccountName();

    $row['subject'] = $this->l(
      $entity->label(),
      new Url(
        'entity.forcontu_entities_message.edit_form', [
          'forcontu_entities_message' => $entity->id(),
        ]
      )
    );
    $row['created'] = $this->dateFormatter->format($entity->getCreatedTime(), 'short');
    return $row + parent::buildRow($entity);
  }
}
```

`MessageForm` 表单（`src/Form/MessageForm.php`）用于创建和编辑 `Message` 类型实体。原则上我们不需要进行任何修改，但可以添加 `validateForm()` 方法以包含字段验证。

`MessageDeleteForm` 表单（`src/Form/MessageDeleteForm.php`）允许删除实体。我们不需要进行任何修改。

`MessageViewsData` 类（`src/Entity/MessageViewsData`）允许实体与视图集成。我们不需要进行任何修改。

### Bundles

为了创建 bundles 或消息类型，我们定义了配置实体 `MessageType`。由于这是一个配置实体，生成的文件与前一单元中研究的文件相同。原则上我们不需要修改这些文件：
- `src/Entity/MessageType.php`：`MessageType` 实体的主类。
- `src/Entity/MessageTypeInterface.php`：实体接口。
- `src/Form/MessageTypeForm.php`：创建/编辑消息类型的表单。
- `src/Form/MessageTypeDeleteForm.php`：删除消息类型的表单。
- `src/MessageTypeHtmlRouteProvider.php`：路由提供者。
- `src/MessageTypeListBuilder.php`：生成消息类型管理页面。
- `config/schema/forcontu_entities_message_type.schema`：配置架构。

### 权限

用于消息不同操作的权限在 `forcontu_entities.permissions.yml` 文件中声明：

```yaml
forcontu_entities.permissions.yml
add message entities:
  title: 'Create new Message entities'
administer message entities:
  title: 'Administer Message entities'
  description: 'Allow to access the administration form to configure Message entities.'
  restrict access: true
delete message entities:
  title: 'Delete Message entities'
edit message entities:
  title: 'Edit Message entities'
access message overview:
  title: 'Access the Message overview page'
view published message entities:
  title: 'View published Message entities'
view unpublished message entities:
  title: 'View unpublished Message entities'
```

在 `src/MessageAccessControlHandler.php` 文件中实现了使用这些权限的逻辑。除非我们想更改访问逻辑，否则不需要修改该文件。

### 主题

在实体实现中添加了以下模板：
- `templates/forcontu-entities-message-content-add-list.html.twig`：显示消息列表的模板。
- `templates/forcontu_entities_message.html.twig`：用于显示消息的模板。与此模板关联，在 `forcontu_entities_message.page.inc` 文件中实现了一个预处理函数，该函数将实体作为变量添加以进行表示。

模板在 `forcontu_entities.module` 文件中通过实现 `hook_theme` 定义。还根据 bundle、显示模式和实体 ID 添加了模板建议。

```php
<?php
/**
 * Implements hook_theme().
 */
function forcontu_entities_theme() {
  $theme = [];
  $theme['forcontu_entities_message'] = [
    'render element' => 'elements',
    'file' => 'forcontu_entities_message.page.inc',
    'template' => 'forcontu_entities_message',
  ];
  $theme['forcontu_entities_message_content_add_list'] = [
    'render element' => 'content',
    'variables' => ['content' => NULL],
    'file' => 'forcontu_entities_message.page.inc',
  ];
  return $theme;
}

/**
 * Implements hook_theme_suggestions_HOOK().
 */
function forcontu_entities_theme_suggestions_forcontu_entities_message(array $variables) {
  $suggestions = [];
  $entity = $variables['elements']['#forcontu_entities_message'];
  $sanitized_view_mode = strtr($variables['elements']['#view_mode'], '.', '_');
  $suggestions[] = 'forcontu_entities_message__' . $sanitized_view_mode;
  $suggestions[] = 'forcontu_entities_message__' . $entity->bundle();
  $suggestions[] = 'forcontu_entities_message__' . $entity->bundle() . '__' . $sanitized_view_mode;
  $suggestions[] = 'forcontu_entities_message__' . $entity->id();
  $suggestions[] = 'forcontu_entities_message__' . $entity->id() . '__' . $sanitized_view_mode;
}
```

### 注册新实体

如果像我们的情况一样，在完成新实体的实现之前模块已经安装，实体表将不会创建。

要注册新实体，可以运行以下 Drush 命令：

```sh
drush entity-updates
drush entup
```

该命令在安装模块后可用：
[https://www.drupal.org/project/devel_entity_updates](https://www.drupal.org/project/devel_entity_updates)

如果检测到实体配置更改，系统将更新它们：

```sh
$ drush entity-updates
The following updates are pending:
forcontu_entities_message entity type :
  El tipo de entidad Mensaje necesita ser instalado.
forcontu_entities_section entity type :
  El tipo de entidad Section necesita ser instalado.
forcontu_entities_message_type entity type :
  El tipo de entidad Message type necesita ser instalado.
Do you wish to run all pending updates? (y/n): y
Cache rebuild complete. [ok]
Finished performing updates. [ok]
```

每当我们进行配置更改且不确定是否影响数据库时，都可以使用此命令。

### 创建消息类型

在我们的实现中，没有定义任何默认的 bundle（或消息类型），因此在创建消息之前，我们需要创建一个类型。我们将其命名为 `Basic`，并从以下路径创建：

```
管理 -> 结构 -> Message Type
```

如图所示，每种消息类型将关联一组典型的内容实体选项（管理字段、管理表单显示和管理显示）。其功能与站点构建级别的功能相同。

### 创建消息

现在我们可以从以下路径创建新的 `Basic` 类型消息：

```
管理 -> 结构 -> Message List [Add Message]
```

创建的消息将显示在消息列表中，我们可以从中执行典型操作（查看、编辑和删除）。

### 基础表

数据存储在基础表中，因为所有字段都定义为基础字段。通过管理字段或编程添加到消息类型的附加字段将存储在附加表中。

### 与视图的集成

我们的实现与视图完全集成，无需添加额外代码。例如，我们实现了 `Mensajes recibidos` 视图，仅显示发送给当前用户的消息。除了与 `Message` 实体相关的权限外，用户还需要能够访问其他用户的个人资料。

创建视图时，我们可以将新实体类型 `Message` 添加为视图的主要元素。其余配置与站点构建级别的配置相同。

# 30.2 创建自定义内容类型

在 `Message` 实体的实现中，我们没有实现任何默认的 bundle 或类型。虽然在本节中我们将看到如何创建一个新的内容类型（节点实体的 bundle），但这适用于任何具有 bundle 的内容实体类型。

在 Drupal 10 中，新的 bundle 的实现是通过配置文件完成的。在模块安装期间，系统将根据这些配置生成新的 bundle。

在第 17.3 节中，我们已经看到配置架构文件用于描述模块配置文件的结构。一个模块可以有多个配置架构文件，尽管通常会创建一个文件来指定所有配置对象的结构。该文件将命名为 `module.schema.yml`，并位于模块的 `/config/schema` 文件夹中。

让我们看看用于创建新内容类型的配置文件及其相应的架构。这些文件位于 `/config/install` 文件夹中。

### 内容类型的声明

文件：`forcontu_entities/config/install/node.type.news.yml`

这是主要文件，用于声明内容类型及其默认配置。在以下示例中，我们创建了内容类型 `News`（新闻）。建议至少修改以下参数：

- `langcode`：如果我们使用西班牙语作为基础语言，可以将其更改为 `es`。
- `description`：添加内容类型的描述。

```yaml
langcode: en
status: true
dependencies:
  module:
    - menu_ui
  enforced:
    module:
      - forcontu_entities
third_party_settings:
  menu_ui:
    available_menus:
      - main
    parent: 'main:'
name: News
type: news
description: 'News content type'
help: ''
new_revision: false
preview_mode: 1
display_submitted: true
```

此配置文件中定义的参数来自文件 `/core/modules/node/config/schema/node.schema.yml`：

```yaml
node.type.*:
  type: config_entity
  label: 'Content type'
  mapping:
    name:
      type: label
      label: 'Name'
    type:
      type: string
      label: 'Machine-readable name'
    description:
      type: text
      label: 'Description'
    help:
      type: text
      label: 'Explanation or submission guidelines'
    new_revision:
      type: boolean
      label: 'Whether a new revision should be created by default'
    preview_mode:
      type: integer
      label: 'Preview before submitting'
    display_submitted:
      type: boolean
      label: 'Display setting for author and date Submitted by post information'
```

在上述架构文件中定义了内容实体的特定参数。此外，由于它是 `config_entity` 类型，我们还需要查找配置实体可用的参数。该架构可以在文件 `/core/config/schema/core.entity.schema.yml` 中找到：

```yaml
config_entity:
  type: mapping
  mapping:
    uuid:
      type: string
      label: 'UUID'
    langcode:
      type: string
      label: 'Language code'
    status:
      type: boolean
      label: 'Status'
    dependencies:
      type: config_dependencies
      label: 'Dependencies'
    third_party_settings:
      type: sequence
      label: 'Third party settings'
      sequence:
        type: '[%parent.%parent.%type].third_party.[%key]'
    _core:
      type: _core_config_info
```

在内容类型的定义中，我们发现了与 `menu_ui` 模块的依赖关系。在 `third_party_settings` 下，可以包含与这些声明为依赖项的模块相关的配置参数。

```yaml
dependencies:
  module:
    - menu_ui
third_party_settings:
  menu_ui:
    available_menus:
      - main
    parent: 'main:'
```

这些与 `menu_ui` 模块相关的参数在哪里定义？我们需要查看 `menu_ui` 模块的配置架构。在文件 `/core/modules/menu_ui/config/schema/menu_ui.schema.yml` 中，我们可以找到所需的架构：

```yaml
node.type.*.third_party.menu_ui:
  type: mapping
  label: 'Per-content type menu settings'
  mapping:
    available_menus:
      type: sequence
      label: 'Available menus'
      sequence:
        type: string
        label: 'Menu machine name'
    parent:
      type: string
      label: 'Parent'
```

### 内容类型的卸载

为了在卸载模块时强制卸载内容类型，可以添加与实现该内容类型的模块的强制依赖：

```yaml
dependencies:
  module:
    - menu_ui
  enforced:
    module:
      - forcontu_entities
```

### 额外字段

文件：`forcontu_entities/config/install/field.field.node.news.body.yml`

添加一个 `Body` 字段。通过这种方式添加的字段不是基础字段，可以通过界面进行配置（甚至删除）。因此，在内容类型中，`Body` 字段是可选的，而 `Title` 字段是必需的（`Title` 是基础字段）。

我们将为每个要添加到内容类型的额外字段创建一个独立的文件。

```yaml
langcode: en
status: true
dependencies:
  config:
    - field.storage.node.body
    - node.type.news
  module:
    - text
id: node.news.body
field_name: body
entity_type: node
bundle: news
label: Body
description: ''
required: false
translatable: true
default_value: { }
default_value_callback: ''
settings:
  display_summary: true
field_type: text_with_summary
```

字段的基本配置架构可以在文件 `/core/config/schema/core.data_types.schema.yml` 中找到：

```yaml
field_config_base:
  type: config_entity
  mapping:
    id:
      type: string
      label: 'ID'
    field_name:
      type: string
      label: 'Field name'
    entity_type:
      type: string
      label: 'Entity type'
    bundle:
      type: string
      label: 'Bundle'
    label:
      type: label
      label: 'Label'
    description:
      type: text
      label: 'Help text'
    required:
      type: boolean
      label: 'Required field'
    translatable:
      type: boolean
      label: 'Translatable'
    default_value:
      type: sequence
      label: 'Default values'
      sequence:
        type: field.value.[%parent.%parent.field_type]
        label: 'Default value'
    default_value_callback:
      type: string
      label: 'Default value callback'
    settings:
      type: field.field_settings.[%parent.field_type]
    field_type:
      type: string
      label: 'Field type'
```

由于这是一个 `text_with_summary` 类型的字段，我们需要在实现该字段的模块中查找其配置架构。在这种情况下，它是核心模块 `text`，架构可以在以下文件中找到：

```yaml
/core/modules/text/config/schema/text.schema.yml
```

第一个使用的架构是提供 `settings` 内属性的架构。我们需要找到指定的配置组：

```yaml
type: field.field_settings.[%parent.field_type]
```

因此，`text_with_summary` 的相应架构为：

```yaml
field.field_settings.text_with_summary:
  type: mapping
  label: 'Text (formatted, long, with summary) settings'
  mapping:
    display_summary:
      type: boolean
      label: 'Summary input'
```

通过这种方式浏览配置架构，我们可以找到所有可用的属性。

### 内容类型的展示

##### 文件：`forcontu_entities/config/install/core.entity_view_display.node.news.default.yml`

定义默认展示选项（管理展示），用于默认展示模式（default）：

```yaml
langcode: en
status: true
dependencies:
  config:
    - field.field.node.news.body
    - node.type.news
  module:
    - text
    - user
id: node.news.default
targetEntityType: node
bundle: news
mode: default
content:
  body:
    label: hidden
    type: text_default
    weight: 101
    settings: { }
    third_party_settings: { }
  links:
    weight: 100
hidden: { }
```

查看配置架构 `core.entity_view_display.*.*.*` 在 `/core/config/schema/core.entity.schema.yml` 中。

##### 文件：`forcontu_entities/config/install/core.entity_view_display.node.news.teaser.yml`

定义默认展示选项（管理展示），用于摘要展示模式（teaser）：

```yaml
langcode: en
status: true
dependencies:
  config:
    - core.entity_view_mode.node.teaser
    - field.field.node.news.body
    - node.type.news
  module:
    - text
    - user
id: node.news.teaser
targetEntityType: node
bundle: news
mode: teaser
content:
  body:
    label: hidden
    type: text_summary_or_trimmed
    weight: 101
    settings:
      trim_length: 600
    third_party_settings: { }
  links:
    weight: 100
hidden: { }
```

### 表单展示

##### 文件：`config/install/core.entity_form_display.node.news.default.yml`

定义内容类型创建/编辑表单的展示选项（管理表单展示）：

```yaml
langcode: en
status: true
dependencies:
  config:
    - field.field.node.news.body
    - node.type.news
  module:
    - path
    - text
id: node.news.default
targetEntityType: node
bundle: news
mode: default
content:
  body:
    type: text_textarea_with_summary
    weight: 31
    settings:
      rows: 9
      summary_rows: 3
      placeholder: ''
    third_party_settings: { }
  created:
    type: datetime_timestamp
    weight: 10
    settings: { }
    third_party_settings: { }
  path:
    type: path
    weight: 30
    settings: { }
    third_party_settings: { }
  promote:
    type: boolean_checkbox
    settings:
      display_label: true
    weight: 15
    third_party_settings: { }
  sticky:
    type: boolean_checkbox
    settings:
      display_label: true
    weight: 16
    third_party_settings: { }
  title:
    type: string_textfield
    weight: -5
    settings:
      size: 60
      placeholder: ''
    third_party_settings: { }
  uid:
    type: entity_reference_autocomplete
    weight: 5
    settings:
      match_operator: CONTAINS
      size: 60
      placeholder: ''
    third_party_settings: { }
hidden: { }
```

查看配置架构 `core.entity_form_display.*.*.*` 在 `/core/config/schema/core.entity.schema.yml` 中。

### 注册新的内容类型或 bundle

要注册新的内容类型，需要重新安装模块。请注意，这将丢失之前创建的相关内容。

### 核心参考

作为创建新内容类型的示例，建议查看核心的标准配置文件，其中定义了内容类型 `文章`（article）和 `基本页面`（page）。你可以在 `/core/profiles/standard/config/install` 中找到这些文件。例如，对于内容类型 `article`，请查看以下文件：
- `node.type.article.yml`
- `field.field.node.article.*.yml`
- `core.entity_form_display.node.article.default.yml`
- `core.entity_view_display.node.article.default.yml`

作为创建其他内容实体类型 bundle 的示例，也可以在标准配置文件中查看 `基本` 类型的定义，位于内容块（或自定义块）中。查看以下文件：
- `block_content.type.basic.yml`
- `field.field.block_content.basic.body.yml`
- `core.entity_form_display.block_content.basic.default.yml`
- `core.entity_view_display.block_content.basic.default.yml`

### 其他参考链接

编程将自定义字段添加到内容类型：
[https://www.drupal.org/docs/drupal-apis/entity-api/programming-custom-fields-into-your-content-type](https://www.drupal.org/docs/drupal-apis/entity-api/programming-custom-fields-into-your-content-type)

# 30.3 创建自定义字段类型

==字段类型是通过插件定义的==，需考虑以下元素：
- 字段类型的定义，创建一个扩展 `Drupal\Core\Field\FieldItemBase` 的 `@FieldType` 插件。
- 字段类型的配置架构。
- 一个或多个表单控件（widgets），用于指定在实体创建/编辑表单中该字段的控件。每个控件是一个 `@FieldWidget` 插件。
- 一个或多个格式化器（formatters），用于指定在展示实体时该字段的值的显示方式。每个格式化器是一个 `@FieldFormatter` 插件。
https://www.drupal.org/docs/drupal-apis/entity-api/fieldtypes-fieldwidgets-and-fieldformatters

==参考链接==：[https://www.drupal.org/docs/drupal-apis/entity-api/fieldtypes-fieldwidgets-and-fieldformatters](https://www.drupal.org/docs/drupal-apis/entity-api/fieldtypes-fieldwidgets-and-fieldformatters)

在我们的模块 `Forcontu Entities` 中，我们将定义字段类型 `Forcontu Color`（`forcontu_entities_color`），用于存储 RGB 十六进制格式的颜色。

#### @FieldType

字段类型通过 `@FieldType` 插件定义。它是一个扩展 `FieldItemBase` 的类，位于 `/src/Plugin/Field/FieldType` 目录中。如果一个模块实现了多个字段类型，每个类将位于独立的文件中，但都在同一个文件夹内。

参考链接：[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!FieldItemBase.php/class/FieldItemBase/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!FieldItemBase.php/class/FieldItemBase/10)

文件：`/forcontu_entities/src/Plugin/Field/FieldType/ColorItem.php`

```php
<?php
namespace Drupal\forcontu_entities\Plugin\Field\FieldType;

use Drupal\Core\Field\FieldItemBase;
use Drupal\Core\Field\FieldStorageDefinitionInterface;
use Drupal\Core\TypedData\DataDefinition;

/**
 * Plugin implementation of the 'forcontu_entities_color' field type.
 *
 * @FieldType(
 *   id = "forcontu_entities_color",
 *   label = @Translation("Forcontu Color"),
 *   module = "forcontu_entities",
 *   description = @Translation("Field to store an RGB color."),
 *   default_widget = "forcontu_entities_text",
 *   default_formatter = "forcontu_entities_simple_text"
 * )
 */
class ColorItem extends FieldItemBase {
  /**
   * {@inheritdoc}
   */
  public static function schema(FieldStorageDefinitionInterface $field_definition) {
    return [
      'columns' => [
        'value' => [
          'type' => 'text',
          'size' => 'tiny',
          'not null' => FALSE,
        ],
      ],
    ];
  }

  /**
   * {@inheritdoc}
   */
  public function isEmpty() {
    $value = $this->get('value')->getValue();
    return $value === NULL || $value === '';
  }

  /**
   * {@inheritdoc}
   */
  public static function propertyDefinitions(FieldStorageDefinitionInterface $field_definition) {
    $properties['value'] = DataDefinition::create('string')
      ->setLabel(t('Hex value'));
    return $properties;
  }
}
```

在插件注解（`@FieldType`）中定义了以下参数：
- `id`：字段类型的系统名称。通常添加模块名称作为前缀。
- `label`：字段的标签。在管理界面中显示的字段名称。
- `module`：实现字段类型的模块。
- `description`：描述性文本，仅在管理区域显示。
- `default_widget`：字段必须至少有一个控件。这里指定实现默认控件的插件的系统名称。
- `default_formatter`：字段必须至少有一个格式化器。这里指定实现默认格式化器的插件的系统名称。

#### FieldItemInterface::schema()

返回字段的架构，用于在数据库中创建表。唯一必须提供的值是表的列（columns）。可以选择添加唯一键、索引和外键。

参考链接：[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!FieldItemInterface.php/function/FieldItemInterface::schema/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!FieldItemInterface.php/function/FieldItemInterface::schema/10)

注意：计算字段可能不需要创建表，因为它们不需要存储字段值。在这种字段中，值在运行时计算或从其他来源获取，但不存储。在这些情况下，`schema()` 方法应返回一个空数组。

#### FieldItemInterface::propertyDefinitions()

此方法必须实现。返回字段属性的数组。

参考链接：[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!FieldItemInterface.php/function/FieldItemInterface::propertyDefinitions/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!FieldItemInterface.php/function/FieldItemInterface::propertyDefinitions/10)

#### TypedData::getConstraints()

Drupal 中的经典验证方法基于表单。然而，在 Drupal 8 中，实体和字段的验证已被独立的实体验证 API 替代，基于约束（constraints）。这样，实体的验证不依赖于通过表单创建或修改。我们将在第 30.5 节中进一步讨论此验证方法。

参考链接：[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!TypedData!TypedData.php/function/TypedData::getConstraints/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!TypedData!TypedData.php/function/TypedData::getConstraints/10)

#### 配置架构

在字段的配置架构中描述其属性。

文件：`/forcontu_entities/config/schema/forcontu_entities.schema.yml`

```yaml
field.forcontu_entities_color.value:
  type: sequence
  label: 'Default value'
  sequence:
    - type: mapping
      label: 'Default'
      mapping:
        value:
          type: string
          label: 'Value'
```

#### @FieldWidget

每个表单控件定义为一个 `@FieldWidget` 插件。它是一个扩展 `WidgetBase` 的类，位于 `/src/Plugin/Field/FieldWidget` 目录中。如果一个模块实现了多个控件，每个类将位于独立的文件中，但都在同一个文件夹内。

参考链接：[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!WidgetBase.php/class/WidgetBase/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!WidgetBase.php/class/WidgetBase/10)

文件：`/forcontu_entities/src/Plugin/Field/FieldWidget/TextWidget.php`

```php
<?php
namespace Drupal\forcontu_entities\Plugin\Field\FieldWidget;

use Drupal\Core\Field\FieldItemListInterface;
use Drupal\Core\Field\WidgetBase;
use Drupal\Core\Form\FormStateInterface;

/**
 * Plugin implementation of the 'forcontu_entities_text' widget.
 *
 * @FieldWidget(
 *   id = "forcontu_entities_text",
 *   module = "forcontu_entities",
 *   label = @Translation("RGB value as #ffffff"),
 *   field_types = {
 *     "forcontu_entities_color"
 *   }
 * )
 */
class TextWidget extends WidgetBase {
  /**
   * {@inheritdoc}
   */
  public function formElement(FieldItemListInterface $items, $delta, array $element, array &$form, FormStateInterface $form_state) {
    $value = isset($items[$delta]->value) ? $items[$delta]->value : '#ffffff';
    $element += [
      '#type' => 'textfield',
      '#default_value' => $value,
      '#size' => 7,
      '#maxlength' => 7,
    ];
    return ['value' => $element];
  }
}
```

在插件注解（`@FieldWidget`）中定义了以下参数：
- `id`：控件的系统名称。通常添加模块名称作为前缀。
- `label`：控件的标签，在管理界面的控件选择中显示。
- `module`：实现控件的模块。
- `field_types`：可以应用此控件的字段的系统名称（id）。

`formElement()` 方法返回用于填写字段的表单控件结构。在我们的示例中，默认控件是一个简单的文本字段，用于输入十六进制颜色值。字段的验证将在稍后添加。

一旦将字段添加到实体中，可以从“管理表单展示”中选择控件。

#### @FieldFormatter

每个字段格式化器定义为一个 `@FieldFormatter` 插件。它是一个扩展 `FormatterBase` 的类，位于 `/src/Plugin/Field/FieldFormatter` 目录中。如果一个模块实现了多个格式化器，每个类将位于独立的文件中，但都在同一个文件夹内。

参考链接：[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!FormatterBase.php/class/FormatterBase/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!FormatterBase.php/class/FormatterBase/10)

文件：`/forcontu_entities/src/Plugin/Field/FieldFormatter/SimpleTextFormatter.php`

```php
<?php
namespace Drupal\forcontu_entities\Plugin\Field\FieldFormatter;

use Drupal\Core\Field\FormatterBase;
use Drupal\Core\Field\FieldItemListInterface;

/**
 * Plugin implementation of the 'forcontu_entities_simple_text' formatter.
 *
 * @FieldFormatter(
 *   id = "forcontu_entities_simple_text",
 *   module = "forcontu_entities",
 *   label = @Translation("Simple text-based formatter"),
 *   field_types = {
 *     "forcontu_entities_color"
 *   }
 * )
 */
class SimpleTextFormatter extends FormatterBase {
  /**
   * {@inheritdoc}
   */
  public function viewElements(FieldItemListInterface $items, $langcode) {
    $elements = [];
    foreach ($items as $delta => $item) {
      $elements[$delta] = [
        // We create a render array to produce the desired markup,
        // "<p style="color: #hexcolor">The color code ...
        // #hexcolor</p>".
        // See theme_html_tag().
        '#type' => 'html_tag',
        '#tag' => 'p',
        '#attributes' => [
          'style' => 'color: ' . $item->value,
        ],
        '#value' => $this->t('The color code in this field is @code', ['@code' => $item->value]),
      ];
    }
    return $elements;
  }
}
```

==格式化器将在“管理展示”中为每个展示模式选择。==

在我们的示例中，格式化器是一个段落，显示一个指示颜色代码的文本。此外，段落添加了颜色作为样式，使文本显示为所选颜色。

```html
<p style="color: #09d209">The color code in this field is #09d209</p>
```

#### 额外配置

控件和格式化器可以有额外的配置，通过界面选择。一些与插件配置相关的方法包括：
- `settingsForm()`：用于请求配置值的表单。
- `defaultSettings()`：返回带有默认配置值的关联数组。
- `settingsSummary()`：显示当前配置值的信息摘要。
- `getSetting()`、`getSettings()`、`setSetting()`、`setSettings()`：用于获取和存储配置值的 get 和 set 方法。

作为示例，我们将为实现的 `SimpleTextFormatter` 添加配置。可以选择用来包裹文本的标签（`<p>`、`<div>` 或 `<span>`）。

```php
class SimpleTextFormatter extends FormatterBase {
  public function viewElements(FieldItemListInterface $items, $langcode) {
    $elements = [];
    foreach ($items as $delta => $item) {
      $elements[$delta] = [
        '#type' => 'html_tag',
        '#tag' => $this->getSetting('formatter_tag'),
        '#attributes' => [
          'style' => 'color: ' . $item->value,
        ],
        '#value' => $this->t('The color code in this field is @code', ['@code' => $item->value]),
      ];
    }
    return $elements;
  }

  public function settingsForm(array $form, FormStateInterface $form_state) {
    $output['formatter_tag'] = [
      '#title' => $this->t('HTML tag'),
      '#type' => 'select',
      '#options' => [
        'p' => $this->t('p'),
        'div' => $this->t('div'),
        'span' => $this->t('span'),
      ],
      '#default_value' => $this->getSetting('formatter_tag'),
    ];
    return $output;
  }

  public static function defaultSettings() {
    return [
      'formatter_tag' => 'p',
    ] + parent::defaultSettings();
  }

  public function settingsSummary() {
    $summary = [];
    $formatter_tag = $this->getSetting('formatter_tag');

    $summary[] = $this->t('HTML Tag: @tag', ['@tag' => $formatter_tag]);

    return $summary;
  }
}
```

不要忘记，除了与配置直接相关的方法外，还需要修改 `viewElements()` 方法以使用配置值（`getSetting()` 方法）。

在图 [F30.3d] 中显示了元素的配置摘要（`settingsSummary()`），以及访问配置表单的按钮 [F30.3e]。

现在生成的 HTML 将取决于格式化器的配置。