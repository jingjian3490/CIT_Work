
在软件开发过程中，项目通常会涉及到配置文件，这些文件可能会因开发者所处环境的不同而需要进行个性化修改。
为了协调团队成员之间的工作，我们需要一个有效的策略来管理这些配置文件，同时确保它们不会干扰到版本控制系统。

## 忽略未跟踪的文件

`.gitignore` 文件是 Git 用来排除不需要加入版本控制的文件和目录的。添加到 `.gitignore` 文件中的条目会被 Git 忽略，不会显示在 `git status` 中，也不会被包含在提交中。
##### 使用 `.gitignore`
1. 在项目根目录下创建 `.gitignore` 文件。
2. 在 `.gitignore` 文件中添加要忽略的文件或文件夹的路径。
例如：
```
# 忽略所有 .env 文件
*.env

# 忽略特定的配置文件
config.php
```
## 处理已跟踪的文件

如果一个文件已经被 Git 跟踪，那么 `.gitignore` 文件不会对它产生影响。在这种情况下，我们可以使用 `git update-index` 命令暂时忽略文件的更改。
##### 暂时忽略更改
要忽略已跟踪文件的更改，可以执行：
```bash
git update-index --assume-unchanged 文件路径
```

这会让 Git 假定该文件未更改，从而忽略任何本地的修改，不会在 `git status` 和 `git diff` 中显示。
##### 取消忽略更改
如果想要重新跟踪这个文件的更改，可以使用：
```bash
git update-index --no-assume-unchanged 文件路径
```
### 注意事项
- 使用 `--assume-unchanged` 标记时，需要注意在将来的合并操作中可能会出现冲突。
- 这个方法适用于临时的更改忽略，如果文件经常变动，最好寻找其他解决方案。
## 最佳实践：本地配置覆盖

对于配置文件，一个更稳定的解决方案是使用一个本地配置文件来覆盖默认的配置。

1. 将默认配置文件命名为 `config.default.php` 并提交到 Git。
2. 在 `.gitignore` 中添加 `config.php`，以便 Git 忽略它。
3. 开发者复制 `config.default.php` 为 `config.php` 并根据个人需要修改。

这种做法的优点在于，它允许每个开发者拥有自己的本地配置，同时不会影响到版本控制系统中的文件。这样可以保持团队成员之间的一致性，同时也避免了不必要的合并冲突。

通过上述方法，团队可以有效地管理配置文件，确保开发工作的顺利进行，同时也保持了版本控制的整洁和一致性。

==当前==
线上注册，线上参会
线下注册，线下参会

==目标==
线上注册，线上参会
线下注册，线上线下皆可参会，参会时间线下为准

==需要修改的地方==
1. 修改 Join 按钮展示，15 minute
2. 修改 attend data


```php
public function joinAccess(int $node) {
    $event = Node::load($node);
    // Basic access checking.
    if (!$this->registerService->eventActionAccessCheck($event)) {
      return AccessResult::forbidden();
    }
    // Check event start time.
    if ($event->get('field_start')->value - 15 * 60 > time()) {
      return AccessResult::forbidden('Join link will be available 15 minutes before the event starts. ');
    }

    // HCP can join virtual event.
    if (!empty($event->get('field_webinar_platform')->getValue()) &&
      $this->registerService->isRegistered($event)) {
      return AccessResult::allowed();
    }

    return AccessResult::forbidden();
  }

  /**
   * Join event.
   *
   * @param int $node
   *   Event id.
   *
   * @return \Drupal\Core\Routing\TrustedRedirectResponse|\Symfony\Component\HttpFoundation\RedirectResponse
   *   Redirect to attend link.
   */
  public function join(int $node) {
    $event = Node::load($node);

    $register_type = EVENT_TYPE_VIRTUAL;

    // Get registration by uid.
    $registration = $this->registerService->getRegistration($event->id(), $this->account->id());
    if ($registration) {
      $register_type = $registration->get('register_type')->value ?: $register_type;
    }

    // Save attendee data.
    $result = $this->attendeeService->saveAttendeeData($node, $this->account, $register_type, Attendee::ATTENDANCE_STATUS_CHECKED);
    if (!$result) {
      throw new NotFoundHttpException(
        'System error, Please try again later.'
      );
    }

    // Webinar integration.
    try {
      $join_link = $this->attendeeService->getJoinLink($registration,$event);
    }
    catch (\Exception $exception) {
      watchdog_exception('register_event', $exception);
      \Drupal::messenger()->addError($exception->getMessage());
      $url = \Drupal::service('path_alias.manager')->getAliasByPath('/node/' . $node);
      return new RedirectResponse($url);
    }

    $join_link = $join_link ?: $event->get('field_attend_link')->uri;
    return new TrustedRedirectResponse($join_link);
  }

  /**
   * Hold on page.
   *
   * @param int $node
   *   Event id.
   * @param \Symfony\Component\HttpFoundation\Request $request
   *   Request object.
   *
   * @return array
   *   Render output for hold on page.
   *
   * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
   */
  public function holdOnPage(int $node, Request $request) {
    $referer = $request->headers->get('referer');
    if ($referer) {
      $parse_url = parse_url($referer);
      $url_object = $this->pathValidator->getUrlIfValid($parse_url['path']);
      if ($url_object->getRouteName() == 'eventhub_attend.form_page') {
        $event = Node::load($node);
        if ($event instanceof NodeInterface) {
          $block_content = NULL;
          $cache_tags = [
            'node:' . $node,
          ];
          try {
            $blocks = \Drupal::entityTypeManager()->getStorage('block_content')
              ->loadByProperties([
                'field_key' => 'hold_on_attend'
              ]);
            $block_content = reset($blocks);
            $cache_tags[] = 'block_content:' . $block_content->id();
          }
          catch (InvalidPluginDefinitionException $exception) {
            watchdog_exception('hold_on_page', $exception);
          }

          return [
            '#theme' => 'hold_on_page',
            '#user_name' => $request->query->get('name'),
            '#event' => $event,
            '#hold_on_block' => $block_content ? $block_content->get('body')->value : '',
            '#cache' => [
              'tags' => $cache_tags,
              'contexts' => ['url.path', 'url.query_args:name', 'url']
            ]
          ];
        }
      }
    }

    throw new NotFoundHttpException();
  }

  /**
   * Determine the status of the join button.
   */
  public function joinButtonStatus(Request $request) {
    $user = \Drupal::currentUser();
    $node_ids = json_decode($request->request->get('node'));
    $events = Node::loadMultiple($node_ids);
    // Check the node_ids that meet the conditions.
    foreach ($events as $nid => $event) {
      $index = array_search($nid, $node_ids);
      if (!$event->isPublished()
        || $event->get('field_start')->value - 15 * 60 >= time()
        || empty($event->get('field_webinar_platform')->getValue())
      ) {
        unset($node_ids[$index]);
      }
    }
    if (empty($node_ids)) {
      return new JsonResponse([[]]);
    }
    // Query if registered or not.
    $entities = \Drupal::entityQuery('registration')
      ->condition('uid', $user->id())
      ->condition('nid', $node_ids, 'IN')
      ->accessCheck(FALSE)
      ->execute();
    // Registered nids.
    $registered_nids = array_keys($entities);
    // Load registered entities.
    $registrations = Registration::loadMultiple($registered_nids);
    // Event ids.
    $event_ids = [];
    foreach ($registrations as $registration) {
      $event_ids[] = $registration->get('nid')->target_id;
    }
    return new JsonResponse([
      $event_ids
    ]);
  }
```

![[Pasted image 20240228080231.png]]

![[Pasted image 20240228080242.png]]

![[Pasted image 20240228080258.png]]


```php
  /**
   * Get join link from vistream.
   *
   * @param \Drupal\eventhub_register\RegistrationInterface|null $registration
   *   Registration entity.
   * @param \Drupal\node\NodeInterface $event
   *   Event object.
   *
   * @return mixed|null
   *   Return join link if success.
   *
   * @throws \Exception
   * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
   * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
   * @throws \Drupal\Core\Entity\EntityStorageException
   */
  public function getJoinLink(?RegistrationInterface $registration, NodeInterface $event) {
    if ($registration instanceof RegistrationInterface) {
      $join_link = $registration->get('join_link')->value;
      if (!empty($join_link)) {
        return $join_link;
      }
    }

    $webinar_platform = $event->hasField('field_webinar_platform') ? $event->get('field_webinar_platform')->target_id : NULL;
    $vistream = $this->eventService->getWebinarPlatformId(EVENT_WEBINAR_PLATFORM_VISTREAM);
    if ($webinar_platform && $webinar_platform == $vistream) {
      $hcp = User::load(\Drupal::currentUser()->id());
      $webinar = new Webinar(
        $event,
        $hcp
      );
      $response = $this->vistreamService->loginEvent($webinar);
      if ($response['code'] == 200 && isset($response['data'])) {
        $success = $response['data']['is_success'] ?? FALSE;
        if ($success) {
          $join_link = $response['data']['join'][0]['url'] ?? NULL;
          if ($join_link && $registration instanceof RegistrationInterface) {
            $registration->set('join_link', $join_link);
            $registration->save();
          }
          return $join_link;
        }
      }

      throw new \Exception('Failed to get join link, please try again later.');
    }

    return NULL;
  }
```

![[Pasted image 20240228080419.png]]