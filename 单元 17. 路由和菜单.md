
正如我们在上一单元中提到的，从 Drupal 8 开始，路由和菜单的概念被分开了，不再使用 `hook_menu()`。
在本单元中，我们将学习如何创建路由和控制器来实现编程页面。
除了简单路由和带参数的路由，我们还将研究其他类以便从代码的任何部分生成路由。
我们还将学习如何创建菜单链接、选项卡和操作链接等，以及如何通过创建特定权限来保护路由的访问。
### 本单元内容
- 17.1 路由和控制器
- 17.2 带参数的路由
- 17.3 用于处理路由的类
- 17.4 菜单链接
- 17.5 选项卡（本地任务）
- 17.6 操作链接
- 17.7 路由访问控制
- 17.8 在控制器类中注入服务
- 17.9 动态路由
- 17.10 从控制台执行

## 17.1 路由和控制器

正如我们在上一单元中提到的，从 Drupal 8 开始，路由和菜单的概念被分开了，不再使用 `hook_menu()`。
==路由在配置文件（`模块.routing.yml`）中定义，页面内容通过控制器类中的方法返回。==
Drupal 10 的路由系统基于 Symfony 的路由系统。虽然我们这里的讲解足以理解 Drupal 的路由系统，但你可以通过查阅 Symfony 的路由组件来扩展这方面的知识：
[Symfony 路由文档](http://symfony.com/doc/current/book/routing.html)

你也可以查阅 Drupal 的官方文档来获取更多信息：
[Drupal 路由系统概述](https://www.drupal.org/docs/drupal-apis/routing-system/routing-system-overview)

### Forcontu Pages 模块
在本单元中，我们将创建一个名为 Forcontu Pages (`forcontu_pages`) 的新模块，在其中实现不同类型的路由、菜单项、选项卡等。请回顾第 17 单元以创建模块定义文件 `forcontu_pages.info.yml`。

### 路由
在 Drupal 10 中，我们区分页面的 URL 或物理路径（在浏览器中使用）和路由名称（在编程中引用的系统名称）。这种区分可以避免在需要更改页面物理 URL 时出现问题，因为内部的路由名称保持不变。

要定义页面的路由，我们需要创建一个路由文件，名为 `forcontu_pages.routing.yml`。该文件位于模块根目录，与 `.info.yml` 文件同级。在这个文件中，将定义我们模块中创建的所有页面路由。

```yaml
forcontu_pages.simple:
  path: '/forcontu/pages/simple'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::simple'
    _title: 'Simple Page'
  requirements:
    _permission: 'access content'
```

路由定义由以下属性组成：
- `forcontu_pages.simple`: 路由的系统名称（机器名称）。通常使用模块名称作为前缀（`forcontu_pages`）。
- `path`: 页面的物理路径。这是在浏览器中加载页面时使用的路径，例如：`http://www.example.com/path`。在我们的示例中，创建的页面将可通过 URL `http://www.example.com/forcontu/pages/simple` 访问。
- `defaults`: 路由的默认属性：
  - `_controller`: 指向控制器类和用于返回页面内容的方法。如果与 Drupal 7 比较，相当于我们在 `hook_menu` 中定义的回调函数（`page callback`）。
  - `_title`: 页面标题。
- `requirements`: 用户访问路由必须满足的条件：
  - `_permission`: 指定用户访问页面所需的权限。稍后我们将学习如何在模块中定义自定义权限。

路由可以有其他属性，我们将在需要时逐步介绍。你可以在以下链接查阅所有适用于路由的属性：
[Drupal 路由结构](https://www.drupal.org/docs/drupal-apis/routing-system/structure-of-routes)

在 `.routing.yml` 文件中定义的路由是==静态路由==，即从模块安装时就固定的路由。稍后我们将学习如何定义在运行时创建的==动态路由==。
### 控制器类

接下来，我们需要创建一个控制器类，用于返回页面内容。
为了创建我们模块的控制器，我们将扩展核心中可用的 `ControllerBase` 类。你可以在以下链接查看该类的方法：
[ControllerBase 类文档](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Controller!ControllerBase.php/class/ControllerBase/10)

我们将在以下文件中定义控制器：
`\forcontu_pages\src\Controller\ForcontuPagesController.php`
我们需要在模块文件夹中创建子文件夹结构（`\src\Controller\`）。

让我们回到路由文件（`forcontu_pages.routing.yml`）中分析控制器的定义：
```yaml
forcontu_pages.simple:
  path: '/forcontu/pages/simple'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::simple'
    _title: 'Simple Page'
  requirements:
    _permission: 'access content'
```

控制器名称的第一部分（`::` 之前）指的是控制器类的位置和名称（`class ForcontuPagesController`）。第二部分（`::` 之后，`simple`）指的是类中负责返回该特定页面内容的方法或函数。

==如果在一个模块中定义了多个页面，将有一个控制器负责所有页面，每个页面在控制器类中有自己对应的方法。在接下来的部分中，我们将定义新的路由并在控制器中创建额外的方法。==

`simple()` 方法返回一个包含页面内容的可渲染数组。我们将在后续单元中详细讨论可渲染数组。现在，我们只需了解 `#markup` 属性用于指定 HTML 输出。在我们的示例中，生成的页面 HTML 将是：`<p>This is a simple page (with no arguments)</p>`（或其相应的翻译）。

```php
<?php
namespace Drupal\forcontu_pages\Controller;

use Drupal\Core\Controller\ControllerBase;

/**
 * Contains \Drupal\forcontu_pages\Controller\ForcontuPagesController.
 */
class ForcontuPagesController extends ControllerBase {
  public function simple() {
    return [
      '#markup' => '<p>' . $this->t('This is a simple page (with no arguments)') . '</p>',
    ];
  }
}
```

你可以在 Drupal API 中阅读更多关于可渲染数组的信息：
[可渲染数组文档](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Render!theme.api.php/group/theme_render/10)

正如我们在第 17 单元中提到的，模块中打印的文本应通过 `t()` 函数处理，以便可以翻译。在控制器函数中，可以使用 `t()` 方法，因此我们将这样使用它：
```php
$this->t('text')
```

在定义控制器类的文件（`ForcontuPagesController.php`）中，我们首先声明命名空间（`namespace`），然后使用 `use` 操作符引用需要使用的类。在我们的例子中，我们的控制器扩展了 `ControllerBase` 类，因此需要包含它。

```php
<?php
/**
 * @file
 * Contains \Drupal\forcontu_pages\Controller\ForcontuPagesController.
 */
namespace Drupal\forcontu_pages\Controller;

use Drupal\Core\Controller\ControllerBase;
```

如果需要使用其他类，也需要使用 `use` 操作符引用它们。在第 17.3 节中，我们将看到一个示例，其中需要包含 `Url` 类以在页面内生成链接。
## 17.2 带参数的路由

要定义带参数的路由，只需为参数指定名称，并将其包含在路由中的大括号内。以下是一些示例：
- `/example/{user}`：定义了参数 `{user}`。一个有效的路由可能是 `/example/12`，其中 `12` 对应用户的内部 ID。
- `/example/{country}/{city}`：定义了参数 `{country}` 和 `{city}`。一个有效的路由可能是：`/example/spain/madrid`。
- `/example/{param1}/foo/{param2}/bar`：在这个示例中，参数也可以与 URL 的其他固定片段交错。

作为带参数路由的完整示例，我们将定义以下 URL：
`/forcontu/pages/calculator/{num1}/{num2}`

```yaml
forcontu_pages.calculator:
  path: '/forcontu/pages/calculator/{num1}/{num2}'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::calculator'
  requirements:
    _permission: 'access content'
```

在我们将添加到模块控制器中的 `calculator()` 方法中，我们将传递这两个参数：`calculator($num1, $num2)`。在这个页面上，我们将使用参数 `$num1` 和 `$num2` 进行一些数学运算。我们遵循的步骤如下（已在代码中注释）：

a) 检查提供的值是否为数字。如果任一参数不是数字，则==抛出带有错误消息的异常==。在这种情况下，我们使用 `BadRequestHttpException` 异常，这需要添加相应的组件：
```php
use Symfony\Component\HttpKernel\Exception\BadRequestHttpException;
```

b) 创建一个数组，其中我们将逐行添加要显示的内容。在每一行中显示一个运算结果。

c) 为避免除零错误，`$num2` 不能为 0。如果为 0，我们将不进行除法运算，并指示值未定义（undefined）。

d) 创建一个可渲染数组 `$output`，其中我们将要在页面上显示的元素添加进去。在我们的示例中，我们只添加了一个元素 `forcontu_pages_calculator`，它将使用==模板 `item_list` 将数组 `$list` 转换为 HTML 列表（`ul`）==。我们将在后续单元中详细讨论可渲染数组和模板。

e) 最后，返回可渲染数组 `$output`。

```php
<?php
/**
 * @file
 * Contains \Drupal\forcontu_pages\Controller\ForcontuPagesController.
 */
namespace Drupal\forcontu_pages\Controller;

use Drupal\Core\Controller\ControllerBase;
use Symfony\Component\HttpKernel\Exception\BadRequestHttpException;

/**
 * Controlador para devolver el contenido de las páginas definidas.
 */
class ForcontuPagesController extends ControllerBase {
  public function simple() {
    //...
  }

  public function calculator($num1, $num2) {
    // a) 检查提供的值是否为数字，如果不是，则抛出异常
    if (!is_numeric($num1) || !is_numeric($num2)) {
      throw new BadRequestHttpException(t('No numeric arguments specified.'));
    }

    // b) 结果将以 HTML 列表（ul）格式显示。每个列表项添加到一个数组中
    $list[] = $this->t('@num1 + @num2 = @sum', [
      '@num1' => $num1,
      '@num2' => $num2,
      '@sum' => $num1 + $num2
    ]);
    $list[] = $this->t('@num1 - @num2 = @difference', [
      '@num1' => $num1,
      '@num2' => $num2,
      '@difference' => $num1 - $num2
    ]);
    $list[] = $this->t('@num1 x @num2 = @product', [
      '@num1' => $num1,
      '@num2' => $num2,
      '@product' => $num1 * $num2
    ]);

    // c) 避免除零错误
    if ($num2 != 0) {
      $list[] = $this->t('@num1 / @num2 = @division', [
        '@num1' => $num1,
        '@num2' => $num2,
        '@division' => $num1 / $num2
      ]);
    } else {
      $list[] = $this->t('@num1 / @num2 = undefined (division by zero)', [
        '@num1' => $num1,
        '@num2' => $num2
      ]);
    }

    // d) 将数组 $list 转换为 HTML 列表（ul）
    $output['forcontu_pages_calculator'] = [
      '#theme' => 'item_list',
      '#items' => $list,
      '#title' => $this->t('Operations:')
    ];

    // e) 返回包含输出的可渲染数组
    return $output;
  }
}
```

根据通过 URL 传递的参数，页面输出如下：
- 路由：`/forcontu/pages/calculator/50/2`，在这种情况下，将进行所有运算。
- 路由：`/forcontu/pages/calculator/50/0`，由于 `$num2` 为 0，不进行除法运算以避免除零错误。
- 路由：`/forcontu/pages/calculator/50/foo`，由于 `$num2` 是非数字值，系统返回错误。此错误记录在事件日志中。

我们将在后续单元中详细讨论错误处理和异常。
### ==可选参数==

如果我们希望路由参数是可选的，我们需要为这些参数添加默认值。这些默认值在 `.routing.yml` 文件中的 `defaults` 部分中为==每个参数分配==。在下面的代码中，我们将 `$num1` 设置为 `20`，将 `$num2` 设置为 `10`。这些默认值仅在 URL 中未指定其他值时使用。

```yaml
forcontu_pages.calculator:
  path: '/forcontu/pages/calculator/{num1}/{num2}'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::calculator'
    num1: 20
    num2: 10
  requirements:
    _permission: 'access content'
```

根据通过 URL 传递的参数，页面输出如下：
- 路由：`/forcontu/pages/calculator/50`，只传递了第一个参数，因此 `$num2` 为 `10`（默认值）。
- 路由：`/forcontu/pages/calculator`，未传递任何参数，因此 `$num1` 为 `20`，`$num2` 为 `10`（默认值）。
### 实体作为参数

当我们希望将实体的 ID 作为参数传递时，Drupal 会简化操作，使实体在控制器方法中已加载并可用。

在下面的示例中，我们定义了一个带有 `{user}` 参数的新路由。

```yaml
forcontu_pages.user:
  path: '/forcontu/pages/user/{user}'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::user'
  requirements:
    _permission: 'access content'
```

==在控制器的方法中，我们指定参数 `$user` 是一个实现 `UserInterface` 的对象，该接口扩展了 `User` 类。==

如果传递的参数==不是有效的uid==，返回的响应是 ==404==。

```php
public function user(UserInterface $user) {
```

为了使用 `UserInterface`，我们需要通过 `use` 操作符将其包含进来：

```php
use Drupal\user\UserInterface;
```

完整的控制器代码如下：

```php
<?php
/**
 * @file
 * Contains \Drupal\forcontu_pages\Controller\ForcontuPagesController.
 */
namespace Drupal\forcontu_pages\Controller;

use Drupal\Core\Controller\ControllerBase;
use Symfony\Component\HttpKernel\Exception\BadRequestHttpException;
use Drupal\user\UserInterface;

/**
 * Controlador para devolver el contenido de las páginas definidas.
 */
class ForcontuPagesController extends ControllerBase {
  public function simple() {
    //...
  }

  public function calculator($num1, $num2) {
    //...
  }

  public function user(UserInterface $user) {
    // 可以直接使用 $user 对象
    $list[] = $this->t("Username: @username", ['@username' => $user->getAccountName()]);
    $list[] = $this->t("Email: @email", ['@email' => $user->getEmail()]);
    $list[] = $this->t("Roles: @roles", ['@roles' => implode(', ', $user->getRoles())]);
    $list[] = $this->t("Last accessed time: @lastaccess", [
      '@lastaccess' => \Drupal::service('date.formatter')->format($user->getLastAccessedTime(), 'short')
    ]);
    
    $output['forcontu_pages_user'] = [
      '#theme' => 'item_list',
      '#items' => $list,
      '#title' => $this->t('User data:'),
    ];
    
    return $output;
  }
}
```

在控制器方法中，我们将 `$user` 作为对象使用，尽管在路由中我们指定的是用户的 `uid`。可以查看以下链接，了解可以与 `$user` 对象一起使用的方法：
[UserInterface 方法](https://api.drupal.org/api/drupal/core!modules!user!src!UserInterface.php/10)

继续我们的示例，我们完成了控制器方法，显示通过 URL 传递的用户信息。具体地，我们展示以下用户字段：

- 用户名：`$user->getAccountName()`
- 电子邮件：`$user->getEmail()`
- 角色：`$user->getRoles()`。由于该方法返回==一个数组，我们使用 `implode()` 将其转换为以逗号（`,`）分隔的字符串。==
- 最后访问时间：`$user->getLastAccessedTime()`。==该方法返回时间戳。为了格式化时间，我们调用 `\Drupal::service('date.formatter')->format()`。==

```php
class ForcontuPagesController extends ControllerBase {
  public function simple() {
    //...
  }

  public function calculator($num1, $num2) {
    //...
  }

  public function user(UserInterface $user) {
    $list[] = $this->t("Username: @username", ['@username' => $user->getAccountName()]);
    $list[] = $this->t("Email: @email", ['@email' => $user->getEmail()]);
    $list[] = $this->t("Roles: @roles", ['@roles' => implode(', ', $user->getRoles())]);
    $list[] = $this->t("Last accessed time: @lastaccess", [
      '@lastaccess' => \Drupal::service('date.formatter')->format($user->getLastAccessedTime(), 'short')
    ]);

    $output['forcontu_pages_user'] = [
      '#theme' => 'item_list',
      '#items' => $list,
      '#title' => $this->t('User data:'),
    ];

    return $output;
  }
}
```

与我们传递用户实体参数的方式类似，我们也可以传递其他类型的实体。例如，我们可以传递一个节点，方法是实现 `NodeInterface` 接口。
[NodeInterface 方法](https://api.drupal.org/api/drupal/core!modules!node!src!NodeInterface.php/interface/NodeInterface/10)
#### PS：设置默认时区
###### 通过Drupal管理界面设置时区
1. **登录到Drupal管理界面**。
2. **导航到区域和语言设置**：
    - 点击顶部的 `配置`。
    - 在 `区域和语言` 部分下，点击 `日期和时间格式`。
3. **设置默认时区**：
    - 点击 `配置区域和语言` 页面中的 `地区设置`。
    - 在 `默认时区` 下拉菜单中，选择你想要的时区。
如果当前用户设置了自己的时区，显示给他的时间将是其对应时区的时间，否则将是 UTC（默认）时区的时间。
## 17.3 路由相关类

### Url 和 Link

`Url` 和 `Link` 类可以协同工作，在内容中生成链接。==`Url` 类定义了一个包含 URL 信息（如路由名称、内部或外部路径、相对或绝对路径等）的对象，而 `Link` 类则负责生成基于该 URL 的 HTML 链接（`<a href>`），并附加指定的属性。==

==Link 是通过 URL 创建的。==
```PHP
$url1 = Url::fromRoute('block.admin_display');
$link1 = Link::fromTextAndUrl($this->t('Go to the Block administration page'), $url1);
```

你可以在以下链接查看 `Url` 类的文档：
[Url 类文档](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Url.php/class/Url/10)

你可以在以下链接查看 `Link` 类的文档：
[Link 类文档](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Link.php/class/Link/10)

为了展示如何在内容中生成链接，我们将在 Forcontu Pages 模块中创建一个新页面，并定义一个包含不同类型链接的列表。

```yaml
forcontu_pages.links:
  path: '/forcontu/pages/links'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::links'
  requirements:
    _permission: 'access content'
```

#### 示例 1：指向内部 URL 的链接（`/admin/structure/blocks`）

第一个链接将指向一个内部路由，即块管理页面（`/admin/structure/blocks`）。为了指向该页面，我们不仅需要知道其物理 URL，还需要知道其在路由文件（`.routing.yml`）中定义的路由名称。由于这是一个与块相关的链接，我们将在核心模块 Block 的路由文件中查找该路由：

`/core/modules/block/block.routing.yml`

在该文件中，我们查找具有已知 URL 的路由（`path: '/admin/structure/block'`）：

```yaml
block.admin_display:
  path: '/admin/structure/block'
  defaults:
    _controller: '\Drupal\block\Controller\BlockListController::listing'
    _title: 'Block layout'
  requirements:
    _permission: 'administer blocks'
```

因此，我们需要引用的路由名称是：`block.admin_display`。

```php
//...
use Drupal\Core\Url;
use Drupal\Core\Link;

class ForcontuPagesController extends ControllerBase {
  public function simple() {
    //...
  }

  public function calculator($num1, $num2) {
    //...
  }

  public function user(UserInterface $user) {
    //...
  }

  public function links() {
    // 链接到 /admin/structure/blocks
    $url1 = Url::fromRoute('block.admin_display');
    $link1 = Link::fromTextAndUrl($this->t('Go to the Block administration page'), $url1);
    $list[] = $link1;

    $output['forcontu_pages_links'] = [
      '#theme' => 'item_list',
      '#items' => $list,
      '#title' => $this->t('Examples of links:'),
    ];

    return $output;
  }
}
```

首先，我们根据内部路由名称生成一个 `Url` 对象。然后，从 `Url` 对象生成一个包含链接的 `Link` 对象。`Link::fromTextAndUrl()` 方法允许我们指定链接文本，并从之前的 `Url` 对象生成 URL。

不要忘记在文件开头使用相应的 `use` 语句包含 `Url` 和 `Link` 类：

```php
//...
use Drupal\Core\Url;
use Drupal\Core\Link;
```

结果将是一个显示块管理页面链接的页面。如果我们查看生成的 HTML 源代码，可以看到如下生成的 HTML 代码：

```html
<a href="/admin/structure/block">Go to the Block administration page</a>
```

稍后我们将学习如何为链接添加额外的属性。
#### 示例 2：包含在文本中的链接

在上一个示例中，我们直接将 `$link1` 对象添加到 `list` 数组中，该数组随后被渲染为一个列表。当我们需要将链接包含在文本中时，需要使用 `toString()` 方法将其转换为字符串。在下面的示例中，我们将链接插入到一段文本中，并通过 `t()` 函数使其可翻译。

```php
$list[] = $this->t('This text contains a link to %link. Just convert it to String to use it into a text.', [
  '%link' => $link1->toString(),
]);
```

由于我们仍在使用示例 1 中生成的 `$link1` 链接，因此文本和 URL 将与示例 1 相同，但它们被包含在一段文本中。

结果将是一个显示块管理页面链接的页面。生成的 HTML 代码如下：

```html
This text contains a link to <a href="/admin/structure/block">Go to the Block administration page</a>. Just convert it to String to use it into a text.
```

#### 示例 3：链接到站点首页（`<front>`）

要生成指向站点首页的链接，只需使用 `<front>` 作为路由名称。

```php
// 链接到 <front>
$url3 = Url::fromRoute('<front>');
$link3 = Link::fromTextAndUrl($this->t('Go to Front page'), $url3);
$list[] = $link3;
```

生成的链接 `$link3` 可以直接在元素列表中使用，如示例 1，或包含在文本中，如示例 2。

完整的控制器代码如下：

```php
<?php
/**
 * @file
 * Contains \Drupal\forcontu_pages\Controller\ForcontuPagesController.
 */
namespace Drupal\forcontu_pages\Controller;

use Drupal\Core\Controller\ControllerBase;
use Symfony\Component\HttpKernel\Exception\BadRequestHttpException;
use Drupal\user\UserInterface;
use Drupal\Core\Url;
use Drupal\Core\Link;

/**
 * Controlador para devolver el contenido de las páginas definidas.
 */
class ForcontuPagesController extends ControllerBase {
  public function simple() {
    //...
  }

  public function calculator($num1, $num2) {
    //...
  }

  public function user(UserInterface $user) {
    //...
  }

  public function links() {
    // 链接到 /admin/structure/blocks
    $url1 = Url::fromRoute('block.admin_display');
    $link1 = Link::fromTextAndUrl($this->t('Go to the Block administration page'), $url1);
    $list[] = $link1;

    // 包含在文本中的链接
    $list[] = $this->t('This text contains a link to %link. Just convert it to String to use it into a text.', [
      '%link' => $link1->toString(),
    ]);

    // 链接到 <front>
    $url3 = Url::fromRoute('<front>');
    $link3 = Link::fromTextAndUrl($this->t('Go to Front page'), $url3);
    $list[] = $link3;

    $output['forcontu_pages_links'] = [
      '#theme' => 'item_list',
      '#items' => $list,
      '#title' => $this->t('Examples of links:'),
    ];

    return $output;
  }
}
```

在文件开头，不要忘记包含 `Url` 和 `Link` 类：

```php
use Drupal\Core\Url;
use Drupal\Core\Link;
```

这样，我们就可以在页面中显示不同类型的链接，包括指向块管理页面的链接、包含在文本中的链接以及指向站点首页的链接。
#### 示例 4：==链接到节点==（`/node/1`）

要链接到节点或任何其他实体，==Drupal 定义了一些特殊的路由，这些路由适用于所有实体==。例如，对于节点，可以使用以下路由：
- `'entity.node.canonical'`：对应节点的主页面，`/node/{node}`
- `'entity.node.edit_form'`：对应节点的编辑表单页面，`/node/{node}/edit`
- `'entity.node.delete_form'`：对应节点的删除页面，`/node/{node}/delete`

这些路由也适用于其他实体。例如，要访问用户页面，可以使用路由 `'entity.user.canonical'`。

因此，要链接到系统 URL 为 `/node/1` 的节点，我们使用路由 `'entity.node.canonical'`，并通过参数指定 `node` 的值。

```php
// 链接到 /node/1
$url4 = Url::fromRoute('entity.node.canonical', ['node' => 1]);
$link4 = Link::fromTextAndUrl($this->t('Link to node/1'), $url4);
$list[] = $link4;
```

==虽然==我们==使用节点的内部路由==来引用其路径，但系统将生成包含节点 ==URL 别名（如果有）==的链接：

```html
<a href="/about-us">Link to node/1</a>
```

#### 示例 5：链接到节点的编辑表单（`/node/1/edit`）

如示例 4 所述，要生成与实体相关的链接，我们需要使用一些特殊的路由。对于节点的编辑表单页面，我们使用路由 `'entity.node.edit_form'`，并通过参数指定 `node` 的值（要编辑的节点 ID）。

```php
// 链接到 /node/1/edit
$url5 = Url::fromRoute('entity.node.edit_form', ['node' => 1]);
$link5 = Link::fromTextAndUrl($this->t('Link to edit node/1'), $url5);
$list[] = $link5;
```

#### 示例 6：链接到外部 URL（`https://www.forcontu.com`）

==要生成指向站点外部 URL 的链接，我们使用 `Url` 类的 `fromUri()` 方法。==

```php
// 链接到 https://www.forcontu.com
$url6 = Url::fromUri('https://www.forcontu.com');
$link6 = Link::fromTextAndUrl($this->t('Link to www.forcontu.com'), $url6);
$list[] = $link6;
```

稍后我们将学习如何为链接添加属性，例如在新窗口中打开链接。

#### 示例 7：链接到未注册的内部 URL

上述方法也适用于引用未注册的内部路径（==即在路由文件中未定义的内部路径==）。例如，如果我们想链接到核心主题 Bartik 的 CSS 文件，可以这样做：

```php
// 链接到内部 CSS 文件
$url7 = Url::fromUri('internal:/core/themes/bartik/css/layout.css');
$link7 = Link::fromTextAndUrl($this->t('Link to layout.css'), $url7);
$list[] = $link7;
```

==我们使用了 `internal:` 前缀来指明这是一个内部路径==，后面是文件的相对路径。
#### 示例 8：==为链接添加属性==

HTML 链接可以具有额外的属性（如 `name`、`rel`、`target`、`class` 等）。在 Drupal 8 中，我们可以在 `Url` 对象上添加这些属性，`Link` 对象会使用它们来生成带有这些属性的链接。

```php
// 链接到 https://www.drupal.org 并添加额外的属性
$url8 = Url::fromUri('https://www.drupal.org');
$link_options = [
  'attributes' => [
    'class' => [
      'external-link',
      'list'
    ],
    'target' => '_blank',
    'title' => 'Go to drupal.org',
  ],
];
$url8->setOptions($link_options);
$link8 = Link::fromTextAndUrl($this->t('Link to drupal.org'), $url8);
$list[] = $link8;
```

在这个示例中，我们定义了一个包含属性的数组，然后==使用 `setOptions` 方法将这些属性添加到 `Url` 对象中==。具体地，我们添加了两个类名到 `class` 属性，使链接在新窗口中打开（`target="_blank"`），并添加了 `title` 属性。生成的 HTML 如下：

```html
<a href="https://www.drupal.org" class="external-link list" target="_blank" title="Go to drupal.org">Link to drupal.org</a>
```

### ==Route、RouteMatch 和 CurrentRouteMatch==

`Route` 对象包含在路由 YML 文件中为特定路由指定的信息。它通常不单独使用，而是作为 `RouteMatch` 对象中的一个组成部分。

`RouteMatch` 对象包含路由名称、`Route` 对象（类型为 `Route`）以及用于生成特定路由的==参数==。

`CurrentRouteMatch` 是一个 `RouteMatch` 对象，但它包含当前路由的信息。

#### `RouteMatch` 的使用示例

我们可以在 `hook_help()` 的实现中看到 `RouteMatch` 的使用示例：
[hook_help()](https://api.drupal.org/api/drupal/core!modules!help!help.api.php/function/hook_help/10)

```php
hook_help($route_name, \Drupal\Core\Routing\RouteMatchInterface $route_match)
```

`hook_help()` 函数接收两个参数：路由名称 `$route_name` 和包含更多路由信息的 `RouteMatch` 对象（`RouteMatchInterface`），即 `$route_match`。==该对象包含 `Route` 对象和路由参数==。

通常，在 `hook_help()` 的实现中，检查路由名称（`$route_name`）即可在该页面上编写帮助信息。如果我们想根据路由的其他参数编写帮助信息，需要在 `$route_match` 对象中查询这些参数。下面是一个示例。

在我们的 Forcontu Pages 模块中，我们将实现 `hook_help`。我们将在 `forcontu_pages.module` 文件中实现它。

我们将在节点编辑页面上显示两个文本（Text A 和 Text B）。节点编辑页面的路由名称为 `entity.node.edit_form`。

- Text A 将显示在所有节点编辑页面上。
- Text B 仅在编辑类型为 "page"（基本页面）的节点时显示。

```php
<?php
/**
 * @file
 * Forcontu Pages module file.
 */
use Drupal\Core\Routing\RouteMatchInterface;

/**
 * Implements hook_help().
 */
function forcontu_pages_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'entity.node.edit_form':
      $node = $route_match->getParameter('node');
      $output = '';
      $output .= '<p>' . t('Text A. This text is shown in every node edit form. Current node is of type %type and its id is %id', [
        '%type' => $node->getType(),
        '%id' => $node->id()
      ]) . '</p>';
      if ($node->getType() == 'page') {
        $output .= '<p>' . t('Text B. This text is shown only in Basic pages nodes.') . '</p>';
      }
      return $output;
  }
}
```

首先，我们检查 `$route_name` 的值是否与我们的路由名称（`entity.node.edit_form`）匹配。

```php
switch ($route_name) {
  case 'entity.node.edit_form':
```

在两个文本中，我们都需要获取正在编辑的节点的附加值，因此下一步是加载节点。节点将作为 `$route_match` 对象的参数可用。我们需要使用 `getParameter()` 方法来获取指定的参数。

```php
$node = $route_match->getParameter('node');
```

现在我们有了一个 `$node` ==对象==，可以使用其相应的方法和属性：
[Node 类](https://api.drupal.org/api/drupal/core!modules!node!src!Entity!Node.php/class/Node/10)

例如，要获取节点类型，我们调用 `$node->getType()`；要获取节点 ID，我们调用 `$node->id()`。

在 Text A 中，我们将这些值用作文本中的变量（在 `t()` 函数中作为替换变量）。

```php
$output .= '<p>' . t('Text A. This text is shown in every node edit form. Current node is of type %type and its id is %id', [
  '%type' => $node->getType(),
  '%id' => $node->id()
]) . '</p>';
```

要显示 Text B，我们首先检查内容类型是否为 "page"，并且仅在满足条件时显示。

```php
if ($node->getType() == 'page') {
  $output .= '<p>' . t('Text B. This text is shown only in Basic pages nodes.') . '</p>';
}
```

当编辑类型为 "文章" 的内容时，仅显示 Text A。当编辑类型为 "基本页面" 的内容时，同时显示 Text A 和 Text B。
## 17.4 菜单链接

如前所述，页面路由的定义与菜单链接的定义已经分离。在本节及后续章节中，我们将学习如何添加菜单链接及其他相关元素，如标签和操作链接。

有关 Drupal 菜单系统的更多信息，请参见以下链接：
[Drupal 10 的菜单 API](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Menu!menu.api.php/group/menu/10)

### 菜单链接

菜单链接==作为配置==定义在专门创建的 YML 文件中。定义菜单元素的==文件结构为== `模块名.links.menu.yml`。

在 Forcontu Hello 模块中，我们已经添加了一个菜单链接，创建了 `forcontu_hello.links.menu.yml` 文件，内容如下：

```yaml
forcontu_hello.hello:
  title: Hello Page
  description: 'Hello Page menu link'
  route_name: forcontu_hello.hello
  menu_name: main
  weight: 1
```

菜单元素的定义包含以下部分：

- `forcontu_hello.hello`：这是菜单元素的系统名称（machine name）。虽然与 `forcontu_hello.routing.yml` 中定义的路由系统名称相同，但不一定必须相同。
- `title`：菜单元素的标题。它是显示在菜单中的文本。
- `description`：菜单元素的描述。它是在鼠标悬停在链接上时显示的文本，对应 HTML 链接的 `title` 属性（`<a href="/forcontu/hello" title="Hello Page menu link">`）。
- `route_name`：路由的系统名称，如在 `routing.yml` 文件中定义的那样。
- `menu_name`：显示菜单元素的菜单名称。在我们的模块中，`main` 是主菜单的系统名称。如果省略菜单名称，则默认使用工具菜单（Tools）。
- `weight`：菜单元素的权重。用于与其他菜单元素的排序。

在接下来的示例中，我们将看到菜单元素定义中可以使用的其他属性。

### 示例：添加菜单链接

假设我们要在 Forcontu Pages 模块中添加一个菜单链接。首先，我们需要定义一个路由（如果还没有定义）。在 `forcontu_pages.routing.yml` 文件中添加以下内容：

```yaml
forcontu_pages.example:
  path: '/forcontu/example'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::example'
    _title: 'Example Page'
  requirements:
    _permission: 'access content'
```

然后，在 `forcontu_pages.links.menu.yml` 文件中添加菜单链接的定义：

```yaml
forcontu_pages.example:
  title: 'Example Page'
  description: 'Example Page menu link'
  route_name: forcontu_pages.example
  menu_name: main
  weight: 0
```

完整的控制器代码如下：

```php
<?php
/**
 * @file
 * Contains \Drupal\forcontu_pages\Controller\ForcontuPagesController.
 */
namespace Drupal\forcontu_pages\Controller;

use Drupal\Core\Controller\ControllerBase;

/**
 * Controlador para devolver el contenido de las páginas definidas.
 */
class ForcontuPagesController extends ControllerBase {
  public function example() {
    return [
      '#markup' => $this->t('This is an example page.'),
    ];
  }
}
```

在文件开头，不要忘记包含必要的命名空间：

```php
use Drupal\Core\Controller\ControllerBase;
```

这样，我们就在 Forcontu Pages 模块中添加了一个新的菜单链接，它指向一个示例页面。通过这种方式，我们可以轻松地将菜单链接添加到 Drupal 站点的主菜单或其他菜单中。