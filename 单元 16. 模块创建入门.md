### 单元内容

- 16.1 模块定义
- 16.2 创建页面
- 16.3 模块激活
- 16.4 实现 hook
- 16.5 模块安装和卸载
- 16.6 Messenger 服务
- 16.7 注册日志事件
- 16.8 使用控制台完成
# 16.1 模块定义

在本单元中，我们将通过创建一个基本模块来学习模块创建，该模块将帮助我们分析必要的最小结构，包括文件和内容。

我们将学习以下内容：

- 新模块的位置。
- 文件的基础语言和编码。
- 模块的主要文件：`.info.yml` 和 `.module`。
- 用于文本字符串翻译的 `t()` 函数。
- 通过定义路径和菜单链接创建页面。
- 模块激活。

我们将创建一个名为 Forcontu Hello 的模块，以便将这些点放在上下文中。该模块将生成一个包含静态内容的页面："Hello, Forcontu!"。

### 模块的位置

在 Drupal 中，每个模块都有自己的目录，通常与模块名称相同，以简化组织。

正如我们所知，在 Drupal 10 中，模块可以位于：

- `/modules`。在 Drupal 7 中，此文件夹保留给核心模块，但从 Drupal 8 开始，这些模块被移动到了 `/core/modules`。在 Drupal 10 中，`/modules` 文件夹用于安装贡献模块（`/modules/contrib`）和/或我们自己开发的模块（`/modules/custom`）。因此，这是我们模块的推荐位置。
- `/sites/all/modules`。我们仍然可以使用在以前的 Drupal 版本中使用的经典文件夹。
- `/sites/<站点域名>/modules`。==一个 Drupal 安装可以为多个网站提供服务（多站点结构）==。当模块只需在特定网站上可用时，我们将使用此文件夹。

我们将使用 `/modules/custom` 文件夹来放置新开发的模块。

### 模块名称

确定模块的位置后，第一步是创建相应的目录。

目录名称不应包含空格或特殊字符。当模块名称包含多个单词时，我们可以使用连字符作为分隔符或将所有单词连接在一起。

例如，模块 Views Slideshow 的目录名称为 `views_slideshow`，而模块 Global Redirect 的目录名称为 `globalredirect`（没有分隔符）。

在某些情况下，如果模块名称太长，或通过其缩写或某个缩略词而被广为人知，我们可以使用这些缩写或缩略词为其分配一个更合适的目录名称。例如，Chaos Tool Suite 模块使用目录 `ctools`。

如果我们正在为某个特定项目开发模块，可以使用项目名称作为前缀（例如，`proyecto_users`、`proyecto_nodes` 等）。这样可以更容易地识别和区分模块与其他已安装的模块，无论是贡献的还是自开发的。

在本课程中，所有开发的模块将使用 `forcontu` 作为前缀（例如，`forcontu_hello`、`forcontu_nodes`、`forcontu_blocks` 等）。

为了继续创建 Forcontu Hello 模块，我们将创建一个名为 `forcontu_hello` 的目录。因此，我们在网站的文件系统中将有以下路径：

```sh
/modules/custom/forcontu_hello
```
### 基础语言和文件编码

创建模块目录后，下一步是创建定义模块的文件。在开始处理文件之前，务必注意以下几点。

尽管 Drupal 可以安装在不同的语言环境中，但基础语言始终是英语。这意味着 Drupal 核心模块和贡献模块都应使用英语编写。这有助于不同国籍的社区成员之间的沟通和协作，并且无疑促进了 Drupal 的快速发展。

因此，我们建议从一开始就使用英语，特别是当你打算将模块贡献给社区时。如果这对你来说有困难，也不必担心，因为用西班牙语编写的模块也能正常工作。只需要注意，你模块中包含的“可翻译”文本字符串将始终被视为系统基础的一部分，因此系统会认为它们是英文（即使你用西班牙语编写）。

在本课程中，我们将出于教学目的使用西班牙语的文本和注释。

此外，还需要注意文件的编码类型。尽管是纯文本文件，但存在不同的编码方式（ANSI、UTF-8、ISO 8859-x 等）。Drupal 使用 UTF-8 编码，因此在创建文件时，第一步是将其转换为 UTF-8 无 BOM 格式，这样可以避免特殊字符（如重音符号和 ñ）的问题。

更改文件编码的方式取决于你使用的 IDE 编辑器。例如，如果你使用 Sublime Text，可以选择以 UTF-8 编码保存文件（File -> Save with Encoding -> UTF-8）。

始终确保文件的编码是正确的。
### .info.yml 文件

在开始为模块生成代码之前，需要创建一个扩展名为 `.info.yml` 的文件。这是一个用 YAML 格式编写的文本文件，包含关于模块的基本信息（名称、描述、Drupal 版本等）、最低要求（例如，特定的 PHP 版本）、可能的依赖关系、模块所属的包以及模块包含的文件。

文件名按照惯例应与模块目录名相似。因此，我们将遵循 `<模块名>.info.yml` 的模式，其中 `<模块名>` 对应为模块创建的目录。对于我们正在开发的第一个模块，合适的名称是 `forcontu_hello.info.yml`。

请记住将文件编码为 UTF-8 无 BOM，并尽可能使用英文文本（我们将在后续单元中学习如何将翻译添加到模块中）。如前所述，为了便于学习，我们将使用西班牙语的注释和文本。

下面是 Forcontu Hello 模块的信息文件内容：

```yaml
name: Forcontu Hello
type: module
description: 'Displays a basic page.'
package: Forcontu
core_version_requirement: ^10
```

#### .info.yml 文件示例

以下是模块定义文件（.info.yml）的示例。

`.info.yml` 文件可以包含以下字段，其中一些是==必填字段==：

- **name**（名称，必填字段）：包含模块的名称，如同在站点管理员界面中显示的那样。
- **type**（类型，必填字段）：定义的元素类型（module、theme 或 profile）。
- **description**（描述，必填字段）：模块的简短描述，也会在管理员界面的模块列表中显示。
- **core**（Drupal 版本，必填字段，直到 Drupal 8）：指示模块适用的 Drupal 版本（6.x、7.x、8.x）。不应写特定版本（例如，8.1 不是正确的值）。
- **core_version_requirement**（Drupal 版本，从 Drupal 8.7.7 开始必填）：在 Drupal 10 中，此字段是必填的。我们可能会遇到以下情况：
  - 在第一个例子中，我们也保持 `core` 字段，指定 Drupal 兼容任何版本的 Drupal 8（8.7.7 之前），以及后续版本的 Drupal 8 和 Drupal 10。
  
    ```yaml
    core: 8.x
    core_version_requirement: ^8 || ^9 || ^10
    ```
  
  - 在这种情况下，模块仅兼容版本 >8.7.7 和任何版本的 Drupal 9 或 10。如果安装在早期版本中，会报错，因为这些版本需要 `core` 指令。
  
    ```yaml
    core_version_requirement: ^8 || ^9 || ^10
    ```
  
  - 如果我们已经在 Drupal 10 中工作，可以只指明相应的版本：
  
    ```yaml
    core_version_requirement: ^10
    ```
  
  - 我们还可以指明特定版本的 Drupal 8、9 或 10。以下是一些有效的示例：
  
    从 Drupal 8.8、Drupal 9.5 和任何版本的 Drupal 10 开始有效：
  
    ```yaml
    core_version_requirement: ^8.8 || ^9.5 || ^10
    ```
  
    从 Drupal 10.1 开始有效：
  
    ```yaml
    core_version_requirement: ^10.1
    ```
  
- **dependencies**（依赖关系，可选字段）：我们的模块可能需要其他模块才能正常工作。`dependencies` 字段是一个包含这些所需模块名称的数组。数组中每个模块的名称应与其系统名称（.info.yml 文件名）一致，并且都是小写字母。在以下示例中，我们指定模块需要核心模块 `node` 和 `serialization` 激活。如果其中一个依赖项未安装但可用，将在安装模块时自动安装。

    ```yaml
    dependencies:
      - node
      - serialization
    ```

    请注意，这些依赖关系与 Composer 无关。如果依赖项未预先下载，模块将无法安装。为了使模块可用，我们首先通过 Composer 添加它（`composer require`）。不需要预先激活它，因为在安装我们正在开发的模块时会自动激活。

    注意：如果你想知道如何使用 Composer 为自定义模块添加依赖关系，请参阅以下链接：
    [Managing dependencies for a custom project](https://www.drupal.org/docs/develop/using-composer/managing-dependencies-for-a-custom-project)

- **package**（包，可选字段）：当模块属于一组模块时，可以在信息文件中包含它所属的包。这样，模块将在管理员界面的模块列表中与其他相关模块一起分组。例如，我们在本课程中开发的模块将属于 Forcontu 组：

    ```yaml
    package: Forcontu
    ```

- **configure**（配置，可选字段）：指定模块配置页面的路径。启用此选项后，将在模块管理列表中显示一个指向配置的链接。在 Drupal 7 中，我们指明页面的物理路径或 URL 别名，从 Drupal 8 开始，我们指明的是路由名称。这是一个系统名称，用于标识路径，无论加载页面时使用的路径或 URL 别名是什么。在以下示例中，我们指明模块配置页面的路由名称是 `forcontu_hello.admin`，但路径可能是 `admin/config/forcontu/hello`：

    ```yaml
    configure: forcontu_hello.admin
    ```

- **version**（模块版本，可选字段）：指定模块的版本。当模块将被贡献并存储在 drupal.org 上时，不需要指明版本，因为打包脚本会自动分配版本。在核心模块中，我们会看到版本指定为 `VERSION`。这种格式仅用于核心模块。在我们的模块中，如果不打算贡献，可以手动指定版本；如果打算贡献到 drupal.org，可以不包含版本行。

    ```yaml
    version: 1.0
    ```

- **hidden**（隐藏模块，可选字段）：将此值指定为 TRUE 时，模块不会显示在模块列表（扩展，/admin/modules）中。通常不隐藏模块，但这对于不希望在列表中显示的测试模块或开发者示例模块可能有用。

    ```yaml
    hidden: TRUE
    ```

如果你想了解更多关于 .info.yml 文件的结构和内容，请参阅以下链接：
[Let Drupal know about your module with an .info.yml file](https://www.drupal.org/docs/develop/creating-modules/let-drupal-know-about-your-module-with-an-infoyml-file)
### .module 文件

从 Drupal 8 开始，`.module` 文件不是必需的。此外，正如我们将在后续单元中看到的，`.module` 文件中的代码相较于以前的 Drupal 版本显著减少，因为现在许多元素（如块、路由等）在特定且独立的文件中创建。

`.module` 文件包括实现 hooks 的函数。

命名 `.module` 文件的标准与 `.info.yml` 文件类似，遵循 `<模块名>.module` 的模式。

对于我们正在开发的第一个模块，我们将创建 `forcontu_hello.module` 文件。请记住将文件编码为 UTF-8 无 BOM，并尽可能使用英文文本。

我们开始在 `forcontu_hello.module` 文件中生成代码，但在此之前，有必要强调 Drupal 在生成和记录代码时遵循严格的标准。我们的 `forcontu_hello.module` 文件从以下代码开始（为了便于理解，注释中的文本已用西班牙语编写）：

```php
<?php
/**
 * @file
 * Module file for Forcontu Hello
 * Este módulo crea una página estática con un mensaje de bienvenida.
 */
```

#### .module 文件示例

`.module` 文件包括以 PHP 函数形式编写的代码。它以 `@file` 指令描述模块。

正如我们之前所提到的，`.module` 文件只是一个 PHP 脚本，因此第一行以 PHP 代码的起始标记 `<?php` 开始。我们不会在文件末尾使用 PHP 关闭标记 `?>`，这种约定可以避免在 HTTP 头信息发送之前由于空白字符或其他“不可见”字符而导致的潜在错误。

代码提供了 Drupal 模块的自动化文档信息（通过 API 文档）。这是一个以 `/**` 开始并以 `*/` 结束的 PHP 注释块。其余行都以 `*` 字符开始。并非代码的所有内容都是文本，还有一个特殊的标识符提供附加信息。在我们的示例中，标识符 `@file` 表明其余信息是关于整个文件的，而不是特定函数，因此我们在此处包含了模块的描述性信息。

到此为止，我们已经准备好为我们的模块生成必要的 PHP 代码。在第 16.4 节中，我们将在 `.module` 文件中实现一个 hook。
# 16.2 创建页面

在本节中，我们将学习如何创建一个编程页面。这个页面将有一个路径和一个菜单链接。

在 Drupal 7 中，我们使用 `hook_menu()` 来注册页面的 URL 并定义菜单链接。从 Drupal 8 开始，使用 Symfony 的路由系统，并将路由和菜单的概念分开。因此，`hook_menu()` 完全消失了。

在 Drupal 10 中，路由被定义为配置（`.routing.yml` 文件），页面的内容通过控制器类中的方法返回。

### 页面路由

要定义页面的路由，我们需要创建一个路由文件，名为 `forcontu_hello.routing.yml`，并将其放在模块的根目录，与 `.info.yml` 文件一起。在这个文件中，将定义我们模块中创建的所有页面路由。

以下是路由文件的内容：

```yaml
forcontu_hello.hello:
  path: '/forcontu/hello'
  defaults:
    _controller: '\Drupal\forcontu_hello\Controller\ForcontuHelloController::hello'
    _title: 'Hello Page'
  requirements:
    _permission: 'access content'
```

路由定义包括以下部分：

- **forcontu_hello.hello**：这是路由的系统名称（machine name）。通常我们使用模块名称作为前缀（例如 `forcontu_hello`）。
- **path**：页面的物理路径。这是加载页面时在浏览器中使用的路径，例如：`http://www.example.com/path`。在我们的示例中，页面将在 URL `http://www.example.com/forcontu/hello` 上可用。
- **defaults**：路由的默认属性：
  - **`_controller`**：指向用于返回页面内容的控制器类和方法。如果与 Drupal 7 相比，这相当于 `hook_menu` 中定义的回调函数（'page callback'）。
  - **`_title`**：页面的标题。
- **requirements**：用户访问路由必须满足的条件：
  - **`_permission`**：指定用户访问页面所需的权限。稍后我们将学习如何在模块中定义自定义权限。
### 定义页面内容的控制器类

接下来，我们需要创建一个控制器类来返回页面的内容。

为了创建我们模块的控制器，我们将扩展核心中可用的 `ControllerBase` 类。可以在以下链接中查看我们控制器将继承的方法：
[ControllerBase 类文档](https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Controller%21ControllerBase.php/class/ControllerBase/10)

控制器将创建在以下文件中：
`\modules\custom\forcontu_hello\src\Controller\ForcontuHelloController.php`

我们需要在模块文件夹中创建子文件夹的结构。

以下是控制器类的代码：

```php
<?php
/**
 * @file
 * Contains \Drupal\forcontu_hello\Controller\ForcontuHelloController.
 */

namespace Drupal\forcontu_hello\Controller;

use Drupal\Core\Controller\ControllerBase;

/**
 * Controlador para devolver el contenido de las páginas definidas
 */
class ForcontuHelloController extends ControllerBase {

  public function hello() {
    return [
      '#markup' => '<p>' . $this->t('Hello, Forcontu! This is my first module in Drupal 10!') . '</p>',
    ];
  }

}
```

我们回顾一下在路由文件（`forcontu_hello.routing.yml`）中的控制器定义：

```yaml
forcontu_hello.hello:
  path: '/forcontu/hello'
  defaults:
    _controller: '\Drupal\forcontu_hello\Controller\ForcontuHelloController::hello'
    _title: 'Hello Page'
  requirements:
    _permission: 'access content'
```

在 `::` 操作符之前的部分指的是控制器类的位置和名称（`class ForcontuHelloController`）。在 `::` 操作符之后的部分（`hello`）指的是类中的方法或函数，该方法负责返回特定页面的内容。

==在定义多个页面的模块中，将有一个控制器负责所有页面。每个页面在控制器类中将有自己的方法。==

`hello()` 方法返回一个包含页面内容的可渲染数组。我们将在后续单元中详细了解可渲染数组。目前，我们只需知道 `#markup` 属性用于指定 HTML 输出。在我们的示例中，生成的页面 HTML 将是：
```html
<p>Hello, Forcontu! This is my first module in Drupal 10!</p>
```
（或其相应的翻译）。

```php
class ForcontuHelloController extends ControllerBase {

  public function hello() {
    return [
      '#markup' => '<p>' . $this->t('Hello, Forcontu! This is my first module in Drupal 10!') . '</p>',
    ];
  }

}
```

你可以在 Drupal API 中阅读更多关于可渲染数组的信息：
[可渲染数组文档](https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Render%21theme.api.php/group/theme_render/10)

### `t()` ==函数==

现在我们来关注一下 `t()` 函数，它在通过 `#markup` 属性由页面构造函数返回的 HTML 字符串中被使用。

`t()` 函数允许系统将文本字符串翻译成站点中激活的其他语言。

你可以在 Drupal 的 API 中找到 `t()` 函数的详细描述：
[`t()` 函数文档](https://api.drupal.org/api/drupal/core%21includes%21bootstrap.inc/function/t/10)

正如我们之前提到的，基础语言是英语，因此强烈建议用英语编写所有代码。`t()` 函数允许我们稍后手动或自动通过与模块关联的翻译文件将这些字符串翻译成西班牙语（或任何其他语言）。

在 Drupal 10 中，推荐在可用时使用 `$this->t()` 方法，而不是 `t()`。在 `$this->t()` 中，`t()` 方法由 `StringTranslationTrait` 提供：
[`StringTranslationTrait` 文档](https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21StringTranslation%21StringTranslationTrait.php/trait/StringTranslationTrait/10)

==每当我们在开发的模块中包含文本时==，都应通过 `$this->t()` 方法来实现，以便后续翻译。==如果==我们在自定义类中开发代码，而该类中最初没有 `$this->t()` 方法，我们将向类中==添加== `StringTranslationTrait`。

我们==只会在实现某些 hooks== 时直接使用 `t()` 函数，因为在这些 hooks 中 `$this->t()` 方法尚不可用。稍后我们将在实现 `hook_help()` 时看到这一点。

如前例所示，HTML 代码不包含在 `t()` 函数内。

#### 向 `t()` 函数传递参数

当要翻译的字符串包含变量部分时，我们将使用替换变量，这些变量将在呈现字符串时被替换为最终值。例如：

```php
$this->t('The content has been viewed %count times', ['%count' => $count]);
```

如果变量 `$count` 的值为 5，则生成的最终字符串将是：“The content has been viewed 5 times”（“该内容已被查看 5 次”）。

在字符串中，我们包含了变量或替换字符串的名称，前面加上 `%` 符号（`%count`）。 `t()` 函数的第二个参数，我们传递了一个数组，其中包含每个变量及其对应的值。在这个例子中，`%count` 的值来自于变量 `$count`，其值必须先前已被获取。

再看一个包含多个替换字符串的示例：

```php
$context['message'] = $this->t('Synchronizing configuration: @op @name in @collection.', [
  '@op' => $operation['op'],
  '@name' => $operation['name'],
  '@collection' => $operation['collection']
]);
```

我们将所有替换变量集成到文本中，然后在作为第二个参数传递的数组中添加键值对，其中键对应替换变量的名称。

在第二个示例中，替换变量前面加上 `@` 符号（`@op`、`@name`、`@collection`）。

#### 使用 `%` 和 `@` 替换字符串的==区别==

实际上，有三种可能的替换变量类型：

- **@variable**：字符串将通过 \Drupal\Component\Utility\Html::escape() 方法==进行“清理”或过滤==。例如，将某些字符转换为相应的 HTML 实体，以避免它们被解释为 HTML 代码：
  - `&`（&符号）转换为 `&amp;`
  - `"`（双引号）转换为 `&quot;`
  - `'`（单引号）转换为 `&#039;`
  - `<`（小于号）转换为 `&lt;`
  - `>`（大于号）转换为 `&gt;`

  这是我们默认应使用的格式。

- **%variable**：返回的文本在 `<em></em>` 标签之间（==强调文本，斜体==）。

- **:variable**：除了 \Drupal\Component\Utility\Html::escape() 方法提供的转换外，还应用了额外的安全过滤器。当==替换值是 URL== 时使用。

`t()` 方法内部使用以下方法，你可以在其中查阅更多关于替换变量格式的信息：
[FormattableMarkup::placeholderFormat() 方法文档](https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Component%21Render%21FormattableMarkup.php/function/FormattableMarkup::placeholderFormat/10)

其他相关链接：
- [\Drupal\Component\Utility\Html::escape()](https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Component%21Utility%21Html.php/function/Html::escape/10)

我们将在第 34 单元中更多地了解模块翻译。
### 菜单链接

在 Drupal 10 中，页面路径的定义与菜单链接的定义已经分离。==菜单链接也被定义为配置文件==，专门为此创建一个 `.yml` 文件。定义菜单元素的文件结构为 `模块名.links.menu.yml`。

对于我们的模块，我们将创建 `forcontu_hello.links.menu.yml` 文件，并将其放在模块的根目录中。文件内容如下：

```yaml
forcontu_hello.hello:
  title: Hello Page
  description: 'Hello Page menu link'
  route_name: forcontu_hello.hello
  menu_name: main
  weight: 1
```

菜单元素的定义==包括以下部分==：

- **forcontu_hello.hello**：这是菜单元素的系统名称（machine name）。尽管它与 `forcontu_hello.routing.yml` 中定义的路径系统名称相同，但它们不必相同。
- **title**：菜单元素的标题。这是显示在菜单中的文本。
- **description**：菜单元素的描述。这是鼠标悬停在链接上时显示的文本。它对应于 HTML 链接中的 `title` 属性（`<a href="/forcontu/hello" title="Hello Page menu link">`）。
- **route_name**：路径的系统名称，如 `routing.yml` 文件中定义的那样。
- **menu_name**：显示菜单元素的菜单名称。在我们的模块中，`main` 是主菜单的系统名称。如果==省略菜单名称==，则==默认==使用工具菜单（Tools）。
- **weight**：元素的权重。用于相对于菜单中的其他元素进行排序。
# 16.3激活模块

接下来的步骤是激活模块并测试创建的页面是否正常工作。

可以从以下路径安装模块：
- 管理界面：管理 -> 扩展（或扩展）
- URL: `/admin/modules`

在 Forcontu 组下会显示 Forcontu Hello 模块，默认情况下是未激活的。只需激活模块并保存配置即可。

对于本课程的后端开发，推荐使用 Drush 命令行工具来安装模块，并在安装后清空缓存：

```bash
$ drush en forcontu_hello
[success] Successfully enabled: forcontu_hello
$ drush cr
[success] Cache rebuild complete.
```

激活后，我们将在主菜单中看到 `Hello Page` 菜单选项。也可以通过在浏览器中直接输入 URL 来访问模块创建的页面：
`http://www.example.com/forcontu/hello`

最后，我们将翻译模块的字符串。访问路径：
- 管理 -> 配置 -> 区域和语言 -> 用户界面翻译
- URL: `/admin/config/regional/translate`

在“翻译”选项卡中，我们需要找到模块的字符串并分配相应的翻译：

- `Hello Page`（页面的欢迎）
- `Hello, Forcontu! This is my first module in Drupal 10!`（你好，Forcontu！这是我在 Drupal 10 中的第一个模块！）
- `Hello Page menu link`（欢迎页面的菜单链接）
- `Displays a basic page.`（显示一个基本页面）

完成翻译后，我们会立即看到菜单和模块创建的页面中的更改。

同时，我们还需要检查在模块管理区域中进行的翻译。