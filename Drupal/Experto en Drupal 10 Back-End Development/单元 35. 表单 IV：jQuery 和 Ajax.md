
==单元内容==

35.1 介绍 Drupal 中的 JavaScript
35.2 介绍 jQuery
35.3 核心中的 jQuery 库
35.4 表单元素的条件加载（#states）
35.5 Drupal 中的 Ajax
35.6 表单中的 Ajax
35.7 表单元素的自动完成

# 35.1 介绍 Drupal 中的 JavaScript

JavaScript 允许在网站上添加动态展示效果。通过 JavaScript，可以实现如显示/隐藏元素或自动递减的计数器等效果，而无需重新加载页面。在 Drupal 中，可以添加自定义的 JavaScript 代码，也可以使用 jQuery，这是一个集成在核心中的函数库，简化了 JavaScript 的使用。

jQuery 允许操作 DOM（Document Object Model，文档对象模型）元素，DOM 是一个 API，提供对构成 HTML 和 XML 页面对象的访问。通过操作这些对象，可以修改 HTML 和 XML 文档的内容、结构和样式。此外，还可以响应事件（如点击或悬停在元素上、按下键、加载页面等）。

JavaScript 是一种在客户端执行的语言，但结合 Ajax，可以实现与服务器的异步通信。这种通信允许在不重新加载整个页面的情况下，对页面的某些内容进行更改。

在本单元中，我们将通过 jQuery 和 Drupal 的 Ajax 框架来介绍 JavaScript/Ajax 编程。

在这一部分，我们将重点介绍如何加载包含 JavaScript 代码的文件。我们将创建一个名为 Forcontu jQuery（forcontu_jquery）的模块，在其中实现 jQuery 的使用示例。

#### JavaScript 文件

在 Drupal 10 中，所有 JavaScript 代码都必须==声明在一个闭包==（closure）函数中，以限制所使用变量的作用域，避免意外覆盖其他全局变量。

```javascript
(function () {
  'use strict';
  // Custom javascript
})();
```

你可以在这里了解更多关于 JavaScript 严格模式的信息：
[JavaScript 严格模式](https://www.w3schools.com/js/js_strict.asp)

此外，始终应使用 `'use strict'` 指令，以强制代码在严格模式下运行（例如，所有变量必须声明）。

==通过将参数 `$` 传递给这个函数==，我们可以在内部使用 `$()` 函数，这是 jQuery() 的别名，允许我们使用 jQuery。

```javascript
(function ($) {
  'use strict';
  // jQuery code
})(jQuery);
```

我们将创建一个 JavaScript 代码的第一个示例。我们将在下一部分中详细介绍如何实现这个 jQuery 代码。该脚本的作用是定位具有 CSS 类 `.fadeout`（class="fadeout"）的 HTML 元素。在 2 秒（2000 毫秒）的延迟后，将应用 `fadeOut()` 函数，使元素在 3 秒内逐渐消失。

文件：`/forcontu_jquery/js/forcontu_jquery_fadeout.js`

```javascript
(function ($) {
  'use strict';

  $(document).ready(function() {
    $(".fadeout").delay(2000).fadeOut(3000);
  });
})(jQuery);
```

#### 定义 JS 库

在之前的单元中，我们已经介绍了如何创建包含 CSS 文件的库。这些库也可以包含 JS 文件，因此添加 JS 文件的过程完全相同。

JS 文件通常位于主题或模块的 `/js` 文件夹中，并在 `.libraries.yml` 文件中声明。

在图 [F35.1a] 中显示了一个 `.libraries.yml` 文件的示例，其中引用了 `css/foo.css` 和 `js/foo.js` 文件。==如果 JavaScript 文件包含 jQuery==，则需要添加对 `core/jquery` 库的依赖，因为 ==Drupal 8 仅在需要时加载 jQuery==。

```yaml
foo:
  version: 1.x
  css:
    theme:
      css/foo.css: {}
  js:
    js/foo.js: {}
  dependencies:
    - core/jquery
```

==所有库都将在同一个== `.libraries.yml` 文件中声明。一个库可以引用多个 CSS 和 JS 文件，但通常只包含直接相关的文件，以便在每个时刻仅加载实际需要的脚本。

在我们的示例中，创建了文件 `/js/forcontu_jquery_fadeout.js`。现在我们需要定义一个库以便引用它。在 `.libraries.yml` 文件中定义一个名为 `forcontu_jquery.fadeout` 的库，其中包含前面的 .js 文件。

文件：`/forcontu_jquery/forcontu_jquery.libraries.yml`

```yaml
forcontu_jquery.fadeout:
  js:
    js/forcontu_jquery_fadeout.js: {}
  dependencies:
    - core/jquery
```

如前所述，==Drupal 仅在某个库请求时加载 jQuery==。我们通过添加对 jQuery 库（`core/jquery`）的==依赖==来实现这一点。

==注意==：`core.jquery` 库在 `/core/core.libraries.yml` 文件中定义，并使用模块中包含的 jQuery ==版本==。新的依赖库添加方式允许我们在需要时链接到其他版本的 jQuery，前提是已安装相应版本。

#### 附加 JS 库

定义库后，有多种方式使用它。指定的名称是模块名加库名（不直接指定 JS 文件名）。

##### 全局方式

此方法==仅适用于主题==，而不适用于模块。在主题的 `.info.yml` 文件中，可以添加 `libraries` 指令，以指示在使用该主题的所有页面上加载的库：

```yaml
name: Bartik
type: theme
base theme: classy
description: 'A flexible, ...'
package: Core
libraries:
  - bartik/global-styling
```

##### 在数组和可渲染元素中

`#attached` 属性允许在可渲染元素（和表单）中附加库。例如：

```php
$build['foo'] = [
  '#markup' => $this->t('Lorem ipsum...'),
  '#attached' => [
    'library' => [
      'forcontu_jquery/forcontu_jquery.bar',
    ],
  ],
];
```

##### 在 Twig 模板中

要将库附加到 Twig 模板中（无论是在模块还是主题中），使用 Twig 的 `attach_library()` 函数，同时指定模块名和库名。

```twig
{% block messages %}
  {% if message_list is not empty %}
    {{ attach_library('bartik/messages') }}
    <div class="messages__wrapper layout-container">
      {{ parent() }}
    </div>
  {% endif %}
{% endblock messages %}
```

##### 预处理函数

实现预处理函数（`hook_preprocess_HOOK`）：

[hook_preprocess_HOOK](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Render!theme.api.php/function/hook_preprocess_HOOK/10)

```php
/**
 * Implements hook_preprocess_HOOK() for maintenance_page.
 */
function seven_preprocess_maintenance_page(&$variables) {
  $variables['#attached']['library'][] = 'seven/maintenance-page';
}
```

##### 添加到特定页面

如果希望限制库加载的页面，可以通过页面级别的预处理函数 `hook_preprocess_page()` 实现。在这种情况下，需要根据路径添加缓存，并检查当前路径。例如：

```php
/**
 * Implements hook_preprocess_HOOK() for page.
 */
function forcontu_theming_preprocess_page(&$variables) {
  $variables['page']['#cache']['contexts'][] = 'route';
  if (\Drupal::routeMatch()->getRouteName() === 'forcontu_theming.render_elements') {
    $variables['#attached']['library'][] = 'forcontu_theming/forcontu_theming.css';
  }
}
```

另一种在特定页面（或条件）下添加库的方法是实现 `hook_page_attachments()`：

[hook_page_attachments](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Render!theme.api.php/function/hook_page_attachments/10)

```php
/**
 * Implements hook_page_attachments().
 */
function foo_page_attachments(array &$attachments) {
  $attachments['#attached']['library'][] = 'foo/bar';
  if (!\Drupal::currentUser()->hasPermission('custom permissions')) {
    $attachments['#attached']['library'][] = 'foo/baz';
  }
}
```

如果你想了解更多关于在模块和主题中使用库的信息，可以参考以下链接：
[在 Drupal 模块中添加样式表（CSS）和 JavaScript（JS）](https://www.drupal.org/docs/creating-custom-modules/adding-stylesheets-css-and-javascript-js-to-a-drupal-module)

#### 页面 /forcontu/jquery/fadeout

回到我们的示例，我们将定义 URL（`/forcontu/jquery/fadeout`）和相应的控制器类：

```yaml
forcontu_jquery.fadeout:
  path: '/forcontu/jquery/fadeout'
  defaults:
    _controller: '\Drupal\forcontu_jquery\Controller\ForcontuJqueryController::fadeout'
    _title: 'Fade out example'
  requirements:
    _permission: 'access content'
```

在控制器方法中，我们定义一个类型为 `html_tag`（`<p>`）的元素，并添加 `fadeout` 类，这是我们的 jQuery 代码用来使元素消失的引用。我们还将库添加到可渲染数组（`#attached`）中：

```php
class ForcontuJqueryController extends ControllerBase {
  public function fadeout() {
    $build['text'] = [
      '#markup' => '<p>' . $this->t('Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis tristique enim lorem, quis imperdiet ante luctus non. Phasellus sapien neque, placerat sed odio ut, efficitur tincidunt dui.') . '</p>',
    ];
    $build['temp_text'] = [
      '#type' => 'html_tag',
      '#tag' => 'p',
      '#attributes' => [
        'class' => 'fadeout',
      ],
      '#value' => $this->t('This text will disappear in 5 seconds...'),
      '#attached' => [
        'library' => [
          'forcontu_jquery/forcontu_jquery.fadeout',
        ],
      ],
    ];
    return $build;
  }
}
```

现在，我们的模块已经包含了所有元素，可以加载页面 `/forcontu/jquery/fadeout` 以及相应的 JS 文件。

注意：在更改路径、模板文件、库等时，请记得清空站点缓存。还可能需要使用 `Control + F4` 更新浏览器缓存。

结果将是一个包含两个段落的页面。其中一个段落分配了 `fadeout` 类，并将逐渐消失（`display: none`）。
#### 合并 JavaScript 文件

如果我们分析浏览器中生成的源代码，我们需要定位 `forcontu_jquery/js/forcontu_jquery_fadeout.js` 文件的包含情况。这取决于我们是否启用了“合并 JavaScript 文件”选项 [F35.1c]：

管理 -> 配置 -> 开发 -> 性能

==当启用该选项时==（推荐在生产环境中启用），会加载一些优化后的 JS 文件（去掉空格并合并成更少的文件）：

```html
<script src="/sites/default/files/js/js_BKcMdIbOMdbTdLn9dkUq3KCJfIKKo2SvKoQ1AnB8Dg.js"></script>
<!--[if lte IE 9]>
<script src="/sites/default/files/js/js_VhqXmo4azheUjYC30rijnR_Dddo0WjWkF27k5gTL8S3.js"></script>
<![endif]-->
<script src="/sites/default/files/js/js_LfAhFkv2X3HMII3xdztgawJmANKuEhoqkFSgUNDRlE.js"></script>
```

==在这种情况下==，我们无法直接知道我们的 JS 文件是否正在加载。==因此==，在开发环境中建议禁用此选项。未优化版本会显示独立的 JavaScript 文件：

```html
<script src="/core/assets/vendor/domready/ready.min.js?v=1.0.8"></script>
<!--[if lte IE 9]>
<script src="/core/assets/vendor/classList/classList.min.js?v=2014-12-13"></script>
<![endif]-->
<script src="/core/assets/vendor/jquery/jquery.min.js?v=2.2.4"></script>
<script src="/core/assets/vendor/underscore/underscore-min.js?v=1.7.3"></script>
<script src="/core/assets/vendor/backbone/backbone-min.js?v=1.2.3"></script>
<script src="/core/assets/vendor/jquery-once/jquery.once.min.js?v=2.1.1"></script>
<script src="/core/misc/drupalSettingsLoader.js?v=7.2.0"></script>
<script src="/sites/default/files/languages/es_qyOYdQA-HyV-DFayu_R3TOsOVkczOPe_uMXT5wJmyM.js?oo04er"></script>
<script src="/core/misc/drupal.js?v=7.2.0"></script>
<script src="/core/misc/drupal.init.js?v=7.2.0"></script>
<script src="/core/assets/vendor/jquery.ui/ui/core-min.js?v=1.10.4"></script>
<script src="/core/assets/vendor/jquery.ui/ui/widget-min.js?v=1.10.4"></script>
<script src="/core/modules/contextual/js/contextual.js?v=7.2.0"></script>
<script src="/modules/custom/forcontu_jquery/js/forcontu_jquery_fadeout.js?oo50v8"></script>
```

##### 库的执行顺序

默认情况下，所有 JS 文件都在文档的末尾（页脚）加载。==如果需要在头部加载==，可以在库声明中指明：

```yaml
js-header:
  header: true
  js:
    header.js: {}
js-footer:
  js:
    footer.js: {}
```

##### ==可配置的 JavaScript==

==通过添加对 `core/drupalSettings` 库的依赖，可以从 PHP 向 JavaScript 代码中添加变量。==

##### .libraries.yml 文件

```yaml
cuddly-slider:
  version: 1.x
  js:
    js/cuddly-slider.js: {}
  dependencies:
    - core/jquery
    - core/drupalSettings
```

##### 从 PHP 传递参数

与使用 `#attached` 添加库一样，我们也可以将参数传递给 JavaScript 代码：

```php
$build['#attached']['library'][] = 'example_module/cuddly-slider';
$build['#attached']['drupalSettings']['example_module']['cuddlySlider']['foo'] = 'bar';
```

==在 JS 文件中，可以这样访问变量 `foo`：==

```javascript
drupalSettings.example_module.cuddlySlider.foo
// 在浏览器控制台打印
console.log(drupalSettings.example_module);
```

在这个示例中，变量的值将是 `bar`。
# 35.2 jQuery 简介

在本节中，我们将简要介绍在 Drupal 中使用 jQuery，并在 “Drupal 10 前端开发专家” 课程中进一步深入学习。

### $(document).ready()

通过 jQuery 的 `.ready()` 方法，系统会检查页面结构是否已==加载并准备就绪==，从而避免引用尚未定义的元素。通常在添加自定义 jQuery 代码之前，我们会使用以下结构：

```javascript
(function ($) {
  'use strict';

  $(document).ready(function() {
    // jQuery 代码
  });
})(jQuery)
```

### 选择元素

jQuery 提供了多种方式来引用页面上的元素，以便后续进行交互。完整的选择器列表可在以下链接中找到：
[jQuery Selectors](http://api.jquery.com/category/selectors/)

以下是一些常用的选择器：

- **ID 选择器 ("==#id==")**：选择具有指定 ID 的元素。在页面中，元素的 ID 值必须唯一。如果重复，文档将被视为无效。但选择器将返回找到的第一个具有该标识符的元素。
  [ID Selector](http://api.jquery.com/id-selector/)

  ```javascript
  // jQuery 代码  --------------------------------- Look
  $("#block1").css("border", "3px solid red");  // --------------------

  // HTML 代码
  <div id="block1">...</div>
  ```

- **类选择器 ("==.class==")**：返回==具有指定类的所有元素==。操作会应用于找到的所有元素。
  [Class Selector](http://api.jquery.com/class-selector/)

  ```javascript
  // jQuery 代码
  $(".block").css("border", "3px solid red");  // ----------------

  // HTML 代码
  <div class="block">Block 1</div>
  <div class="block">Block 2</div>
  ```

- **==标签名选择器== ("element")**：返回==具有指定标签的所有元素==。
  [Element Selector](http://api.jquery.com/element-selector/)

  ```javascript
  // jQuery 代码
  $("div").css("border", "9px solid red");  // ---------------------------------

  // HTML 代码
  <div id="block1" class="block">Block 1</div>
  <div id="block2" class="block">Block 2</div>
  <span>Block 3</span>
  ```

- **属性选择器 (name="value")**：返回具有指定属性值的所有元素。
  [Attribute Equals Selector](http://api.jquery.com/attribute-equals-selector/)

  ```javascript
  // jQuery 代码
  $('input[value="Monday"]').parent().css("color", "red");

  // HTML 代码
  <label>
    <input type="radio" name="weekday" value="Monday" />Monday
  </label>
  <label>
    <input type="radio" name="weekday" value="Tuesday" />Tuesday
  </label>
  <label>
    <input type="radio" name="weekday" value="Wednesday" />Wednesday
  </label>
  ```

其他属性选择器：
- `[name |= "value"]`：属性 name 的值为 "value" 或以 "value-" 开头的字符串。
  [Attribute Contains Prefix Selector](http://api.jquery.com/attribute-contains-prefix-selector/)
- `[name *= "value"]`：属性 name 的值包含子字符串 "value"。
  [Attribute Contains Selector](http://api.jquery.com/attribute-contains-selector/)
- `[name ~= "value"]`：属性 name 的值包含单词 "value"。
  [Attribute Contains Word Selector](http://api.jquery.com/attribute-contains-word-selector/)
- `[name != "value"]`：属性值不等于 "value"。
  [Attribute Not Equal Selector](http://api.jquery.com/attribute-not-equal-selector/)
- `[name ^= "value"]`：属性值以 "value" 开头。
  [Attribute Starts With Selector](http://api.jquery.com/attribute-starts-with-selector/)
- `[name $= "value"]`：属性值以 "value" 结尾。
  [Attribute Ends With Selector](http://api.jquery.com/attribute-ends-with-selector/)

- **`选择所有元素 ("*")`**：选择页面上的所有元素。
  [All Selector](http://api.jquery.com/all-selector/)

- **元素类型选择器**：使用缩写形式，例如 `$(':button')` 相当于 `[$('[type=button]')`。
  一些常用的类型选择器：
  - [button](http://api.jquery.com/button-selector/)
  - [checkbox](http://api.jquery.com/checkbox-selector/)
  - [file](http://api.jquery.com/file-selector/)
  - [image](http://api.jquery.com/image-selector/)
  - [password](http://api.jquery.com/password-selector/)
  - [radio](http://api.jquery.com/radio-selector/)
  - [reset](http://api.jquery.com/reset-selector/)
  - [submit](http://api.jquery.com/submit-selector/)
  - [text](http://api.jquery.com/text-selector/)

- **元素顺序选择器**：选择偶数、奇数、首个元素、最后一个元素等。
  - [even](http://api.jquery.com/even-selector/)
  - [odd](http://api.jquery.com/odd-selector/)
  - [first](http://api.jquery.com/first-selector/)
  - [last](http://api.jquery.com/last-selector/)

  ```javascript
  // jQuery 代码
  $("tr").css("color", "#FFF");
  $("tr:even").css("background-color", "red");
  $("tr:odd").css("background-color", "green");
  $("tr:first").css("background-color", "blue");

  // HTML 代码
  <table border="1">
    <tr><td>Row #0 (first)</td></tr>
    <tr><td>Row #1</td></tr>
    <tr><td>Row #2</td></tr>
    <tr><td>Row #3</td></tr>
    <tr><td>Row #4</td></tr>
    <tr><td>Row #5</td></tr>
  </table>
  ```

### 修改 CSS

jQuery API 提供了一些方法来修改页面元素的 CSS 属性：

- `.css()`：==当只传递属性名称时，返回所选元素第一个元素的属性值。当传递属性名称和值时，应用指定的样式==。
  [CSS 方法](http://api.jquery.com/css/)

  ```javascript
  // 获取样式属性值
  var color = $("div.left").css("background-color");

  // 设置样式属性值
  $("p").css("color", "#000000");
  $("#block1").css({'background-color': '#ffe', 'border': '5px solid #ccc'});
  ```

- `.addClass()`：为元素添加一个或多个类。
  [Add Class](http://api.jquery.com/addClass/)

  ```javascript
  $("p").addClass("class1 class2");
  ```

- `.removeClass()`：从元素中移除一个或多个类。
  [Remove Class](http://api.jquery.com/removeClass/)

  ```javascript
  $("p").removeClass("oldclass1 oldclass2");
  ```

- 结合使用 `.removeClass()` 和 `.addClass()` 来替换类。

  ```javascript
  $("p").removeClass("oldclass1 oldclass2").addClass("class1");
  ```

更多方法请参阅 jQuery API 的 [CSS](http://api.jquery.com/category/css/) 和 [Attributes](http://api.jquery.com/category/attributes/) 部分。

### 事件

jQuery 提供了许多事件方法，当事件发生时，会执行指定的操作。可用事件列表请参阅：
[jQuery Events](http://api.jquery.com/category/events/)

- `.change()`：当==表单元素==的值改变时触发。
  [Change Event](http://api.jquery.com/change/)

- `.click()`：当点击元素时触发。
  [Click Event](http://api.jquery.com/click/)

- `.error()`：当发生 JavaScript 错误时触发。
  [Error Event](http://api.jquery.com/error/)

- `.focus()`：当元素==获得焦点时==触发。
  [Focus Event](http://api.jquery.com/focus/)

- `.blur()`：当元素==失去焦点时==触发。
  [Blur Event](http://api.jquery.com/blur/)

- `.focusin()` 和 `.focusout()`：分别相当于 `.focus()` 和 `.blur()`，但也检查选定元素内的子元素。
  [Focusin Event](http://api.jquery.com/focusin/)
  [Focusout Event](http://api.jquery.com/focusout/)

- `.hover()`：当鼠标==悬停在元素==上时触发。
  [Hover Event](http://api.jquery.com/hover/)

- `.keydown()`：当用户首次按下键盘上的键时触发。
  [Keydown Event](http://api.jquery.com/keydown/)

- `.keypress()`：当用户按下键盘上的键时触发，每次按键都会触发。
  [Keypress Event](http://api.jquery.com/keypress/)

- 鼠标相关事件：
  - `.mousedown()`：[Mousedown Event](http://api.jquery.com/mousedown/)
  - `.mouseenter()`：[Mouseenter Event](http://api.jquery.com/mouseenter/)
  - `.mouseleave()`：[Mouseleave Event](http://api.jquery.com/mouseleave/)
  - `.mousemove()`：[Mousemove Event](http://api.jquery.com/mousemove/)
  - `.mouseout()`：[Mouseout Event](http://api.jquery.com/mouseout/)
  - `.mouseover()`：[Mouseover Event](http://api.jquery.com/mouseover/)
  - `.mouseup()`：[Mouseup Event](http://api.jquery.com/mouseup/)

- `.scroll()`：当元素滚动时触发。
  [Scroll Event](http://api.jquery.com/scroll/)

- `.select()`：当在元素中选择文本时触发。
  [Select Event](http://api.jquery.com/select/)

- `.submit()`：当尝试提交表单时触发。
  [Submit Event](http://api.jquery.com/submit/)

- `.toggle()`：允许每次点击（默认行为）元素时执行不同的操作。
  [Toggle Event](http://api.jquery.com/toggle-event/)

  ```javascript
  $("li").toggle(
    function() {
      $(this).css("color", "blue");
    },
    function() {
      $(this).css("color", "red");
    },
    function() {
      $(this).css("color", "green");
    }
  );
  ```

- `event.preventDefault()`：==阻止默认事件的执行==。例如，点击链接时阻止加载 URL。

### 效果

jQuery API 还包括一组方法，可以在页面元素上添加动态效果。完整效果列表请参阅：
[jQuery Effects](http://api.jquery.com/category/effects/)

- `.animate()`：通过修改一些 CSS 属性来生成动画。
  [Animate](http://api.jquery.com/animate/)

- `.delay()`：在动画中添加延迟，以毫秒为单位。
  [Delay](http://api.jquery.com/delay/)

- `.fadeIn()` 和 `.fadeOut()`：这些效果通过调整元素的不透明度来显示或隐藏元素。
  [FadeIn](http://api.jquery.com/fadeIn/)
  [FadeOut](http://api.jquery.com/fadeOut/)

- `.hide()` 和 `.show()`：这些效果允许隐藏或显示元素。可以传递毫秒数或 'slow'（600 ms）和 'fast'（200 ms）作为参数。
  [Hide](http://api.jquery.com/hide/)
  [Show](http://api.jquery.com/show/)

- `.slideDown()` 和 `.slideUp()`：`slideDown()` 显示元素从上到下出现，`slideUp()` 隐藏元素从下到上消失。
  [SlideDown](http://api.jquery.com/slideDown/)
  [SlideUp](http://api.jquery.com/slideUp/)

- `.stop()`：停止元素上正在执行的动画。
  [Stop](http://api.jquery.com/stop/)

### 示例：结合使用效果

在下面的示例中，标识为 `#box1` 的层通过定义的链接（`#ocultar` 和 `#mostrar`）显示或隐藏。隐藏层使用 `.fadeOut()` 效果，使层通过减少不透明度消失。显示层使用 `.slideDown()` 效果，使层从上到下出现。

```javascript
$(document).ready(function(){
  $("#ocultar").click(function(event){
    event.preventDefault();
    $('#box1').fadeOut(2000);
  });
  $("#mostrar").click(function(event){
    event.preventDefault();
    $("#box1").slideDown(3000);
  });
});
```

```html
<div id="box1" style="background-color: green; color:#fff; padding:10px;">
  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce tellus purus, hendrerit nec porta id, commodo sed sem. Donec scelerisque luctus arcu quis dignissim.</p>
</div>
<p>
  <a href="#" id="ocultar">Ocultar la capa</a> |
  <a href="#" id="mostrar">Mostrar la capa</a>
</p>
```
# 35.3 jQuery UI 库

在 Drupal 10 中，jQuery UI 库已从核心中删除。要重新引入它们，可以通过 jQuery UI 模块实现：

- **jQuery UI**: [jQuery UI Project](https://www.drupal.org/project/jquery_ui)

我们还可以添加其他 jQuery UI 库。例如，要添加 jQuery UI Accordion，可以安装以下模块：[jQuery UI Accordion](https://www.drupal.org/project/jquery_ui_accordion)。

在文件 `/core/core.libraries.yml` 中，我们可以查找仍包含在核心中的库。

### Accordion

Accordion 允许将页面元素格式化为手风琴式布局，当展开一个元素时，其余元素会折叠。插件的完整描述可以在以下链接中找到：
[Accordion Documentation](http://docs.jquery.com/UI/Accordion)

如前所述，我们需要先安装 jQuery UI 和 jQuery UI Accordion 模块。此外，还需在模块的 `.info.yml` 文件中添加依赖项：

```yaml
dependencies:
  - jquery_ui_accordion:jquery_ui_accordion
```

接下来，在 `.libraries.yml` 文件中声明库。在这里，依赖项将是 `jquery_ui_accordion/accordion`。

### 文件：forcontu_jquery.libraries.yml

```yaml
forcontu_jquery.accordion:
  js:
    js/forcontu_jquery_accordion.js: {}
  dependencies:
    - jquery_ui_accordion/accordion
```

随后，我们添加 `.js` 文件，其中包含使用插件的特定配置（`js/forcontu_jquery_accordion.js`）。手风琴将激活 ID 为 `accordion` 的元素。

### 文件：js/forcontu_jquery_accordion.js

```javascript
(function ($) {
  'use strict';

  $(document).ready(function() {
    $("#accordion").accordion();
  });
})(jQuery)
```

最后，定义一个页面以使用手风琴效果。在路由文件中定义路由 `forcontu_jquery.accordion`，URL 为 `/forcontu/jquery/accordion`。例如，添加静态内容：

### 文件：ForcontuJqueryController.php

```php
class ForcontuJqueryController extends ControllerBase {
  // ...
  public function accordion() {
    $build['content'] = [
      '#markup' => '
        <div id="accordion">
          <h3><a href="#">Section 1</a></h3>
          <div><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p></div>
          <h3><a href="#">Section 2</a></h3>
          <div><p>Vivamus nec nisl vitae lorem molestie elementum.</p></div>
          <h3><a href="#">Section 3</a></h3>
          <div><p>Quisque ultricies viverra hendrerit.</p></div>
        </div>',
      '#attached' => [
        'library' => [
          'forcontu_jquery/forcontu_jquery.accordion',
        ],
      ],
    ];

    return $build;
  }
}
```

点击每个部分的标题时，手风琴效果将如图所示。

### 其他库

以下是一些我们可以以相同方式使用的其他库。您可以在 jQuery API 中找到每个库的使用示例。

- **Dialog** (`jquery_ui_dialog/dialog`)：生成一个带标题和内容区域的浮动窗口（对话框）。该窗口可以移动、缩放和关闭。
  [Dialog Documentation](http://docs.jquery.com/UI/Dialog)
  需要模块：[jQuery UI Dialog](https://www.drupal.org/project/jquery_ui_dialog)

- **Draggable** (`jquery_ui_draggable/draggable`)：允许元素可通过鼠标拖动。通常与可以放置元素的元素（Droppable 插件）一起使用。这种技术称为拖放（Drag & Drop）。
  [Draggable Documentation](http://docs.jquery.com/UI/Draggable)
  需要模块：[jQuery UI Draggable](https://www.drupal.org/project/jquery_ui_draggable)

- **Droppable** (`jquery_ui_droppable/droppable`)：定义一个允许放置可拖动元素的元素。通常与 Draggable 插件一起使用。
  [Droppable Documentation](http://docs.jquery.com/UI/Droppable)
  需要模块：[jQuery UI Droppable](https://www.drupal.org/project/jquery_ui_droppable)

- **Progressbar** (`jquery_ui_progressbar/progressbar`)：允许添加一个进度条，显示任何过程的完成百分比。请注意，进度条不会自动计算时间和百分比，我们必须在代码中手动设置。
  [Progressbar Documentation](http://docs.jquery.com/UI/Progressbar)
  需要模块：[jQuery UI Progressbar](https://www.drupal.org/project/jquery_ui_progressbar)

- **Resizable** (`jquery_ui_resizable/resizable`)：使元素可调节大小。
  [Resizable Documentation](http://docs.jquery.com/UI/Resizable)
  需要模块：[jQuery UI Resizable](https://www.drupal.org/project/jquery_ui_resizable)

- **Selectable** (`jquery_ui_selectable/selectable`)：将列表中的元素转换为可选择的。可以直接通过鼠标点击选择，或使用 Control 键选择非连续元素。
  [Selectable Documentation](http://docs.jquery.com/UI/Selectable)
  需要模块：[jQuery UI Selectable](https://www.drupal.org/project/jquery_ui_selectable)

- **Sortable** (`core/sortable`)：允许通过拖放对元素进行排序。
  [Sortable Documentation](http://docs.jquery.com/UI/Sortable)

### 效果

jQuery 的效果可以通过 jQuery UI Effects 模块添加：
[jQuery UI Effects](https://www.drupal.org/project/jquery_ui_effects)

- **Bounce** (`jquery_ui_effects/bounce`)：使元素在水平和/或垂直方向上移动几次。
  [Bounce Effect Documentation](http://docs.jquery.com/UI/Effects/Bounce)

- **Explode** (`jquery_ui_effects/explode`)：将元素爆炸成多个部分。
  [Explode Effect Documentation](http://docs.jquery.com/UI/Effects/Explode)

- **Fold** (`jquery_ui_effects/fold`)：像纸一样折叠元素。
  [Fold Effect Documentation](http://docs.jquery.com/UI/Effects/Fold)

- **Pulsate** (`jquery_ui_effects/pulsate`)：使元素闪烁，调整其不透明度。
  [Pulsate Effect Documentation](http://docs.jquery.com/UI/Effects/Pulsate)

### ==字符串翻译==

我们知道 `t()` 函数允许代码中的字符串可通过界面翻译。同样，我们也可以通过 `Drupal.t()` 函数==在 JavaScript 代码中包含可翻译的字符==串。

在示例中，我们将字符串 "Advanced search" 追加到元素 `#block1` 末尾，使用 `.append()` 方法。该字符串将像通过 `Drupal.t()` 函数添加的其他字符串一样可翻译。

```javascript
$("#block1").append(Drupal.t('Advanced search'));
```

我们还可以向 `Drupal.t()` 函数传递参数：

```javascript
return Drupal.t('@count styles configured', {'@count': count});
```

最后，展示 `Drupal.formatPlural()` 函数的用法示例：

```javascript
var nodesCount = Drupal.formatPlural(count, '1 node', '@count nodes');
var nodesCountOfType = Drupal.formatPlural(count, '1 node of @type', '@count nodes of @type', {'@type': nodeType});
```
# 35.4 条件加载表单元素 (#states)

### 属性 `#states`

属性 `#states` 赋予表单元素条件行为，使其相对于其他表单元素进行交互。例如，可以在完成一个元素时显示另一个元素，或在激活选项时展开一个元素容器。

这些状态通过 JavaScript 进行管理，仅在客户端的呈现层面起作用。需要注意的是，为了可访问性，表单在没有 JavaScript 的情况下也应正常工作。

管理表单状态的库是 `core/drupal.states`，它加载文件 `/core/misc/states.js`。我们==无需手动加载该库==，因为系统会通过 Renderer 类自动检查渲染的元素是否使用了 `#states` 属性，并在必要时附加库。

### 属性 `#states` 的结构

`#states` 属性是一个数组，结构如下：

```php
[
  STATE1 => CONDITIONS_ARRAY1,
  STATE2 => CONDITIONS_ARRAY2,
  ...
]
```

每个键（STATE1, STATE2 等）是一个状态（例如，visible、checked 等）。每个条件数组具有键/值结构，键是 jQuery 选择器，指向要称为远程元素的其他表单元素。值是一个数组，包含满足条件以应用状态的要求。

```php
[
  'visible' => [
    JQUERY_SELECTOR => REMOTE_CONDITIONS,
    JQUERY_SELECTOR => REMOTE_CONDITIONS,
  ]
]
```

### 示例

在以下示例中，元素 `item1` 仅在复选框 `checkbox1` 被选中时显示：

```php
$form['item1'] = [
  '#type' => 'textfield',
  '#states' => [
    'visible' => [
      ':input[name="checkbox1"]' => ['checked' => TRUE],
    ],
  ],
];
```

如果一个状态有多个条件，则必须满足所有条件才能触发状态变化。如果希望只满足其中一个条件，可以使用 `or` 操作符，如下所示：

```php
$form['group'] = [
  '#type' => 'container',
  '#states' => [
    'visible' => [
      [':input[name="confirmation_type"]' => ['value' => 'page']],
      'or',
      [':input[name="confirmation_type"]' => ['value' => 'inline']],
    ],
  ],
];
```

在上述示例中，容器元素 `group` 仅在 `confirmation_type` 的值为 `page` 或 `inline` 时可见。

==容器元素的状态将影响其包含的所有元素==，所有元素将一起显示或隐藏，而无需对其各个元素单独应用状态条件。

### 可用状态

==可以应用于元素的状态有==：

- **enabled / disabled**：元素启用或禁用。
- **required / optional**：元素必填或可选。
- **visible / invisible**：元素可见或不可见。
- **checked / unchecked**：元素已选中或未选中。
- **expanded / collapsed**：元素展开或折叠。
```php
    $form['options'] = [
      '#type' => 'container',
      '#states' => [
        'visible' => [
          ':input[name="unlock_options"]' => ['checked' => TRUE],
        ],
      ],
    ];
```

在远程条件中，==可以检查以下状态==：

- **empty / filled**：元素是否为空或已填充。
- **checked / unchecked**：元素是否已选中。
- **expanded / collapsed**：元素是否已展开或折叠。
- **value**：元素的值。
```php
    $form['options']['color_name'] = [
      '#type' => 'textfield',
      '#size' => 50,
      '#title' => $this->t('Color name'),
      '#description' => $this->t('Write the color name'),
      '#states' => [
        'visible' => [
          ':input[name="color"]' => ['value' => 'other'],
        ],
        'required' => [
          ':input[name="color"]' => ['value' => 'other'],
        ],
      ],
    ];
```

`value` 条件用于检查选择列表（select、单选按钮等）中的选项是否已被选中。

### 状态变化示例

我们将在 Forcontu Forms 模块（`forcontu_forms`）中实现 States 表单。首先定义表单的路由：

### 文件：forcontu_forms/forcontu_forms.routing.yml

```yaml
forcontu_forms.states:
  path: '/forcontu/forms/states'
  defaults:
    _form: '\Drupal\forcontu_forms\Form\States'
    _title: 'States Form'
  requirements:
    _permission: 'access content'
```

### 文件：forcontu_forms/src/Form/States.php

```php
<?php

namespace Drupal\forcontu_forms\Form;

use Drupal\Core\Form\FormBase;
use Drupal\Core\Form\FormStateInterface;

class States extends FormBase {

  public function buildForm(array $form, FormStateInterface $form_state) {
    $form['title'] = [
      '#type' => 'textfield',
      '#title' => $this->t('Title'),
      '#required' => TRUE,
      '#default_value' => '',
    ];

    $form['unlock_options'] = [
      '#type' => 'checkbox',
      '#title' => $this->t('Check to unlock more options'),
    ];
    
    $form['options'] = [
      '#type' => 'container',
      '#states' => [
        'visible' => [
          ':input[name="unlock_options"]' => ['checked' => TRUE],
        ],
      ],
    ];

    $form['options']['color'] = [
      '#type' => 'select',
      '#title' => $this->t('Color'),
      '#options' => [
        'none' => $this->t('None'),
        'black' => $this->t('Black'),
        'red' => $this->t('Red'),
        'blue' => $this->t('Blue'),
        'other' => $this->t('Other color'),
      ],
      '#description' => $this->t('Choose a color.'),
    ];

    $form['options']['color_name'] = [
      '#type' => 'textfield',
      '#size' => 50,
      '#title' => $this->t('Color name'),
      '#description' => $this->t('Write the color name'),
      '#states' => [
        'visible' => [
          ':input[name="color"]' => ['value' => 'other'],
        ],
        'required' => [
          ':input[name="color"]' => ['value' => 'other'],
        ],
      ],
    ];

    // ...
    return $form;
  }
  
  // ...
}
```

在这个例子中，当元素 `unlock_options` 被激活时，容器 `options` 将变为可见，因此它最初是隐藏的。激活复选框后，`options` 容器将变为可见。

如果在选择列表 `color` 中选择值 `other`，则元素 `color_name` 将显示，并且还将被标记为必填（required）。

通过取消选择相应选项，表单将恢复到原始状态。
# 35.5 在 Drupal 中使用 Ajax

通过 Ajax 技术，我们可以使已经加载在浏览器中的页面继续与服务器进行异步通信，交换后台信息，并在不重新加载整个页面的情况下在页面上显示这些信息。

### Drupal behaviors

在开始使用 Ajax 之前，我们需要介绍 Drupal behaviors（行为）概念。

至今为止，我们使用了 `.ready()` 方法来检查页面是否已加载并开始执行我们的代码。

```javascript
(function ($) {
  'use strict';

  $(document).ready(function() {
    // jQuery 代码
  });
})(jQuery)
```

这种方法可能会带来一个问题：因为代码==仅在页面加载时执行==，所以不会应用于稍后动态添加的新元素。这在使用 Ajax 时特别相关，因为通常会向服务器请求新数据。

Drupal Behaviors 提供了一种结构化的方法来编写和管理JavaScript代码，==确保代码在页面加载和Ajax请求后都能正确执行。==
### 不使用 Drupal Behaviors 的示例

以下是一个非常简单的示例。下面的 jQuery 代码将 CSS 类 "red-text" 添加到所有 `<p>` 标签。我们在一个 .css 文件中预先定义了这个类（`.red-text { color: red; }`）。

在 `.ready()` 事件中定义的所有操作将在 DOM 结构构建完毕后立即执行。首先，我们将类添加到所有 `<p>` 标签，但这只会影响 DOM 中已定义的标签。因此，当稍后使用 `.append()` 方法添加更多 HTML 代码时，这些内容将不会接收到其他段落已接收到的类。

```javascript
(function($){
  'use strict';
  $(document).ready(function(){
    // 添加类 "red-text" 到所有 <p> 标签
    $("p").addClass("red-text");
    // 添加新段落，此标签 <p> 不接收新类
    $("#maintext").append("<p>Vivamus ut velit nisi, id ultricies sem. Pellentesque tincidunt commodo neque et egestas.</p>");
  });
})(jQuery);
```

```html
<div id="maintext">
  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce tellus purus, hendrerit nec porta id, commodo sed sem.</p>
</div>
```

### 使用 Drupal Behaviors 的示例

通过 Drupal behaviors，我们可以在页面的某些元素上定义行为，以便在任何时候重新执行这些行为，适用于添加到 DOM 的新元素。

在下面的示例中，我们将添加类 "red-text" 的操作封装在 `Drupal.behaviors.addRedtext` 中，以便在将新元素添加到页面时重用它。

现在，在向页面添加新元素后，我们需要调用 `Drupal.attachBehaviors()` 函数，它将负责为元素添加相应的行为。

```javascript
(function($){
  'use strict';
  Drupal.behaviors.addRedtext = {
    attach: function (context, settings) {
      $("p", context).addClass("red-text");
    }
  };
  $(document).ready(function(){
    // 添加新段落
    $("#maintext").append("<p>Vivamus ut velit nisi, id ultricies sem. Pellentesque tincidunt commodo neque et egestas.</p>");
    // 执行 behaviors
    Drupal.attachBehaviors();
  });
})(jQuery);
```

```html
<div id="maintext">
  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce tellus purus, hendrerit nec porta id, commodo sed sem.</p>
</div>
```

`Drupal.attachBehaviors(context, settings)` 函数可以接收参数 `context` 和 `settings`。参数 `context` 用于传递刚刚添加到函数中的元素。==当没有==指定特定上下文时，函数将使用整个文档（document）作为上下文。在我们的示例中，我们可以将上下文限制为包含新段落的元素：

```javascript
Drupal.attachBehaviors($("#maintext"));
```

这样，将检查 `#maintext` 元素中的所有 `<p>` 标签，并只为尚未拥有该类的标签添加 CSS 类。

==当未在== `settings` 中指定当前上下文的特定配置参数时，将使用全局对象 `drupalSettings`。

在 Drupal 中，行为通过两种函数定义，一种用于内容添加到页面时（attach），另一种用于内容从页面移除时（detach）。

```javascript
(function ($) {
  'use strict';
  Drupal.behaviors.exampleBehavior = {
    attach: function (context, settings) {
      // 当内容添加到页面时
    },
    detach: function (context, settings) {
      // 当内容从页面移除时（可选）
    }
  };
})(jQuery);
```

`Drupal.attachBehaviors()` 和 `Drupal.detachBehaviors()` 函数定义在 `/core/misc/drupal.js` 中。

更多关于 `Drupal.behaviors` 的信息：
- [Drupal behaviors 文档](https://www.drupal.org/docs/drupal-apis/javascript-api/javascript-api-overview)

### 在 Drupal 中使用 Ajax

通过 Ajax，可以动态更新 HTML 页面中的特定元素，当某个事件发生时（例如点击按钮或链接），向服务器请求信息。服务器在后台提供新信息，并在页面上更新需要修改的元素，而无需重新加载整个页面。

Drupal 的 Ajax API 提供了一组类，允许完全管理 Ajax 事件：
- [Ajax API](https://api.drupal.org/api/drupal/core!core.api.php/group/ajax/10)

==我们可以多种方式使用 Drupal 的 Ajax 框架：==

- **在表单元素中**：使用 Form API，可以通过 `#ajax` ==属性==在表单元素中添加 Ajax 事件。
- **在链接中**：添加 `use-ajax` ==类==到链接，使链接作为 Ajax 调用处理。
- **在表单按钮中**：添加 `use-ajax-submit` ==类==到表单提交按钮，可以执行 Ajax 调用。

在这些情况下，当系统接收到 Ajax 调用时，==服务器执行请求的操作并创建一个命令数组==。这些命令将转换为 JSON 对象，返回给客户端进行评估和处理。

命令通常与 JavaScript/jQuery 方法相对应。例如，"css" 命令将告诉客户端使用 jQuery 的 `.css()` 方法。该命令的定义数组将包含命令名称（'command'）、应用的元素或元素（'selector'）以及应用的值（'argument'）。

==每个命令将转换为 JavaScript 命令对象==，通过 `Drupal.ajax` 中定义的方法在客户端应用。例如，'css' 命令由 `/core/misc/ajax.js` 中定义的函数实现：
- `Drupal.AjaxCommands.prototype.css()`

### 在链接中使用 Ajax

可以通过链接使用 Ajax，当点击链接时执行 Ajax 函数，从服务器获取信息。在这个示例中，获取服务器时间并显示在指定的 HTML 元素中，而无需重新加载整个页面。

我们将创建 Forcontu Ajax 模块（`forcontu_ajax`），注册以下路由：

- `forcontu_ajax.link`，URL 是 `forcontu/ajax/link`。在此页面中定义页面内容和进行 Ajax 调用的链接。
- `forcontu_ajax.link_callback`，URL 是 `forcontu/ajax/link-callback`。此路由将作为 Ajax 调用的返回。

### 文件：forcontu_ajax/forcontu_ajax.routing.yml

```yaml
forcontu_ajax.link:
  path: '/forcontu/ajax/link'
  defaults:
    _controller: '\Drupal\forcontu_ajax\Controller\ForcontuAjaxController::link'
    _title: 'Ajax link example'
  requirements:
    _permission: 'access content'

forcontu_ajax.link_callback:
  path: '/forcontu/ajax/link-callback'
  defaults:
    _controller: '\Drupal\forcontu_ajax\Controller\ForcontuAjaxController::linkCallback'
    _title: 'Ajax link example callback'
  requirements:
    _permission: 'access content'
```

### 文件：forcontu_ajax/src/Controller/ForcontuAjaxController.php

```php
<?php

namespace Drupal\forcontu_ajax\Controller;

use Drupal\Core\Controller\ControllerBase;
use Drupal\Core\Url;
use Drupal\Core\Ajax\AjaxResponse;
use Drupal\Core\Ajax\ReplaceCommand;

class ForcontuAjaxController extends ControllerBase {
  public function link() {
    $build['text'] = [
      '#markup' => '<p>' . $this->t('Click the link to get the updated time from server.') . '</p>',
    ];
    $build['time'] = [
      '#type' => 'html_tag',
      '#tag' => 'div',
      '#value' => date("H:i:s"),
      '#attributes' => [
        'id' => 'time',
      ],
    ];
    $build['refresh_time'] = [
      '#title' => $this->t('Refresh time'),
      '#type' => 'link',
      '#url' => Url::fromRoute('forcontu_ajax.link_callback'),
      '#attributes' => [
        'class' => 'use-ajax',
      ],
    ];

    return $build;
  }

  public function linkCallback() {
    $response = new AjaxResponse();
    $response->addCommand(new ReplaceCommand(
      '#time',
      '<div id="time">' . date("H:i:s") . ' (' . $this->t("via AJAX") . ')</div>'
    ));
    return $response;
  }
}
```

在 `link()` 方法中，对应路由 `forcontu_ajax.link`，定义了一个 ID 为 `time` 的 div 容器，它将通过 Ajax 替换。在该容器外添加了一个带有 `use-ajax` 类的链接。生成的 HTML 代码如下：

```html
<p>Click the link to get the updated time from server.</p>
<div id="time">19:32:42</div>
<a href="/forcontu/ajax/link-callback" class="use-ajax">Refresh time</a>
```

在 `linkCallback()` 方法中，对应路由 `forcontu_ajax.link_callback`，生成 Ajax 响应对象 `AjaxResponse`：

- [AjaxResponse API](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Ajax!AjaxResponse.php/class/AjaxResponse/10)

`addCommand()` ==方法允许添加 Ajax 命令==，执行不同的操作。在这里，我们使用了 Ajax 命令 `ReplaceCommand`，它使用 jQuery 的 `replace()` 方法。该方法定位指定选择器（`id="time"`）的所有出现，==并将其替换为目标 HTML 代码==。

- [ReplaceCommand API](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Ajax!ReplaceCommand.php/class/ReplaceCommand/10)

创建 `ReplaceCommand` 对象时，传递了 $selector（`#time`）和 $content，包含将替换的 HTML 内容。

注意，不仅替换元素的内容，==还包括元素本身的标签==（如 `<div id="time"></div>`），因此我们在替换字符串中重新包含标签。

### Ajax 命令

Ajax 命令实现 `CommandInterface` 接口或扩展其他实现该接口的命令。核心中定义的命令位于：

- `/core/lib/Drupal/Core/Ajax/*Command.php`

==一些可用命令==：

- **AppendCommand**：使用 jQuery 的 `append()` 方法向指定选择器元素==添加 HTML 代码==。
- **RemoveCommand**：使用 jQuery 的 `remove()` 方法删除与选择器匹配的==元素及其内容==。
- **AlertCommand**：实现 JavaScript ==警告窗口==。
- **OpenDialogCommand**：在==弹出对话框窗口==中打开内容。
- **OpenModalDialogCommand**：与前一个命令类似，区别在于它阻止用户与原页面进行交互，==直到完成与模态窗口的交互==。
- **RedirectCommand**：实现 ==URL 重定向==。
# 35.6 在 Drupal 中使用 Ajax 表单

在本节中，我们将向 Forcontu Ajax 模块添加一个示例 `AjaxDemo`，该示例来自于开发者示例模块 `fapi_example`。我们将创建 `AjaxForm` 表单，演示一个典型示例：两个相互依赖的选择列表，第二个列表的选项将根据第一个列表中选择的选项进行更新。

**注意**：尽管这里使用的是静态列表，但我们可以从分类术语中获取这些信息。

在这个具体示例中，第一个列表选择根据温度分为：温暖（warm）和冷（cool）。第二个列表将在第一个列表选择后重新加载相应的颜色。

### 创建路由

首先创建显示表单的路由。在这种情况下，不需要注册一个路由来进行 Ajax 调用，像在链接中添加 Ajax 时那样。

### 文件：forcontu_ajax/forcontu_ajax.routing.yml

```yaml
forcontu_ajax.form:
  path: '/forcontu/ajax/form'
  defaults:
    _form: '\Drupal\forcontu_ajax\Form\AjaxForm'
    _title: 'Ajax Form Example'
  requirements:
    _permission: 'access content'
```

### 创建表单类

接下来，我们定义处理表单的类。

### 文件：forcontu_ajax/src/Form/AjaxForm.php

```php
<?php

namespace Drupal\forcontu_ajax\Form;

use Drupal\Core\Form\FormBase;
use Drupal\Core\Form\FormStateInterface;

class AjaxForm extends FormBase {
  private $colors = [
    'warm' => [
      'red' => 'Red',
      'orange' => 'Orange',
      'yellow' => 'Yellow',
    ],
    'cool' => [
      'blue' => 'Blue',
      'purple' => 'Purple',
      'green' => 'Green',
    ],
  ];

  public function buildForm(array $form, FormStateInterface $form_state) {
    $form['temperature'] = [
      '#title' => $this->t('Temperature'),
      '#type' => 'select',
      '#options' => ['warm' => 'Warm', 'cool' => 'Cool'],
      '#empty_option' => $this->t('-select-'),
      '#ajax' => [
        'callback' => '::colorCallback',
        'wrapper' => 'color-wrapper',
      ],
    ];

    // 禁用表单缓存
    $form_state->setCached(FALSE);

    $form['color_wrapper'] = [
      '#type' => 'container',
      '#attributes' => ['id' => 'color-wrapper'],
    ];

    $form['actions'] = [
      '#type' => 'actions',
    ];

    $form['actions']['submit'] = [
      '#type' => 'submit',
      '#value' => $this->t('Submit'),
    ];

    return $form;
  }

  public function getFormId() {
    return 'forcontu_ajax_ajax_form';
  }

  public function colorCallback(array &$form, FormStateInterface $form_state) {
    $temperature = $form_state->getValue('temperature');
    $form['color_wrapper']['color'] = [
      '#type' => 'select',
      '#title' => $this->t('Color'),
      '#options' => $this->colors[$temperature],
    ];
    return $form['color_wrapper'];
  }

  public function submitForm(array &$form, FormStateInterface $form_state) {
    // 处理提交逻辑
  }
}
```

在 `buildForm` 方法中，我们定义了选择元素 `temperature`，通过 `#ajax` 属性发起 Ajax 调用：

```php
$form['temperature'] = [
  '#title' => $this->t('Temperature'),
  '#type' => 'select',
  '#options' => ['warm' => 'Warm', 'cool' => 'Cool'],
  '#empty_option' => $this->t('-select-'),
  '#ajax' => [
    'callback' => '::colorCallback',
    'wrapper' => 'color-wrapper',
  ],
];
```

我们还定义了一个容器 `color_wrapper`，它的 ID 是 `color-wrapper`，用于在 Ajax 调用时更新。

### 属性 `#ajax`

我们已经了解到，表单元素可以包含 `#ajax` 属性，该属性会添加事件以与服务器进行 Ajax 通信。

`#ajax` 属性是一个数组，可以包含以下可选值：

- **callback**：返回 Ajax 调用的函数或方法名称。返回的值可以是 HTML 内容、可渲染数组（如前面的示例）或 Ajax 命令数组。
- **wrapper**：定义用于显示 Ajax 返回内容的 HTML 元素 ID。==重要的是，替换的是整个元素，而不仅仅是其内容，因此新内容也应包含元素的 ID。==通常我们使用一个容器元素（如 `<div>`）来显示动态内容。
- **method**：指示将返回的 HTML 插入到定义的 `wrapper` 中的方式。==默认值是== `replaceWith`，还可以使用其他值如 `after`、`append`、`before`、`prepend` 或 `html`。
- **effect**：指定用于添加 Ajax 返回内容时的效果。默认值为 `none`，其他可能的值包括 `fade` 和 `slide`。
- **speed**：如果使用效果，确定速度。可以是 `slow`、`fast` 或数字值，表示毫秒数。
- **event**：触发 Ajax 请求的事件。可以使用任何 jQuery 事件，但通常与表单元素类型相关。默认值有：
  - `'mousedown'`，==用于提交元素、图片按钮和普通按钮==。
  - `'blur'`，==用于文本框和文本区域==。
  - `'change'`，==用于选择元素==。

在我们的示例中，没有添加此属性，因此作为==选择元素的默认事件==为 `'change'`。

### 示例

下面是一个完整的 Ajax 表单示例，展示了如何使用 Ajax 动态更新选择列表。

当用户在第一个选择列表中选择温度时，第二个选择列表将更新，以显示相应的颜色。

```php
// 文件: forcontu_ajax/src/Form/AjaxForm.php
namespace Drupal\forcontu_ajax\Form;

use Drupal\Core\Form\FormBase;
use Drupal\Core\Form\FormStateInterface;

class AjaxForm extends FormBase {
  private $colors = [
    'warm' => [
      'red' => 'Red',
      'orange' => 'Orange',
      'yellow' => 'Yellow',
    ],
    'cool' => [
      'blue' => 'Blue',
      'purple' => 'Purple',
      'green' => 'Green',
    ],
  ];

  public function buildForm(array $form, FormStateInterface $form_state) {
    $form['temperature'] = [
      '#title' => $this->t('Temperature'),
      '#type' => 'select',
      '#options' => ['warm' => 'Warm', 'cool' => 'Cool'],
      '#empty_option' => $this->t('-select-'),
      '#ajax' => [
        'callback' => '::colorCallback',
        'wrapper' => 'color-wrapper',
      ],
    ];

    // 禁用表单缓存
    $form_state->setCached(FALSE);

    $form['color_wrapper'] = [
      '#type' => 'container',
      '#attributes' => ['id' => 'color-wrapper'],
    ];

    $form['actions'] = [
      '#type' => 'actions',
    ];

    $form['actions']['submit'] = [
      '#type' => 'submit',
      '#value' => $this->t('Submit'),
    ];

    return $form;
  }

  public function getFormId() {
    return 'forcontu_ajax_ajax_form';
  }

  public function colorCallback(array &$form, FormStateInterface $form_state) {
    $temperature = $form_state->getValue('temperature');
    $form['color_wrapper']['color'] = [
      '#type' => 'select',
      '#title' => $this->t('Color'),
      '#options' => $this->colors[$temperature],
    ];
    return $form['color_wrapper'];
  }

  public function submitForm(array &$form, FormStateInterface $form_state) {
    // 处理提交逻辑
  }
}
```

在这个示例中，当用户选择温度后，第二个选择列表将根据第一个选择的值动态更新。

通过使用 Ajax，我们能够提升用户体验，让表单更加动态和响应迅速。
# 35.7 表单元素的自动完成

我们可以通过为 `textfield` 类型的字段添加 `#autocomplete_route_name` 属性来实现自动完成。该属性值将是一个路由，该路由实现一个返回结果数组的控制器，结果以 JsonResponse 形式返回。以下是一个示例。

### 定义路由

我们定义两个路由，一个用于表单，另一个用于返回自动完成结果：

### 文件：forcontu_ajax/forcontu_ajax.routing.yml

```yaml
forcontu_ajax.form_autocomplete:
  path: '/forcontu/ajax/form/autocomplete'
  defaults:
    _form: '\Drupal\forcontu_ajax\Form\AutocompleteForm'
    _title: 'Autocomplete Form Example'
  requirements:
    _permission: 'access content'

forcontu_ajax.user_autocomplete:
  path: '/forcontu/ajax/user_autocomplete'
  defaults:
    _controller: '\Drupal\forcontu_ajax\Controller\ForcontuAjaxAutocompleteController::userAutocomplete'
    _title: 'User autocomplete'
  requirements:
    _permission: 'access content'
```

### 实现表单

在表单中添加一个具有 `#autocomplete_route_name` 属性的 `textfield` 元素。

### 文件：forcontu_ajax/src/Form/AutocompleteForm.php

```php
<?php

namespace Drupal\forcontu_ajax\Form;

use Drupal\Core\Form\FormBase;
use Drupal\Core\Form\FormStateInterface;

class AutocompleteForm extends FormBase {
  public function getFormId() {
    return 'forcontu_ajax_autocomplete';
  }

  public function buildForm(array $form, FormStateInterface $form_state) {
    $form['user'] = [
      '#type' => 'textfield',
      '#title' => 'Username',
      '#autocomplete_route_name' => 'forcontu_ajax.user_autocomplete',
    ];

    //...

    return $form;
  }

  public function submitForm(array &$form, FormStateInterface $form_state) {
    //...
  }
}
```

### 实现自动完成控制器

实现一个方法，根据用户在文本字段中输入的值返回匹配结果。该值通过 GET 请求传递给自动完成 URL 的 `q` 参数。

### 文件：forcontu_ajax/src/Controller/ForcontuAjaxAutocompleteController.php

```php
<?php

namespace Drupal\forcontu_ajax\Controller;

use Drupal\Core\Controller\ControllerBase;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;

class ForcontuAjaxAutocompleteController extends ControllerBase {
  public function userAutocomplete(Request $request) {
    $string = $request->query->get('q');
    $users = ['admin', 'foo', 'foobar', 'foobaz'];
    $matches = preg_grep("/$string/i", $users);
    return new JsonResponse(array_values($matches));
  }
}
```

为了确保 Json 响应正确编码，我们通过 `array_values()` 函数处理结果数组，该函数将为数组添加索引。

### 路由参数化

路由也可以参数化（在 `.routing.yml` 文件中），然后使用 `#autocomplete_route_parameters` 属性从自动完成元素传递参数。参数将以参数/值数组的形式指定。

### 文件：forcontu_ajax/forcontu_ajax.routing.yml

```yaml
forcontu_ajax.user_autocomplete:
  path: '/forcontu/ajax/user_autocomplete/{role}'
  defaults:
    _controller: '\Drupal\forcontu_ajax\Controller\ForcontuAjaxAutocompleteController::userAutocomplete'
    _title: 'User autocomplete'
  requirements:
    _permission: 'access content'
```

### 更新表单

```php
$form['user'] = [
  '#type' => 'textfield',
  '#title' => 'Username',
  '#autocomplete_route_name' => 'forcontu_ajax.user_autocomplete',
  '#autocomplete_route_parameters' => ['role' => 'admin'],
];
```

### 使用 `entity_autocomplete` 元素

`entity_autocomplete` 表单元素为任何定义的实体类型提供了自动完成功能。

### 示例：选择节点

添加一个 `entity_autocomplete` 元素，用于选择类型为 `article` 或 `page` 的节点。==对于核心实体==，可以使用默认的 `#selection_handler`。对于自定义实体，需要创建自定义选择插件。

```php
$form['selected_node'] = [
  '#type' => 'entity_autocomplete',
  '#title' => 'Select a content',
  '#target_type' => 'node',
  '#selection_handler' => 'default',
  '#selection_settings' => [
    'target_bundles' => ['article', 'page'],
  ],
];
```

### 自动创建实体

`entity_autocomplete` 元素允许通过 `#autocreate` 属性自动创建实体，如果搜索的实体不存在，==可以在提交表单时创建==。

```php
$form['tags'] = [
  '#type' => 'entity_autocomplete',
  '#target_type' => 'taxonomy_term',
  '#autocreate' => [
    'bundle' => 'tags',
  ],
];
```

必须指定实体的 `bundle`，如果实体需要作者，可以选择性地指定 `uid`。如果未指定，实体将分配给当前用户。

通过以上示例，我们可以方便地为表单中的 `textfield` 和 `entity_autocomplete` 元素实现自动完成功能，提升用户体验。