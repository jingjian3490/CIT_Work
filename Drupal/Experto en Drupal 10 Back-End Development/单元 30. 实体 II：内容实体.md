
在本单元中，我们将学习如何创建内容实体和字段。
### 单元内容

30.1 内容实体
30.2 创建自定义内容类型
30.3 自定义字段
30.4 实体主题化
30.5 分类法编程
30.6 实体验证
30.7 路由访问和实体操作
30.8 实体子类型类（bundle class）
30.9 使用控制台

# 30.1 内容实体

我们再次推荐使用 Drush Generate 来生成内容实体类型的骨架。定义内容实体所需的文件数量多于配置实体，如果尝试从零开始创建，容易出错。

作为示例，我们将创建一个名为 `Message`（消息）的内容实体类型，ID 为 `forcontu_entities_message`。该实体允许站点用户之间发送消息。实体将具有多个 bundle，因此可以定义不同类型的消息。为了简化，实体不可翻译，也不支持消息的修订版本。

每个消息将具有以下属性：
- 收件人（user_to）：引用站点用户。
- 主题（subject）：文本，限制为 100 个字符。
- 内容（content）：长文本。
- 已读（is_read）：布尔类型字段，接受 FALSE（未读）和 TRUE（已读）值。此属性不可由用户填写。

我们将逐步查看创建实体所需的文件。请参阅本单元的最后一部分以了解如何使用 Drush Generate 创建实体。

### Message 实体类

在第一步中，我们将创建接口和实现实体的类。

接口扩展 `ContentEntityInterface`、`EntityChangedInterface` 和 `EntityOwnerInterface`。根据其他特性，还可以扩展其他接口。

在接口中，我们声明实体字段的 `get` 和 `set` 方法。与配置实体不同，内容实体的附加属性将定义为字段（基础字段）。稍后我们将看到具体实现。

不要忘记适当地注释这些方法。通常，我们会在接口中添加注释，并在实现该接口的类中继承这些注释。

文件：`src/Entity/MessageInterface.php`

```php
<?php
namespace Drupal\forcontu_entities\Entity;

use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\Core\Entity\EntityChangedInterface;
use Drupal\user\EntityOwnerInterface;

/**
 * Provides an interface for defining Message entities.
 *
 * @ingroup forcontu_entities
 */
interface MessageInterface extends ContentEntityInterface, EntityChangedInterface, EntityOwnerInterface {
  // Add get/set methods for your configuration properties here.

  /**
   * Gets the Message type.
   *
   * @return string
   *   The Message type.
   */
  public function getType();

  /**
   * Gets the Message subject.
   *
   * @return string
   *   Subject of the Message.
   */
  public function getSubject();

  /**
   * Sets the Message subject.
   *
   * @param string $subject
   *   The Message subject.
   *
   * @return \Drupal\forcontu_entities\Entity\MessageInterface
   *   The called Message entity.
   */
  public function setSubject($subject);

  /**
   * Gets the Message creation timestamp.
   *
   * @return int
   *   Creation timestamp of the Message.
   */
  public function getCreatedTime();

  /**
   * Sets the Message creation timestamp.
   *
   * @param int $timestamp
   *   The Message creation timestamp.
   *
   * @return \Drupal\forcontu_entities\Entity\MessageInterface
   *   The called Message entity.
   */
  public function setCreatedTime($timestamp);

  /**
   * Returns the Message published status indicator.
   *
   * Unpublished Message are only visible to restricted users.
   *
   * @return bool
   *   TRUE if the Message is published.
   */
  public function isPublished();

  /**
   * Sets the published status of a Message.
   *
   * @param bool $published
   *   TRUE to set this Message to published, FALSE to set it to unpublished.
   *
   * @return \Drupal\forcontu_entities\Entity\MessageInterface
   *   The called Message entity.
   */
  public function setPublished($published);

  /**
   * Gets the To user id.
   *
   * @return int
   *   The user id.
   */
  public function getUserToId();

  /**
   * Sets the To user id.
   *
   * @param int $uid
   *   To user id.
   *
   * @return $this
   */
  public function setUserToId($uid);

  /**
   * Gets the To user object.
   *
   * @return UserInterface
   *   The user object.
   */
  public function getUserTo();

  /**
   * Sets the To user object.
   *
   * @param string $account
   *   The user object.
   *
   * @return $this
   */
  public function setUserTo(UserInterface $account);

  /**
   * Gets the Content.
   *
   * @return string
   *   Message content.
   */
  public function getContent();

  /**
   * Sets the message's content.
   *
   * @param string $content
   *   Message's content.
   *
   * @return $this
   */
  public function setContent($content);

  /**
   * Returns the Message read indicator.
   *
   * @return bool
   */
  public function isRead();

  /**
   * Sets the read status of a Message.
   *
   * @param bool $read
   *   TRUE to set this Message to read.
   *
   * @return $this
   */
  public function setRead($read);
}
```

接下来，我们实现 `Message` 类，该类扩展 `ContentEntityBase` 并实现上述接口。请记住，虽然实体类型的系统名称或 ID 包含模块名称作为前缀，但类名不需要这样做。

类具有注解格式的注释头，在 `@ContentEntityType` 指令中定义实体的属性。

文件：`src/Entity/Message.php`（注解）

```php
<?php
namespace Drupal\forcontu_entities\Entity;

use Drupal\Core\Entity\EntityStorageInterface;
use Drupal\Core\Field\BaseFieldDefinition;
use Drupal\Core\Entity\ContentEntityBase;
use Drupal\Core\Entity\EntityChangedTrait;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\user\UserInterface;

/**
 * Defines the Message entity.
 *
 * @ingroup forcontu_entities
 *
 * @ContentEntityType(
 *   id = "forcontu_entities_message",
 *   label = @Translation("Message"),
 *   bundle_label = @Translation("Message type"),
 *   handlers = {
 *     "view_builder" = "Drupal\Core\Entity\EntityViewBuilder",
 *     "list_builder" = "Drupal\forcontu_entities\MessageListBuilder",
 *     "views_data" = "Drupal\forcontu_entities\Entity\MessageViewsData",
 *     "form" = {
 *       "default" = "Drupal\forcontu_entities\Form\MessageForm",
 *       "add" = "Drupal\forcontu_entities\Form\MessageForm",
 *       "edit" = "Drupal\forcontu_entities\Form\MessageForm",
 *       "delete" = "Drupal\forcontu_entities\Form\MessageDeleteForm",
 *     },
 *     "access" = "Drupal\forcontu_entities\MessageAccessControlHandler",
 *     "route_provider" = {
 *       "html" = "Drupal\forcontu_entities\MessageHtmlRouteProvider",
 *     },
 *   },
 *   base_table = "forcontu_entities_message",
 *   admin_permission = "administer message entities",
 *   entity_keys = {
 *     "id" = "id",
 *     "bundle" = "type",
 *     "label" = "subject",
 *     "uuid" = "uuid",
 *     "uid" = "user_id",
 *     "langcode" = "langcode",
 *     "status" = "status",
 *   },
 *   links = {
 *     "canonical" = "/admin/structure/forcontu_entities_message/{forcontu_entities_message}",
 *     "add-page" = "/admin/structure/forcontu_entities_message/add",
 *     "add-form" = "/admin/structure/forcontu_entities_message/add/{forcontu_entities_message_type}",
 *     "edit-form" = "/admin/structure/forcontu_entities_message/{forcontu_entities_message}/edit",
 *     "delete-form" = "/admin/structure/forcontu_entities_message/{forcontu_entities_message}/delete",
 *     "collection" = "/admin/structure/forcontu_entities_message",
 *   },
 *   bundle_entity_type = "forcontu_entities_message_type",
 *   field_ui_base_route = "entity.forcontu_entities_message_type.edit_form"
 * )
 */
```

在 `@ContentEntityType` 中，我们定义了以下属性：
- `base_table`：用于存储 Message 类型实体的表名。
- `bundle_label`：此实体的 bundle 类型标签。
- 在 `entity_keys` 中：
  - `bundle` = `type`：bundle 的内部名称为 `type`，因此我们将创建消息类型。这类似于内容类型，其中 bundle 也标识为 `type`。
  - ==`label` = `subject`：每个消息的标签对应于 `subject` 字段（消息主题）==。这是我们在使用 Drush Generate 生成文件后唯一更改的地方。
- `bundle_entity_type`：存储 bundle 信息的配置实体类型名称。

在同一文件中，我们定义 `Message` 类，指明其属性和接口要求的方法。与配置实体不同，附加属性不会在此处作为属性添加。

文件：`src/Entity/Message.php`（类）

```php
class Message extends ContentEntityBase implements MessageInterface {
  use EntityChangedTrait;

  /**
   * {@inheritdoc}
   */
  public static function preCreate(EntityStorageInterface $storage_controller, array &$values) {
    parent::preCreate($storage_controller, $values);
    $values += [
      'user_id' => \Drupal::currentUser()->id(),
    ];
  }

  public function getType() {
    return $this->bundle();
  }

  public function getSubject() {
    return $this->get('subject')->value;
  }

  public function setSubject($subject) {
    $this->set('subject', $subject);
    return $this;
  }

  public function getCreatedTime() {
    return $this->get('created')->value;
  }

  public function setCreatedTime($timestamp) {
    $this->set('created', $timestamp);
    return $this;
  }

  public function getOwner() {
    return $this->get('user_id')->entity;
  }

  public function getOwnerId() {
    return $this->get('user_id')->target_id;
  }

  public function setOwnerId($uid) {
    $this->set('user_id', $uid);
    return $this;
  }

  public function setOwner(UserInterface $account) {
    $this->set('user_id', $account->id());
    return $this;
  }

  public function isPublished() {
    return (bool) $this->getEntityKey('status');
  }

  public function setPublished($published) {
    $this->set('status', $published ? TRUE : FALSE);
    return $this;
  }

  public function getUserToId() {
    return $this->get('user_to')->target_id;
  }

  public function setUserToId($uid) {
    $this->set('user_to', $uid);
    return $this;
  }

  public function getUserTo() {
    return $this->get('user_to')->entity;
  }

  public function setUserTo(UserInterface $account) {
    $this->set('user_to', $account->id());
    return $this;
  }

  public function getContent() {
    return $this->get('content')->value;
  }

  public function setContent($content) {
    $this->set('content', $content);
    return $this;
  }

  public function isRead() {
    return (bool) $this->getEntityKey('is_read');
  }

  public function setRead($read) {
    $this->set('is_read', $read ? TRUE : FALSE);
    return $this;
  }

  // ...
```

在 `baseFieldDefinitions()` 方法中，我们定义实体的基础字段。这些字段虽然构建为 Field API 字段，但用户无法通过“管理字段”界面修改。它们是直接存储在实体基础表（`forcontu_entities_message`）中的基础字段。

文件：`src/Entity/Message.php`（字段）

```php
public static function baseFieldDefinitions(EntityTypeInterface $entity_type) {
  $fields = parent::baseFieldDefinitions($entity_type);

  $fields['user_id'] = BaseFieldDefinition::create('entity_reference')
    ->setLabel(t('Authored by'))
    ->setDescription(t('The user ID of author of the Message entity.'))
    ->setRevisionable(TRUE)
    ->setSetting('target_type', 'user')
    ->setSetting('handler', 'default')
    ->setTranslatable(TRUE)
    // setDisplayOptions 是不必要的，因为可以在页面中修改
    ->setDisplayOptions('view', [
      'label' => 'hidden',
      'type' => 'author',
      'weight' => 0,
    ])
    ->setDisplayOptions('form', [
      'type' => 'entity_reference_autocomplete',
      'weight' => 5,
      'settings' => [
        'match_operator' => 'CONTAINS',
        'size' => '60',
        'autocomplete_type' => 'tags',
        'placeholder' => '',
      ],
    ])
    ->setDisplayConfigurable('form', TRUE)
    ->setDisplayConfigurable('view', TRUE);

  $fields['user_to'] = BaseFieldDefinition::create('entity_reference')
    ->setLabel(t('To'))
    ->setDescription(t('The user ID of the Message recipient.'))
    ->setRevisionable(TRUE)
    ->setSetting('target_type', 'user')
    ->setSetting('handler', 'default')
    ->setTranslatable(TRUE)
    ->setDisplayOptions('view', [
      'label' => 'To',
      'type' => 'author',
      'weight' => 0,
    ])
    ->setDisplayOptions('form', [
      'type' => 'entity_reference_autocomplete',
      'weight' => 5,
      'settings' => [
        'match_operator' => 'CONTAINS',
        'size' => '60',
        'autocomplete_type' => 'tags',
        'placeholder' => '',
      ],
    ])
    ->setDisplayConfigurable('form', TRUE)
    ->setDisplayConfigurable('view', TRUE);

  $fields['subject'] = BaseFieldDefinition::create('string')
    ->setLabel(t('Subject'))
    ->setDescription(t('The subject of the Message entity.'))
    ->setSettings([
      'max_length' => 100,
      'text_processing' => 0,
    ])
    ->setDefaultValue('')
    ->setDisplayOptions('view', [
      'label' => 'above',
      'type' => 'string',
      'weight' => -4,
    ])
    ->setDisplayOptions('form', [
      'type' => 'string_textfield',
      'weight' => -4,
    ])
    ->setDisplayConfigurable('form', TRUE)
    ->setDisplayConfigurable('view', TRUE);

  $fields['content'] = BaseFieldDefinition::create('text_long')
    ->setLabel(t('Content'))
    ->setDescription(t('The content of the Message'))
    ->setTranslatable(TRUE)
    ->setDisplayOptions('view', [
      'label' => 'hidden',
      'type' => 'text_default',
      'weight' => 0,
    ])
    ->setDisplayConfigurable('view', TRUE)
    ->setDisplayOptions('form', [
      'type' => 'text_textfield',
      'weight' => 0,
    ])
    ->setDisplayConfigurable('form', TRUE);

  $fields['is_read'] = BaseFieldDefinition::create('boolean')
    ->setLabel(t('Read'))
    ->setDescription(t('A boolean indicating whether the Message is read.'))
    ->setDefaultValue(FALSE);

  $fields['status'] = BaseFieldDefinition::create('boolean')
    ->setLabel(t('Publishing status'))
    ->setDescription(t('A boolean indicating whether the Message is published.'))
    ->setDefaultValue(TRUE);

  $fields['created'] = BaseFieldDefinition::create('created')
    ->setLabel(t('Created'))
    ->setDescription(t('The time that the entity was created.'));

  $fields['changed'] = BaseFieldDefinition::create('changed')
    ->setLabel(t('Changed'))
    ->setDescription(t('The time that the entity was last edited.'));

  return $fields;
}
```

我们添加的字段包括：
- `user_to`：类型为 `entity_reference`，目标实体类型为 `user`。
- `subject`：类型为 `string`，限制为 100 个字符。
- `content`：类型为 `text_long`。
- `is_read`：布尔类型字段，指示消息是否已读。

注意：在为字段命名时要小心，特别是使用英文时。这些名称将成为基础表中的列名，如果使用 MySQL 保留字，生成的查询可能会出错。请参阅 MySQL 保留字列表：
[https://dev.mysql.com/doc/refman/5.7/en/keywords.html](https://dev.mysql.com/doc/refman/5.7/en/keywords.html)

更多关于字段定义的信息，请参阅：
[https://www.drupal.org/docs/drupal-apis/entity-api/defining-and-using-content-entity-field-definitions](https://www.drupal.org/docs/drupal-apis/entity-api/defining-and-using-content-entity-field-definitions)

#### PS ==关于字段设置==
```PHP
  $fields['user_id'] = BaseFieldDefinition::create('entity_reference')
    ->setLabel(t('Authored by'))
    ->setDescription(t('The user ID of author of the Message entity.'))
    ->setRevisionable(TRUE)
    ->setSetting('target_type', 'user')
    ->setSetting('handler', 'default')
    ->setTranslatable(TRUE)
    // setDisplayOptions 是不必要的，因为可以在页面中修改
    ->setDisplayOptions('view', [
      'label' => 'hidden',
      'type' => 'author',
      'weight' => 0,
    ])
    ->setDisplayOptions('form', [
      'type' => 'entity_reference_autocomplete',
      'weight' => 5,
      'settings' => [
        'match_operator' => 'CONTAINS',
        'size' => '60',
        'autocomplete_type' => 'tags',
        'placeholder' => '',
      ],
    ])
    ->setDisplayConfigurable('form', TRUE)
    ->setDisplayConfigurable('view', TRUE);
```
1.  ==setDisplayOptions== 是不必要的，因为可以在页面中修改
![[Pasted image 20240625145224.png]]

2. ==setDisplayOptions== 和 ==setDisplayConfigurable== 方法的第一个参数代表的含义：

==form== 代表的是实体的 `Manage format display` 的设置，`setDisplayOptions` 中的设置体现在管理员创建实体的页面，但可以在`Manage format display` 页面修改。可以修改的前提是 `setDisplayConfigurable` 方法的第二个参数设置为 `true`，如果设置为 `false`，该字段的将不会显示在`Manage format display` 页面.
![[Pasted image 20240625145518.png]]

==view== 代表的是实体的 `Manage display` 的设置，`setDisplayOptions` 中的设置体现在前端展示的页面，但可以在`Manage format display` 页面修改。可以修改的前提是 `setDisplayConfigurable` 方法的第二个参数设置为 `true`，如果设置为 `false`，该字段的将不会显示在`Manage display` 页面，同时前端页面也不会显示了。
![[Pasted image 20240625150006.png]]

### 路由和菜单链接的定义

我们已经讨论了两种可能的方法：静态路由和动态路由。这里我们再次使用 Drush Generate 生成的方法。

链接（links）通过注解（Annotation）在 `Message` 类中定义。路由提供者类在实体的处理程序中设置（也在注解中）：

```php
"route_provider" = {
  "html" = "Drupal\forcontu_entities\MessageHtmlRouteProvider",
}
```

查看由 Drush Generate 生成的文件 `src/MessageHtmlRouteProvider.php`。原则上我们不需要对该文件进行任何修改。如果我们想更改路由，可以在实体的注解定义中进行。

以下文件定义了与实体管理相关的菜单链接、操作链接和选项卡：
- `forcontu_entities.links.menu.yml`
- `forcontu_entities.links.task.yml`
- `forcontu_entities.links.action.yml`

### 实体控制类

现在我们需要定义允许管理 `Message` 类型实体的页面。回到实体注解定义中的 `handlers` 部分，查看需要创建的类。

我们从列出已创建实体的页面开始（`src/MessageListBuilder.php`）。在 `buildHeader()` 方法中定义表头，在 `buildRow()` 方法中构建每一行，指明每列的值。表单元素的名称必须与实体属性的名称一致。

此外，我们注入了 `date.formatter` 服务，用于处理日期格式。为此，我们创建了 `__construct()` 和 `createInstance` 方法。在注入额外服务之前，请复习命名规则和必需参数。这些必需参数由父类的构造函数决定。

在表中，我们添加了 `From`、`To`、`Subject`（重用 `Name`）和 `Created` 字段。要获取这些值，我们使用 `Message` 类中定义的方法。`label()` 方法是一个继承方法，返回实体的标签。在我们的例子中，该值对应于 `subject`，如注解定义中所述。

文件：`src/MessageListBuilder.php`

```php
<?php
namespace Drupal\forcontu_entities;

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityListBuilder;
use Drupal\Core\Routing\LinkGeneratorTrait;
use Drupal\Core\Url;
use Drupal\Core\Datetime\DateFormatterInterface;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Entity\EntityStorageInterface;

/**
 * Defines a class to build a listing of Message entities.
 *
 * @ingroup forcontu_entities
 */
class MessageListBuilder extends EntityListBuilder {
  use LinkGeneratorTrait;
  protected $dateFormatter;

  public function __construct(EntityTypeInterface $entity_type, EntityStorageInterface $storage, DateFormatterInterface $date_formatter) {
    parent::__construct($entity_type, $storage);
    $this->dateFormatter = $date_formatter;
  }

  /**
   * {@inheritdoc}
   */
  public static function createInstance(ContainerInterface $container, EntityTypeInterface $entity_type) {
    return new static(
      $entity_type,
      $container->get('entity_type.manager')->getStorage($entity_type->id()),
      $container->get('date.formatter')
    );
  }

  /**
   * {@inheritdoc}
   */
  public function buildHeader() {
    $header['id'] = $this->t('Message ID');
    $header['from'] = $this->t('From');
    $header['to'] = $this->t('To');
    $header['subject'] = $this->t('Subject');
    $header['created'] = $this->t('Created');

    return $header + parent::buildHeader();
  }

  /**
   * {@inheritdoc}
   */
  public function buildRow(EntityInterface $entity) {
    /* @var $entity \Drupal\forcontu_entities\Entity\Message */

    $row['id'] = $entity->id();
    $row['from'] = $entity->getOwner()->getAccountName();
    $row['to'] = $entity->getUserTo()->getAccountName();

    $row['subject'] = $this->l(
      $entity->label(),
      new Url(
        'entity.forcontu_entities_message.edit_form', [
          'forcontu_entities_message' => $entity->id(),
        ]
      )
    );
    $row['created'] = $this->dateFormatter->format($entity->getCreatedTime(), 'short');
    return $row + parent::buildRow($entity);
  }
}
```

`MessageForm` 表单（`src/Form/MessageForm.php`）用于创建和编辑 `Message` 类型实体。原则上我们不需要进行任何修改，但可以添加 `validateForm()` 方法以包含字段验证。

`MessageDeleteForm` 表单（`src/Form/MessageDeleteForm.php`）允许删除实体。我们不需要进行任何修改。

`MessageViewsData` 类（`src/Entity/MessageViewsData`）允许实体与视图集成。我们不需要进行任何修改。

### Bundles

为了创建 bundles 或消息类型，我们定义了配置实体 `MessageType`。由于这是一个配置实体，生成的文件与前一单元中研究的文件相同。原则上我们不需要修改这些文件：
- `src/Entity/MessageType.php`：`MessageType` 实体的主类。
- `src/Entity/MessageTypeInterface.php`：实体接口。
- `src/Form/MessageTypeForm.php`：创建/编辑消息类型的表单。
- `src/Form/MessageTypeDeleteForm.php`：删除消息类型的表单。
- `src/MessageTypeHtmlRouteProvider.php`：路由提供者。
- `src/MessageTypeListBuilder.php`：生成消息类型管理页面。
- `config/schema/forcontu_entities_message_type.schema`：配置架构。

### 权限

用于消息不同操作的权限在 `forcontu_entities.permissions.yml` 文件中声明：

```yaml
forcontu_entities.permissions.yml
add message entities:
  title: 'Create new Message entities'
administer message entities:
  title: 'Administer Message entities'
  description: 'Allow to access the administration form to configure Message entities.'
  restrict access: true
delete message entities:
  title: 'Delete Message entities'
edit message entities:
  title: 'Edit Message entities'
access message overview:
  title: 'Access the Message overview page'
view published message entities:
  title: 'View published Message entities'
view unpublished message entities:
  title: 'View unpublished Message entities'
```

在 `src/MessageAccessControlHandler.php` 文件中实现了使用这些权限的逻辑。除非我们想更改访问逻辑，否则不需要修改该文件。

### 主题

在实体实现中添加了以下模板：
- `templates/forcontu-entities-message-content-add-list.html.twig`：显示消息列表的模板。
- `templates/forcontu_entities_message.html.twig`：用于显示消息的模板。与此模板关联，在 `forcontu_entities_message.page.inc` 文件中实现了一个预处理函数，该函数将实体作为变量添加以进行表示。

模板在 `forcontu_entities.module` 文件中通过实现 `hook_theme` 定义。还根据 bundle、显示模式和实体 ID 添加了模板建议。

```php
<?php
/**
 * Implements hook_theme().
 */
function forcontu_entities_theme() {
  $theme = [];
  $theme['forcontu_entities_message'] = [
    'render element' => 'elements',
    'file' => 'forcontu_entities_message.page.inc',
    'template' => 'forcontu_entities_message',
  ];
  $theme['forcontu_entities_message_content_add_list'] = [
    'render element' => 'content',
    'variables' => ['content' => NULL],
    'file' => 'forcontu_entities_message.page.inc',
  ];
  return $theme;
}

/**
 * Implements hook_theme_suggestions_HOOK().
 */
function forcontu_entities_theme_suggestions_forcontu_entities_message(array $variables) {
  $suggestions = [];
  $entity = $variables['elements']['#forcontu_entities_message'];
  $sanitized_view_mode = strtr($variables['elements']['#view_mode'], '.', '_');
  $suggestions[] = 'forcontu_entities_message__' . $sanitized_view_mode;
  $suggestions[] = 'forcontu_entities_message__' . $entity->bundle();
  $suggestions[] = 'forcontu_entities_message__' . $entity->bundle() . '__' . $sanitized_view_mode;
  $suggestions[] = 'forcontu_entities_message__' . $entity->id();
  $suggestions[] = 'forcontu_entities_message__' . $entity->id() . '__' . $sanitized_view_mode;
}
```

### 注册新实体

如果像我们的情况一样，在完成新实体的实现之前模块已经安装，实体表将不会创建。

要注册新实体，可以运行以下 Drush 命令：

```sh
drush entity-updates
drush entup
```

该命令在安装模块后可用：
[https://www.drupal.org/project/devel_entity_updates](https://www.drupal.org/project/devel_entity_updates)

如果检测到实体配置更改，系统将更新它们：

```sh
$ drush entity-updates
The following updates are pending:
forcontu_entities_message entity type :
  El tipo de entidad Mensaje necesita ser instalado.
forcontu_entities_section entity type :
  El tipo de entidad Section necesita ser instalado.
forcontu_entities_message_type entity type :
  El tipo de entidad Message type necesita ser instalado.
Do you wish to run all pending updates? (y/n): y
Cache rebuild complete. [ok]
Finished performing updates. [ok]
```

每当我们进行配置更改且不确定是否影响数据库时，都可以使用此命令。

### 创建消息类型

在我们的实现中，没有定义任何默认的 bundle（或消息类型），因此在创建消息之前，我们需要创建一个类型。我们将其命名为 `Basic`，并从以下路径创建：

```
管理 -> 结构 -> Message Type
```

如图所示，每种消息类型将关联一组典型的内容实体选项（管理字段、管理表单显示和管理显示）。其功能与站点构建级别的功能相同。

### 创建消息

现在我们可以从以下路径创建新的 `Basic` 类型消息：

```
管理 -> 结构 -> Message List [Add Message]
```

创建的消息将显示在消息列表中，我们可以从中执行典型操作（查看、编辑和删除）。

### 基础表

数据存储在基础表中，因为所有字段都定义为基础字段。通过管理字段或编程添加到消息类型的附加字段将存储在附加表中。

### 与视图的集成

我们的实现与视图完全集成，无需添加额外代码。例如，我们实现了 `Mensajes recibidos` 视图，仅显示发送给当前用户的消息。除了与 `Message` 实体相关的权限外，用户还需要能够访问其他用户的个人资料。

创建视图时，我们可以将新实体类型 `Message` 添加为视图的主要元素。其余配置与站点构建级别的配置相同。

# 30.2 创建自定义内容类型

在 `Message` 实体的实现中，我们没有实现任何默认的 bundle 或类型。虽然在本节中我们将看到如何创建一个新的内容类型（节点实体的 bundle），但这适用于任何具有 bundle 的内容实体类型。

在 Drupal 10 中，新的 bundle 的实现是通过配置文件完成的。在模块安装期间，系统将根据这些配置生成新的 bundle。

在第 17.3 节中，我们已经看到配置架构文件用于描述模块配置文件的结构。一个模块可以有多个配置架构文件，尽管通常会创建一个文件来指定所有配置对象的结构。该文件将命名为 `module.schema.yml`，并位于模块的 `/config/schema` 文件夹中。

让我们看看用于创建新内容类型的配置文件及其相应的架构。这些文件位于 `/config/install` 文件夹中。

### 内容类型的声明

文件：`forcontu_entities/config/install/node.type.news.yml`

这是主要文件，用于声明内容类型及其默认配置。在以下示例中，我们创建了内容类型 `News`（新闻）。建议至少修改以下参数：

- `langcode`：如果我们使用西班牙语作为基础语言，可以将其更改为 `es`。
- `description`：添加内容类型的描述。

```yaml
langcode: en
status: true
dependencies:
  module:
    - menu_ui
  enforced:
    module:
      - forcontu_entities
third_party_settings:
  menu_ui:
    available_menus:
      - main
    parent: 'main:'
name: News
type: news
description: 'News content type'
help: ''
new_revision: false
preview_mode: 1
display_submitted: true
```

此配置文件中定义的参数来自文件 `/core/modules/node/config/schema/node.schema.yml`：

```yaml
node.type.*:
  type: config_entity
  label: 'Content type'
  mapping:
    name:
      type: label
      label: 'Name'
    type:
      type: string
      label: 'Machine-readable name'
    description:
      type: text
      label: 'Description'
    help:
      type: text
      label: 'Explanation or submission guidelines'
    new_revision:
      type: boolean
      label: 'Whether a new revision should be created by default'
    preview_mode:
      type: integer
      label: 'Preview before submitting'
    display_submitted:
      type: boolean
      label: 'Display setting for author and date Submitted by post information'
```

在上述架构文件中定义了内容实体的特定参数。此外，由于它是 `config_entity` 类型，我们还需要查找配置实体可用的参数。该架构可以在文件 `/core/config/schema/core.entity.schema.yml` 中找到：

```yaml
config_entity:
  type: mapping
  mapping:
    uuid:
      type: string
      label: 'UUID'
    langcode:
      type: string
      label: 'Language code'
    status:
      type: boolean
      label: 'Status'
    dependencies:
      type: config_dependencies
      label: 'Dependencies'
    third_party_settings:
      type: sequence
      label: 'Third party settings'
      sequence:
        type: '[%parent.%parent.%type].third_party.[%key]'
    _core:
      type: _core_config_info
```

在内容类型的定义中，我们发现了与 `menu_ui` 模块的依赖关系。在 `third_party_settings` 下，可以包含与这些声明为依赖项的模块相关的配置参数。

```yaml
dependencies:
  module:
    - menu_ui
third_party_settings:
  menu_ui:
    available_menus:
      - main
    parent: 'main:'
```

这些与 `menu_ui` 模块相关的参数在哪里定义？我们需要查看 `menu_ui` 模块的配置架构。在文件 `/core/modules/menu_ui/config/schema/menu_ui.schema.yml` 中，我们可以找到所需的架构：

```yaml
node.type.*.third_party.menu_ui:
  type: mapping
  label: 'Per-content type menu settings'
  mapping:
    available_menus:
      type: sequence
      label: 'Available menus'
      sequence:
        type: string
        label: 'Menu machine name'
    parent:
      type: string
      label: 'Parent'
```

### 内容类型的卸载

为了在卸载模块时强制卸载内容类型，可以添加与实现该内容类型的模块的强制依赖：

```yaml
dependencies:
  module:
    - menu_ui
  enforced:
    module:
      - forcontu_entities
```

### 额外字段

文件：`forcontu_entities/config/install/field.field.node.news.body.yml`

添加一个 `Body` 字段。通过这种方式添加的字段不是基础字段，可以通过界面进行配置（甚至删除）。因此，在内容类型中，`Body` 字段是可选的，而 `Title` 字段是必需的（`Title` 是基础字段）。

我们将为每个要添加到内容类型的额外字段创建一个独立的文件。

```yaml
langcode: en
status: true
dependencies:
  config:
    - field.storage.node.body
    - node.type.news
  module:
    - text
id: node.news.body
field_name: body
entity_type: node
bundle: news
label: Body
description: ''
required: false
translatable: true
default_value: { }
default_value_callback: ''
settings:
  display_summary: true
field_type: text_with_summary
```

字段的基本配置架构可以在文件 `/core/config/schema/core.data_types.schema.yml` 中找到：

```yaml
field_config_base:
  type: config_entity
  mapping:
    id:
      type: string
      label: 'ID'
    field_name:
      type: string
      label: 'Field name'
    entity_type:
      type: string
      label: 'Entity type'
    bundle:
      type: string
      label: 'Bundle'
    label:
      type: label
      label: 'Label'
    description:
      type: text
      label: 'Help text'
    required:
      type: boolean
      label: 'Required field'
    translatable:
      type: boolean
      label: 'Translatable'
    default_value:
      type: sequence
      label: 'Default values'
      sequence:
        type: field.value.[%parent.%parent.field_type]
        label: 'Default value'
    default_value_callback:
      type: string
      label: 'Default value callback'
    settings:
      type: field.field_settings.[%parent.field_type]
    field_type:
      type: string
      label: 'Field type'
```

由于这是一个 `text_with_summary` 类型的字段，我们需要在实现该字段的模块中查找其配置架构。在这种情况下，它是核心模块 `text`，架构可以在以下文件中找到：

```yaml
/core/modules/text/config/schema/text.schema.yml
```

第一个使用的架构是提供 `settings` 内属性的架构。我们需要找到指定的配置组：

```yaml
type: field.field_settings.[%parent.field_type]
```

因此，`text_with_summary` 的相应架构为：

```yaml
field.field_settings.text_with_summary:
  type: mapping
  label: 'Text (formatted, long, with summary) settings'
  mapping:
    display_summary:
      type: boolean
      label: 'Summary input'
```

通过这种方式浏览配置架构，我们可以找到所有可用的属性。

### 内容类型的展示

##### 文件：`forcontu_entities/config/install/core.entity_view_display.node.news.default.yml`

定义默认展示选项（管理展示），用于默认展示模式（default）：

```yaml
langcode: en
status: true
dependencies:
  config:
    - field.field.node.news.body
    - node.type.news
  module:
    - text
    - user
id: node.news.default
targetEntityType: node
bundle: news
mode: default
content:
  body:
    label: hidden
    type: text_default
    weight: 101
    settings: { }
    third_party_settings: { }
  links:
    weight: 100
hidden: { }
```

查看配置架构 `core.entity_view_display.*.*.*` 在 `/core/config/schema/core.entity.schema.yml` 中。

##### 文件：`forcontu_entities/config/install/core.entity_view_display.node.news.teaser.yml`

定义默认展示选项（管理展示），用于摘要展示模式（teaser）：

```yaml
langcode: en
status: true
dependencies:
  config:
    - core.entity_view_mode.node.teaser
    - field.field.node.news.body
    - node.type.news
  module:
    - text
    - user
id: node.news.teaser
targetEntityType: node
bundle: news
mode: teaser
content:
  body:
    label: hidden
    type: text_summary_or_trimmed
    weight: 101
    settings:
      trim_length: 600
    third_party_settings: { }
  links:
    weight: 100
hidden: { }
```

### 表单展示

##### 文件：`config/install/core.entity_form_display.node.news.default.yml`

定义内容类型创建/编辑表单的展示选项（管理表单展示）：

```yaml
langcode: en
status: true
dependencies:
  config:
    - field.field.node.news.body
    - node.type.news
  module:
    - path
    - text
id: node.news.default
targetEntityType: node
bundle: news
mode: default
content:
  body:
    type: text_textarea_with_summary
    weight: 31
    settings:
      rows: 9
      summary_rows: 3
      placeholder: ''
    third_party_settings: { }
  created:
    type: datetime_timestamp
    weight: 10
    settings: { }
    third_party_settings: { }
  path:
    type: path
    weight: 30
    settings: { }
    third_party_settings: { }
  promote:
    type: boolean_checkbox
    settings:
      display_label: true
    weight: 15
    third_party_settings: { }
  sticky:
    type: boolean_checkbox
    settings:
      display_label: true
    weight: 16
    third_party_settings: { }
  title:
    type: string_textfield
    weight: -5
    settings:
      size: 60
      placeholder: ''
    third_party_settings: { }
  uid:
    type: entity_reference_autocomplete
    weight: 5
    settings:
      match_operator: CONTAINS
      size: 60
      placeholder: ''
    third_party_settings: { }
hidden: { }
```

查看配置架构 `core.entity_form_display.*.*.*` 在 `/core/config/schema/core.entity.schema.yml` 中。

### 注册新的内容类型或 bundle

要注册新的内容类型，需要重新安装模块。请注意，这将丢失之前创建的相关内容。

### 核心参考

作为创建新内容类型的示例，建议查看核心的标准配置文件，其中定义了内容类型 `文章`（article）和 `基本页面`（page）。你可以在 `/core/profiles/standard/config/install` 中找到这些文件。例如，对于内容类型 `article`，请查看以下文件：
- `node.type.article.yml`
- `field.field.node.article.*.yml`
- `core.entity_form_display.node.article.default.yml`
- `core.entity_view_display.node.article.default.yml`

作为创建其他内容实体类型 bundle 的示例，也可以在标准配置文件中查看 `基本` 类型的定义，位于内容块（或自定义块）中。查看以下文件：
- `block_content.type.basic.yml`
- `field.field.block_content.basic.body.yml`
- `core.entity_form_display.block_content.basic.default.yml`
- `core.entity_view_display.block_content.basic.default.yml`

### 其他参考链接

编程将自定义字段添加到内容类型：
[https://www.drupal.org/docs/drupal-apis/entity-api/programming-custom-fields-into-your-content-type](https://www.drupal.org/docs/drupal-apis/entity-api/programming-custom-fields-into-your-content-type)

# 30.3 创建自定义字段类型

==字段类型是通过插件定义的==，需考虑以下元素：
- 字段类型的定义，创建一个扩展 `Drupal\Core\Field\FieldItemBase` 的 `@FieldType` 插件。
- 字段类型的配置架构。
- 一个或多个表单控件（widgets），用于指定在实体创建/编辑表单中该字段的控件。每个控件是一个 `@FieldWidget` 插件。
- 一个或多个格式化器（formatters），用于指定在展示实体时该字段的值的显示方式。每个格式化器是一个 `@FieldFormatter` 插件。
https://www.drupal.org/docs/drupal-apis/entity-api/fieldtypes-fieldwidgets-and-fieldformatters

==参考链接==：[https://www.drupal.org/docs/drupal-apis/entity-api/fieldtypes-fieldwidgets-and-fieldformatters](https://www.drupal.org/docs/drupal-apis/entity-api/fieldtypes-fieldwidgets-and-fieldformatters)

在我们的模块 `Forcontu Entities` 中，我们将定义字段类型 `Forcontu Color`（`forcontu_entities_color`），用于存储 RGB 十六进制格式的颜色。

#### @FieldType

字段类型通过 `@FieldType` 插件定义。它是一个扩展 `FieldItemBase` 的类，位于 `/src/Plugin/Field/FieldType` 目录中。如果一个模块实现了多个字段类型，每个类将位于独立的文件中，但都在同一个文件夹内。

参考链接：[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!FieldItemBase.php/class/FieldItemBase/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!FieldItemBase.php/class/FieldItemBase/10)

文件：`/forcontu_entities/src/Plugin/Field/FieldType/ColorItem.php`

```php
<?php
namespace Drupal\forcontu_entities\Plugin\Field\FieldType;

use Drupal\Core\Field\FieldItemBase;
use Drupal\Core\Field\FieldStorageDefinitionInterface;
use Drupal\Core\TypedData\DataDefinition;

/**
 * Plugin implementation of the 'forcontu_entities_color' field type.
 *
 * @FieldType(
 *   id = "forcontu_entities_color",
 *   label = @Translation("Forcontu Color"),
 *   module = "forcontu_entities",
 *   description = @Translation("Field to store an RGB color."),
 *   default_widget = "forcontu_entities_text",
 *   default_formatter = "forcontu_entities_simple_text"
 * )
 */
class ColorItem extends FieldItemBase {
  /**
   * {@inheritdoc}
   */
  public static function schema(FieldStorageDefinitionInterface $field_definition) {
    return [
      'columns' => [
        'value' => [
          'type' => 'text',
          'size' => 'tiny',
          'not null' => FALSE,
        ],
      ],
    ];
  }

  /**
   * {@inheritdoc}
   */
  public function isEmpty() {
    $value = $this->get('value')->getValue();
    return $value === NULL || $value === '';
  }

  /**
   * {@inheritdoc}
   */
  public static function propertyDefinitions(FieldStorageDefinitionInterface $field_definition) {
    $properties['value'] = DataDefinition::create('string')
      ->setLabel(t('Hex value'));
    return $properties;
  }
}
```

在插件注解（`@FieldType`）中定义了以下参数：
- `id`：字段类型的系统名称。通常添加模块名称作为前缀。
- `label`：字段的标签。在管理界面中显示的字段名称。
- `module`：实现字段类型的模块。
- `description`：描述性文本，仅在管理区域显示。
- `default_widget`：字段必须至少有一个控件。这里指定实现默认控件的插件的系统名称。
- `default_formatter`：字段必须至少有一个格式化器。这里指定实现默认格式化器的插件的系统名称。

#### FieldItemInterface::schema()

返回字段的架构，用于在数据库中创建表。唯一必须提供的值是表的列（columns）。可以选择添加唯一键、索引和外键。

参考链接：[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!FieldItemInterface.php/function/FieldItemInterface::schema/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!FieldItemInterface.php/function/FieldItemInterface::schema/10)

注意：计算字段可能不需要创建表，因为它们不需要存储字段值。在这种字段中，值在运行时计算或从其他来源获取，但不存储。在这些情况下，`schema()` 方法应返回一个空数组。

#### FieldItemInterface::propertyDefinitions()

此方法必须实现。返回字段属性的数组。

参考链接：[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!FieldItemInterface.php/function/FieldItemInterface::propertyDefinitions/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!FieldItemInterface.php/function/FieldItemInterface::propertyDefinitions/10)

#### TypedData::getConstraints()

Drupal 中的经典验证方法基于表单。然而，在 Drupal 8 中，实体和字段的验证已被独立的实体验证 API 替代，基于约束（constraints）。这样，实体的验证不依赖于通过表单创建或修改。我们将在第 30.5 节中进一步讨论此验证方法。

参考链接：[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!TypedData!TypedData.php/function/TypedData::getConstraints/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!TypedData!TypedData.php/function/TypedData::getConstraints/10)

#### 配置架构

在字段的配置架构中描述其属性。

文件：`/forcontu_entities/config/schema/forcontu_entities.schema.yml`

```yaml
field.forcontu_entities_color.value:
  type: sequence
  label: 'Default value'
  sequence:
    - type: mapping
      label: 'Default'
      mapping:
        value:
          type: string
          label: 'Value'
```

#### @FieldWidget

每个表单控件定义为一个 `@FieldWidget` 插件。它是一个扩展 `WidgetBase` 的类，位于 `/src/Plugin/Field/FieldWidget` 目录中。如果一个模块实现了多个控件，每个类将位于独立的文件中，但都在同一个文件夹内。

参考链接：[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!WidgetBase.php/class/WidgetBase/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!WidgetBase.php/class/WidgetBase/10)

文件：`/forcontu_entities/src/Plugin/Field/FieldWidget/TextWidget.php`

```php
<?php
namespace Drupal\forcontu_entities\Plugin\Field\FieldWidget;

use Drupal\Core\Field\FieldItemListInterface;
use Drupal\Core\Field\WidgetBase;
use Drupal\Core\Form\FormStateInterface;

/**
 * Plugin implementation of the 'forcontu_entities_text' widget.
 *
 * @FieldWidget(
 *   id = "forcontu_entities_text",
 *   module = "forcontu_entities",
 *   label = @Translation("RGB value as #ffffff"),
 *   field_types = {
 *     "forcontu_entities_color"
 *   }
 * )
 */
class TextWidget extends WidgetBase {
  /**
   * {@inheritdoc}
   */
  public function formElement(FieldItemListInterface $items, $delta, array $element, array &$form, FormStateInterface $form_state) {
    $value = isset($items[$delta]->value) ? $items[$delta]->value : '#ffffff';
    $element += [
      '#type' => 'textfield',
      '#default_value' => $value,
      '#size' => 7,
      '#maxlength' => 7,
    ];
    return ['value' => $element];
  }
}
```

在插件注解（`@FieldWidget`）中定义了以下参数：
- `id`：控件的系统名称。通常添加模块名称作为前缀。
- `label`：控件的标签，在管理界面的控件选择中显示。
- `module`：实现控件的模块。
- `field_types`：可以应用此控件的字段的系统名称（id）。

`formElement()` 方法返回用于填写字段的表单控件结构。在我们的示例中，默认控件是一个简单的文本字段，用于输入十六进制颜色值。字段的验证将在稍后添加。

一旦将字段添加到实体中，可以从“管理表单展示”中选择控件。

#### @FieldFormatter

每个字段格式化器定义为一个 `@FieldFormatter` 插件。它是一个扩展 `FormatterBase` 的类，位于 `/src/Plugin/Field/FieldFormatter` 目录中。如果一个模块实现了多个格式化器，每个类将位于独立的文件中，但都在同一个文件夹内。

参考链接：[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!FormatterBase.php/class/FormatterBase/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Field!FormatterBase.php/class/FormatterBase/10)

文件：`/forcontu_entities/src/Plugin/Field/FieldFormatter/SimpleTextFormatter.php`

```php
<?php
namespace Drupal\forcontu_entities\Plugin\Field\FieldFormatter;

use Drupal\Core\Field\FormatterBase;
use Drupal\Core\Field\FieldItemListInterface;

/**
 * Plugin implementation of the 'forcontu_entities_simple_text' formatter.
 *
 * @FieldFormatter(
 *   id = "forcontu_entities_simple_text",
 *   module = "forcontu_entities",
 *   label = @Translation("Simple text-based formatter"),
 *   field_types = {
 *     "forcontu_entities_color"
 *   }
 * )
 */
class SimpleTextFormatter extends FormatterBase {
  /**
   * {@inheritdoc}
   */
  public function viewElements(FieldItemListInterface $items, $langcode) {
    $elements = [];
    foreach ($items as $delta => $item) {
      $elements[$delta] = [
        // We create a render array to produce the desired markup,
        // "<p style="color: #hexcolor">The color code ...
        // #hexcolor</p>".
        // See theme_html_tag().
        '#type' => 'html_tag',
        '#tag' => 'p',
        '#attributes' => [
          'style' => 'color: ' . $item->value,
        ],
        '#value' => $this->t('The color code in this field is @code', ['@code' => $item->value]),
      ];
    }
    return $elements;
  }
}
```

==格式化器将在“管理展示”中为每个展示模式选择。==

在我们的示例中，格式化器是一个段落，显示一个指示颜色代码的文本。此外，段落添加了颜色作为样式，使文本显示为所选颜色。

```html
<p style="color: #09d209">The color code in this field is #09d209</p>
```

#### 额外配置

控件和格式化器可以有额外的配置，通过界面选择。一些与插件配置相关的方法包括：
- `settingsForm()`：用于请求配置值的表单。
- `defaultSettings()`：返回带有默认配置值的关联数组。
- `settingsSummary()`：显示当前配置值的信息摘要。
- `getSetting()`、`getSettings()`、`setSetting()`、`setSettings()`：用于获取和存储配置值的 get 和 set 方法。

作为示例，我们将为实现的 `SimpleTextFormatter` 添加配置。可以选择用来包裹文本的标签（`<p>`、`<div>` 或 `<span>`）。

```php
class SimpleTextFormatter extends FormatterBase {
  public function viewElements(FieldItemListInterface $items, $langcode) {
    $elements = [];
    foreach ($items as $delta => $item) {
      $elements[$delta] = [
        '#type' => 'html_tag',
        '#tag' => $this->getSetting('formatter_tag'),
        '#attributes' => [
          'style' => 'color: ' . $item->value,
        ],
        '#value' => $this->t('The color code in this field is @code', ['@code' => $item->value]),
      ];
    }
    return $elements;
  }

  public function settingsForm(array $form, FormStateInterface $form_state) {
    $output['formatter_tag'] = [
      '#title' => $this->t('HTML tag'),
      '#type' => 'select',
      '#options' => [
        'p' => $this->t('p'),
        'div' => $this->t('div'),
        'span' => $this->t('span'),
      ],
      '#default_value' => $this->getSetting('formatter_tag'),
    ];
    return $output;
  }

  public static function defaultSettings() {
    return [
      'formatter_tag' => 'p',
    ] + parent::defaultSettings();
  }

  public function settingsSummary() {
    $summary = [];
    $formatter_tag = $this->getSetting('formatter_tag');

    $summary[] = $this->t('HTML Tag: @tag', ['@tag' => $formatter_tag]);

    return $summary;
  }
}
```

不要忘记，除了与配置直接相关的方法外，还需要修改 `viewElements()` 方法以使用配置值（`getSetting()` 方法）。

在图 [F30.3d] 中显示了元素的配置摘要（`settingsSummary()`），以及访问配置表单的按钮 [F30.3e]。

现在生成的 HTML 将取决于格式化器的配置。

### ==Paragraph 模块很大程度上取代了自定义字段类型==
# 30.4 实体的主题化

在第 30.1 节中，我们介绍了如何创建与实体相关的模板。在本节中，我们将探讨一些与实体展示相关的钩子（hooks）。

#### `hook_entity_view()`

该钩子允许在任何类型的==实体渲染之前==对其展示进行操作。钩子接收 `$build` 作为参数（通过引用传递）。对这个可渲染数组的任何修改都会直接反映在实体的输出中。

```php
hook_entity_view(&$build, $entity, $display, $view_mode)
```

参考链接：[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Entity!entity.api.php/function/hook_entity_view/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Entity!entity.api.php/function/hook_entity_view/10)

例如，可以查看核心模块 `comment` 中 `hook_entity_view()` 的实现（`comment_entity_view`）。`comment` 模块检查实体是否在 RSS 模式下展示（`$view_mode == 'rss'`），以便在 RSS 中添加一个新的 `comments` 元素，该元素是指向实体评论的链接。

参考链接：[https://api.drupal.org/api/drupal/core!modules!comment!comment.module/function/comment_entity_view/10](https://api.drupal.org/api/drupal/core!modules!comment!comment.module/function/comment_entity_view/10)

#### `hook_ENTITY_TYPE_view()`

该钩子与 `hook_entity_view()` 功能相同，但作用于==特定类型的实体==。

```php
hook_ENTITY_TYPE_view(&$build, $entity, $display, $view_mode)
```

参考链接：[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Entity!entity.api.php/function/hook_ENTITY_TYPE_view/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Entity!entity.api.php/function/hook_ENTITY_TYPE_view/10)

#### `hook_entity_view_alter()`

该钩子允许在实体整体渲染之前对其进行操作。此钩子在 `hook_entity_view()` ==之后执行==，主要区别在于它拥有一个更完整的可渲染数组。

```php
hook_entity_view_alter(&$build, $entity, $display)
```

参考链接：[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Entity!entity.api.php/function/hook_entity_view_alter/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Entity!entity.api.php/function/hook_entity_view_alter/10)

#### `hook_ENTITY_TYPE_view_alter()`

该钩子类似于 `hook_entity_view_alter()`，但作用于==特定类型==的实体。

```php
hook_ENTITY_TYPE_view_alter(&$build, $entity, $display)
```

参考链接：[https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Entity!entity.api.php/function/hook_ENTITY_TYPE_view_alter/10](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Entity!entity.api.php/function/hook_ENTITY_TYPE_view_alter/10)

# 30.5 编程管理分类法

#### 创建词汇表

词汇表的创建通常通过位于 `/config/install` 目录中的配置文件完成。作为示例，我们可以分析标准安装配置文件中的 `taxonomy.vocabulary.tags.yml` 文件，该文件创建了与内容类型文章（article）关联的词汇表 Tags（tags）。

文件：`/config/install/taxonomy.vocabulary.nombre_vocabulario.yml`

```yaml
langcode: en
status: true
dependencies: { }
name: Tags
vid: tags
description: 'Use tags to group articles on similar topics into categories.'
hierarchy: 0
weight: 0
```

该配置文件的架构为 `taxonomy.vocabulary.*`，位于 `/core/modules/taxonomy/config/schema/taxonomy.schema.yml`。

虽然上述方法是常见的做法，但我们也可以在代码的其他地方使用 `Vocabulary` 类的 `create()` 和 `save()` 方法来创建词汇表。

参考链接：[https://api.drupal.org/api/drupal/core!modules!taxonomy!src!Entity!Vocabulary.php/class/Vocabulary/10](https://api.drupal.org/api/drupal/core!modules!taxonomy!src!Entity!Vocabulary.php/class/Vocabulary/10)

```php
use Drupal\taxonomy\Entity\Vocabulary;

// ...
Vocabulary::create([
  'vid' => 'tags',
  'name' => 'Tags',
])->save();
```

#### 创建术语

术语也是一种实体，可以使用 `Term` 类的 `create()` 和 `save()` 方法创建。

参考链接：[https://api.drupal.org/api/drupal/core!modules!taxonomy!src!Entity!Term.php/class/Term/10](https://api.drupal.org/api/drupal/core!modules!taxonomy!src!Entity!Term.php/class/Term/10)

例如，我们可以分析核心模块 `Forum` 的 `hook_install()` 实现，其中创建了与 `vid = 'forums'` 的词汇表关联的术语 'General discussion'：

```php
/**
 * Implements hook_install().
 */
function forum_install() {
  // ...
  // Create a default forum so forum posts can be created.
  $term = Term::create([
    'name' => t('General discussion'),
    'description' => '',
    'parent' => [0],
    'vid' => 'forums',
    'forum_container' => 0,
  ]);
  $term->save();
}
```

#### 引用分类法的字段

我们回到标准安装配置文件，分析如何创建分类法引用字段。这个过程分两步进行：

1. 为 Node 类型的实体创建字段：

文件：`core/profiles/standard/config/install/field.storage.node.field_tags.yml`

```yaml
langcode: en
status: true
dependencies:
  module:
    - node
    - taxonomy
id: node.field_tags
field_name: field_tags
entity_type: node
type: entity_reference
settings:
  target_type: taxonomy_term
module: core
locked: false
cardinality: -1
translatable: true
indexes: { }
persist_with_no_fields: false
custom_storage: false
```

2. 实例化上述字段，将其关联到内容类型文章（article）：

文件：`/core/profiles/standard/config/install/field.field.node.article.field_tags.yml`

```yaml
langcode: en
status: true
dependencies:
  config:
    - field.storage.node.field_tags
    - node.type.article
    - taxonomy.vocabulary.tags
id: node.article.field_tags
field_name: field_tags
entity_type: node
bundle: article
label: Tags
description: 'Enter a comma-separated list. For example: Amsterdam, Mexico City, "Cleveland, Ohio"'
required: false
translatable: true
default_value: { }
default_value_callback: ''
settings:
  handler: 'default:taxonomy_term'
  handler_settings:
    target_bundles:
      tags: tags
    sort:
      field: _none
    auto_create: true
field_type: entity_reference
```

#### 访问分类法字段

有多种方式可以访问分类法术语：

1. 通过术语的标识符（tid）加载术语实体。我们将访问 `taxonomy_term` 实体类型的存储。

```php
$term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
$term = $term_storage->load($tid);
```

2. 如果我们想加载多个已知的术语（tids），或者通过 `entityQuery` 获取它们的 tids：

```php
$query = \Drupal::entityQuery('taxonomy_term');
$query->accessCheck(TRUE)->condition('vid', "tags");
$tids = $query->execute();
$term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
$terms = $term_storage->loadMultiple($tids);
```

3. 获取术语引用字段的术语。在示例中，我们访问节点 `$node` 中 `field_tags` 字段的术语。

```php
foreach ($node->field_tags as $item) {
  $term = $item->entity;
  // $term->id()
  // $term->label()
}
```

4. 获取词汇表的术语树，考虑到术语可能是分层的：

```php
$term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
$tree = $term_storage->loadTree('tags');
```

# 30.6 实体和字段的验证

在 Drupal 10 中，实体的验证已从典型的表单验证中分离出来。这样，我们可以添加验证，无论实体是如何创建或修改的，因为表单并不是唯一的途径。

Drupal 的实体验证 API 使用 Symfony 的验证系统，基于约束（constraints）。Drupal 使用 Symfony 提供的约束，并添加了一些更具体的约束。我们可以使用现有的约束或创建新的约束。

参考链接：[Entity Validation API](https://www.drupal.org/docs/drupal-apis/entity-api/entity-validation-api/entity-validation-api-overview)

#### 约束（Constraints）

每个约束定义为一个由 `@Constraint` 标识的插件。验证类接收信息，检查其是否有效，并返回相应的错误消息。

核心添加的基本约束位于：
`/core/lib/Drupal/Core/Validation/Plugin/Validation/Constraint`

Symfony 的约束可以直接使用或扩展类进行修改。这些约束位于：
`/vendor/symfony/validator/Constraints/`

你还可以在核心模块和贡献模块中找到其他约束（搜索 `@Constraint` 以定位所有可用的约束）。

#### LengthConstraint

作为示例，我们分析 `Length` 约束，由 `LengthConstraint` 类管理，位于：

`/core/lib/Drupal/Core/Validation/Plugin/Validation/Constraint/LengthConstraint.php`

```php
<?php
namespace Drupal\Core\Validation\Plugin\Validation\Constraint;

use Symfony\Component\Validator\Constraints\Length;

/**
 * Length constraint.
 *
 * Overrides the symfony constraint to use Drupal-style replacement patterns.
 *
 * @Constraint(
 *   id = "Length",
 *   label = @Translation("Length", context = "Validation"),
 *   type = { "string" }
 * )
 */
class LengthConstraint extends Length {
  public $maxMessage = 'This value is too long. It should have %limit character or less.|This value is too long. It should have %limit characters or less.';
  public $minMessage = 'This value is too short. It should have %limit character or more.|This value is too short. It should have %limit characters or more.';
  public $exactMessage = 'This value should have exactly %limit character.|This value should have exactly %limit characters.';

  /**
   * {@inheritdoc}
   */
  public function validatedBy() {
    return '\Symfony\Component\Validator\Constraints\LengthValidator';
  }
}
```

这是一个对字符串长度的约束。可以指定字符串的最小（min）或最大（max）字符数（或两者）。

此类覆盖了 Symfony 的 `Length` 类，位于：
`/vendor/symfony/validator/Constraints/Length.php`

如 `validatedBy()` 方法所示，验证由 Symfony 的 `LengthValidator` 类执行：
`/vendor/symfony/validator/Constraints/LengthValidator.php`

约束可以应用于实体级别或字段级别。

#### 实体验证

实体级别的验证适用于涉及多个字段或需要检查超出单个字段值的复杂条件的情况。我们来看两个案例：

##### 案例 1：在模块中实现实体类型时

例如，`Comment` 模块添加了 `ContentName` 约束：

- 约束：`/core/modules/comment/src/Plugin/Validation/Constraint/CommentNameConstraint.php`
- 验证器：`/core/modules/comment/src/Plugin/Validation/Constraint/CommentNameConstraintValidator.php`

此约束在保存评论时进行多项检查：
- 如果评论由匿名用户发布，检查指定的名称是否与已注册用户名不一致。
- 如果管理员编辑评论，检查是否指定了有效的作者。
- 评论作者的名称必须与评论的作者一致。

在这些检查中使用的字段是 `name` 和 `uid`。在约束类中还定义了发生验证错误时返回的消息。这些消息可以包含参数。

```php
<?php
namespace Drupal\comment\Plugin\Validation\Constraint;

use Drupal\Core\Entity\Plugin\Validation\Constraint\CompositeConstraintBase;

/**
 * Supports validating comment author names.
 *
 * @Constraint(
 *   id = "CommentName",
 *   label = @Translation("Comment author name", context = "Validation"),
 *   type = "entity:comment"
 * )
 */
class CommentNameConstraint extends CompositeConstraintBase {
  /**
   * Message shown when an anonymous user comments using a registered name.
   *
   * @var string
   */
  public $messageNameTaken = 'The name you used (%name) belongs to a registered user.';
  //...
  public function coversFields() {
    return ['name', 'uid'];
  }
}
```

我们来看 `validate()` 方法的一个片段：

```php
<?php
class CommentNameConstraintValidator extends ConstraintValidator implements ContainerInjectionInterface {
  protected $context;

  public function validate($entity, Constraint $constraint) {
    $author_name = $entity->name->value;
    $owner_id = (int) $entity->uid->target_id;

    // Do not allow unauthenticated comment authors to use a name that is
    // taken by a registered user.
    if (isset($author_name) && $author_name !== '' && $owner_id === 0) {
      $users = $this->userStorage->loadByProperties(['name' => $author_name]);
      if (!empty($users)) {
        $this->context->buildViolation($constraint->messageNameTaken, ['%name' => $author_name])
          ->atPath('name')
          ->addViolation();
      }
    }
    // ...
  }
}
```

当不满足约束条件时，会生成一个违规。上下文（`$this->context`）收集在验证过程中生成的所有违规。

参考链接：[ExecutionContextInterface](https://api.drupal.org/api/drupal/vendor!symfony!validator!Context!ExecutionContextInterface.php/interface/ExecutionContextInterface/10)

对于每个违规（`buildViolation`），指定要显示的消息（在上例中为 `$constraint->messageNameTaken`）。还可以添加其他参数，如发生违规的属性或字段（`atPath`）。最后，将违规添加到上下文中（`addViolation`）。

参考链接：[ConstraintViolationBuilderInterface](https://api.drupal.org/api/drupal/vendor!symfony!validator!Violation!ConstraintViolationBuilderInterface.php/interface/ConstraintViolationBuilderInterface/10)

现在我们需要将 `Comment` 实体与定义的约束关联起来。我们将在定义实体的注解中进行此操作，文件位于：
`/core/modules/comment/src/Entity/Comment.php`

```php
/**
 * Defines the comment entity class.
 *
 * @ContentEntityType(
 *   id = "comment",
 *   ...
 *   constraints = {
 *     "CommentName" = {}
 *   }
 * )
 */
```

空的花括号表示约束不需要参数。这一定义足以在保存 `Comment` 实体（创建或编辑）时检查是否满足约束条件。

##### 案例 2：为其他模块的实体添加约束

要为其他模块的实体添加额外的约束，我们使用 `hook_entity_type_alter()`：

```php
hook_entity_type_alter(array &$entity_types)
```

参考链接：[hook_entity_type_alter](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Entity!entity.api.php/function/hook_entity_type_alter/10)

```php
/**
 * Implements hook_entity_type_alter().
 */
function forcontu_entities_entity_type_alter(array &$entity_types) {
  $node_definition = $entity_types['node'];
  $node_definition->addConstraint('ConstraintName', ['options']);
}
```

#### validate() 方法

我们已经提到，约束在保存实体时会被检查。我们也可以直接对实体进行检查，使用 `validate()` 方法，该方法返回检测到的违规列表。

```php
$violations = $entity->validate();
```
#### 字段验证

我们也可以在字段级别添加约束。当保存实体时，会检查每个字段的约束，并返回检测到的违规。

##### 案例 1：在我们的模块中定义字段类型

当我们定义一个字段类型插件时，可以直接在注解中包含约束。作为示例，我们来看 `file` 字段类型在 `file` 模块中的定义：

文件：`/core/modules/file/src/Plugin/Field/FieldType/FileItem.php`

```php
/**
 * Plugin implementation of the 'file' field type.
 *
 * @FieldType(
 *   id = "file",
 *   label = @Translation("File"),
 *   ...
 *   constraints = {"ReferenceAccess" = {}, "FileValidation" = {}}
 * )
 */
```

例如，我们可以查看 `FileValidation` 约束：

- 约束：`/core/modules/file/src/Plugin/Validation/Constraint/FileValidationConstraint.php`
- 验证器：`/core/modules/file/src/Plugin/Validation/Constraint/FileValidationConstraintValidator.php`

与字段类型关联的约束也可以在 `propertyDefinitions()` 方法中添加：

```php
class ListStringItem extends ListItemBase {
  public static function propertyDefinitions(FieldStorageDefinitionInterface $field_definition) {
    $properties['value'] = DataDefinition::create('string')
      ->setLabel(t('Text value'))
      ->addConstraint('Length', ['max' => 255])
      ->setRequired(TRUE);
    return $properties;
  }
}
```

##### TypedData::getConstraints()

`getConstraints()` 方法返回字段类型中定义的约束，但也可以用于定义额外的约束。

参考链接：[TypedData::getConstraints](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!TypedData!TypedData.php/function/TypedData::getConstraints/10)

例如，在 `telephone` 字段类型中，我们可以看到以下定义：

文件：`/core/modules/telephone/src/Plugin/Field/FieldType/TelephoneItem.php`

```php
public function getConstraints() {
  $constraint_manager = \Drupal::typedDataManager()->getValidationConstraintManager();
  $constraints = parent::getConstraints();
  $max_length = 256;
  $constraints[] = $constraint_manager->create('ComplexData', [
    'value' => [
      'Length' => [
        'max' => $max_length,
        'maxMessage' => t('%name: the telephone number may not be longer than @max characters.', ['%name' => $this->getFieldDefinition()->getLabel(), '@max' => $max_length]),
      ]
    ],
  ]);
  return $constraints;
}
```

##### 案例 2：在我们的模块中定义实体类型

在这种情况下，我们在模块中定义的不是字段类型，而是一个新的实体类型，并在其基础字段上应用约束。我们在 `baseFieldDefinitions()` 方法中添加约束，与每个字段的声明一起：

```php
public static function baseFieldDefinitions(EntityTypeInterface $entity_type) {
  $fields['mail'] = BaseFieldDefinition::create('email')
    ->setLabel(t('Email'))
    ->setDescription(t('The email of this user.'))
    ->setDefaultValue('')
    ->addConstraint('UserMailUnique')
    ->addConstraint('UserMailRequired')
    ->addConstraint('ProtectedUserField');

  $fields['age'] = BaseFieldDefinition::create('integer')
    ->setLabel(t('Age'))
    ->setDescription(t('The age of this user.'))
    ->setDefaultValue('')
    ->addPropertyConstraints('value', [
      'Range' => [
        'min' => 0,
        'max' => 17,
      ]
    ]);

  $fields['name'] = BaseFieldDefinition::create('string')
    ->setLabel(t('Name'))
    ->setPropertyConstraints('value', [
      'Length' => [
        'max' => 32,
      ]
    ]);

  return $fields;
}
```

`addConstraint()` ==方法用于添加没有参数的约束==（如 `UserMailUnique`、`UserMailRequired` 等）。

`addPropertyConstraints()` ==方法用于添加带参数的约束==，如 `Range` 或 `Length`。

##### 案例 3：为其他模块定义的字段添加约束

例如，如果我们想为节点的 `title` 字段添加约束，可以实现 `hook_entity_base_field_info_alter()`：

参考链接：[hook_entity_base_field_info_alter](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Entity!entity.api.php/function/hook_entity_base_field_info_alter/10)

```php
/**
 * Implements hook_entity_base_field_info_alter().
 */
function forcontu_entities_entity_base_field_info_alter(&$fields, \Drupal\Core\Entity\EntityTypeInterface $entity_type) {
  if ($entity_type->id() === 'node') {
    $title = $fields['title'];
    $title->addPropertyConstraints('value', [
      'Length' => [
        'min' => 10,
        'max' => 50,
      ]
    ]);
  }
}
```

##### validate() 方法

在字段级别，我们也可以使用 `validate()` 方法，指定要验证的字段名称：

```php
$violations = $entity->field_text->validate();
```

##### 更多信息

参考文章：[Drupal 8 Entity Validation and Typed Data Explained](https://www.sitepoint.com/drupal-8-entity-validation-and-typed-data-explained/)

## 对比
`TypedData::getConstraints()` 是 Drupal 中的数据验证机制的一部分，用于获取与特定数据类型相关联的约束（constraints）。这些约束定义了数据的验证规则，确保数据符合预期的格式和要求。

### `TypedData::getConstraints()` 的作用

`TypedData::getConstraints()` 方法返回一个约束数组，这些约束可以是内置的或自定义的。约束用于验证数据是否符合特定的规则，例如字符串长度、数值范围、日期格式等。

### 字段定义中的约束

在定义字段时，确实可以设置一些基本的约束，例如字符串字段的长度（`size`）或数值字段的最小和最大值。这些约束是通过字段类型和字段存储定义时的属性进行设置的。例如：

```php
$fields['example_field'] = BaseFieldDefinition::create('string')
  ->setLabel(t('Example Field'))
  ->setDescription(t('An example field with a length constraint.'))
  ->setSettings([
    'max_length' => 255,
  ])
  ->setRequired(TRUE);
```

在上述代码中，`max_length` 设置了字符串字段的最大长度。

### `TypedData::getConstraints()` 的优势

尽管==在字段定义时可以设置一些基本约束==，`TypedData::getConstraints()` 提供了一种更灵活和可扩展的方式来定义复杂的验证逻辑。使用 `TypedData::getConstraints()`，你可以：

1. **添加自定义验证逻辑**：除了基本的长度和范围约束，你还可以添加更复杂的验证规则。例如，确保某个字符串字段符合特定的正则表达式，或者确保某个数值字段是某个特定范围内的质数。

2. **复用验证规则**：通过使用 `TypedData::getConstraints()`，你可以在多个地方复用相同的验证规则，而不需要在每个字段定义中重复定义这些规则。

3. **动态验证**：在某些情况下，你可能需要根据上下文动态地应用不同的验证规则。`TypedData::getConstraints()` 允许你根据特定条件动态生成和应用验证规则。

### 示例

以下是如何使用 `TypedData::getConstraints()` 来添加自定义约束的示例：

```php
use Symfony\Component\Validator\Constraints\Length;
use Symfony\Component\Validator\Constraints\Regex;

$fields['example_field'] = BaseFieldDefinition::create('string')
  ->setLabel(t('Example Field'))
  ->setDescription(t('An example field with custom constraints.'))
  ->setSettings([
    'max_length' => 255,
  ])
  ->setRequired(TRUE)
  ->addConstraint('Length', ['max' => 255])
  ->addConstraint('Regex', ['pattern' => '/^[a-zA-Z0-9]+$/']);
```

在这个示例中，我们为 `example_field` 字段添加了两个约束：

1. **Length**：确保字符串的最大长度为 255。
2. **Regex**：确保字符串只包含字母和数字。

# 30.7 路由访问和实体操作

在第 17.2 节（实体作为参数）中，我们已经讨论了如何通过路由参数传递实体。例如，通过传递 `{user}`，可以直接创建一个用户对象。

==由于这些路由通常用于对实体进行操作==，因此访问控制通常通过添加 `_entity_access` 键来实现。

例如，在评论编辑表单中，我们检查用户是否具有 `update` 操作的权限（`comment.update`），在删除表单中，则检查 `delete` 操作的权限（`comment.delete`），始终在实体名称前加上前缀。

```yaml
entity.comment.edit_form:
  path: '/comment/{comment}/edit'
  defaults:
    _title: 'Edit'
    _entity_form: 'comment.default'
  requirements:
    _entity_access: 'comment.update'
  comment: \d+

entity.comment.delete_form:
  path: '/comment/{comment}/delete'
  defaults:
    _title: 'Delete'
    _entity_form: 'comment.delete'
  requirements:
    _entity_access: 'comment.delete'
  comment: \d+
```

在上述路由中，还添加了验证：

```yaml
comment: \d+
```

==这是基于正则表达式的附加验证==，检查参数值是否为一个或多个数字。

内部，`EntityAccessCheck::access()` 方法负责检查用户是否具有适当的权限。

参考链接：[EntityAccessCheck::access](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Entity!EntityAccessCheck.php/function/EntityAccessCheck::access/10)

同样，我们可以使用实体的 `access()` 方法来检查当前用户是否可以执行特定操作：

```php
if ($entity->access('delete')) {
  // 用户有删除权限
}

if ($entity->access('update')) {
  // 用户有更新权限
}
```

# 30.8 实体子类型的类（bundle class）

在 Drupal 中，可以为每个实体子类型（bundle）定义特定的类。这些类允许我们为不同的子类型添加特定的逻辑和方法，从而更好地组织和管理代码。

### 参考链接

- [使用特定内容类型的类](https://www.solucionex.com/blog/usar-clases-especificas-por-tipo-de-contenido-en-drupal)
- [Drupal 文档](https://www.drupal.org/node/3191609)

## 使用 Drush 生成 bundle class

我们可以使用 Drush 命令来生成实体子类型的类。命令如下：

```sh
drush gen entity:bundle-class
```


## 比较自定义捆绑类和钩子

==虽然钩子可以实现许多自定义逻辑，但自定义捆绑类也有其独特的优势：==

==将来弃用 HOOK 后就使用自定义 bundle class ？==

1. **面向对象的设计**：
   - 自定义捆绑类允许你使用面向对象的编程（OOP）方法来组织代码，这对于复杂逻辑和大型项目来说更加清晰和可维护。
   - 通过扩展实体类，你可以直接在类中定义方法和属性，这使得代码更具结构性和可读性。

2. **代码复用**：
   - 自定义捆绑类允许你在类中定义通用方法，这些方法可以在其他地方复用。
   - 通过继承和多态性，你可以创建更具弹性的代码结构。

3. **更好的封装**：
   - 自定义捆绑类可以将特定捆绑的逻辑封装在一起，减少全局钩子函数的复杂性和冲突。
   - 通过类的封装，你可以更好地控制数据和逻辑的访问权限。

### 示例对比

#### 使用钩子实现自定义字段处理逻辑

```php
/**
 * Implements hook_entity_presave().
 */
function mymodule_entity_presave(Drupal\Core\Entity\EntityInterface $entity) {
  if ($entity->getEntityTypeId() === 'node' && $entity->bundle() === 'article') {
    if (empty($entity->get('field_summary')->value)) {
      $entity->set('field_summary', substr($entity->get('body')->value, 0, 200));
    }
  }
}
```

#### 使用自定义捆绑类实现相同的逻辑

```php
namespace Drupal\your_module\Entity\Node;

use Drupal\node\Entity\Node;
use Drupal\Core\Entity\EntityStorageInterface;

/**
 * Defines the Article bundle class.
 */
class ArticleBundle extends Node {

  /**
   * {@inheritdoc}
   */
  public static function preSave(EntityStorageInterface $storage, array &$entities) {
    parent::preSave($storage, $entities);

    foreach ($entities as $entity) {
      if ($entity->bundle() === 'article' && empty($entity->get('field_summary')->value)) {
        $entity->set('field_summary', substr($entity->get('body')->value, 0, 200));
      }
    }
  }
}
```

### 使用场景

- **简单逻辑**：对于简单的自定义逻辑，钩子通常是更直接和简洁的选择。
- **复杂逻辑**：对于复杂的业务逻辑，尤其是涉及多个方法和属性的情况，自定义捆绑类提供了更好的代码组织和复用能力。
- **模块化设计**：如果你希望将特定捆绑的逻辑完全封装在一起，自定义捆绑类是更好的选择。

### 总结

钩子和自定义捆绑类各有其优缺点。钩子适用于简单和快速的自定义逻辑，而自定义捆绑类则适用于复杂的业务逻辑和面向对象编程的需求。根据具体的需求和项目规模，你可以选择最合适的实现方式。如果你有更多问题或需要进一步的帮助，请告诉我。
## 自定义捆绑类案例
### 案例 1：自定义字段处理逻辑

假设你有一个内容类型 `article`，并且你希望在保存节点时自动生成一个摘要字段的值。

#### 步骤：

1. **生成捆绑类**：

   使用 Drush 命令生成捆绑类：

   ```sh
   drush gen entity:bundle-class
   ```

   输入相关信息，例如实体类型 `node` 和捆绑名称 `article`。

2. **实现自定义逻辑**：

   编辑生成的 `ArticleBundle` 类，添加自定义的字段处理逻辑：

   ```php
   namespace Drupal\your_module\Entity\Node;

   use Drupal\node\Entity\Node;
   use Drupal\Core\Entity\EntityStorageInterface;

   /**
    * Defines the Article bundle class.
    */
   class ArticleBundle extends Node {

     /**
      * {@inheritdoc}
      */
     public static function preSave(EntityStorageInterface $storage, array &$entities) {
       parent::preSave($storage, $entities);

       foreach ($entities as $entity) {
         if ($entity->bundle() === 'article' && empty($entity->get('field_summary')->value)) {
           $entity->set('field_summary', substr($entity->get('body')->value, 0, 200));
         }
       }
     }
   }
   ```

   在这个示例中，`preSave` 方法被覆盖以在保存 `article` 节点之前自动生成 `field_summary` 字段的值。

### 案例 2：自定义验证规则

假设你希望在保存 `article` 节点时验证标题字段的长度，确保其长度在 10 到 100 个字符之间。

#### 步骤：

1. **生成捆绑类**：

   使用 Drush 命令生成捆绑类。

2. **实现自定义验证逻辑**：

   编辑生成的 `ArticleBundle` 类，添加自定义的验证规则：

   ```php
   namespace Drupal\your_module\Entity\Node;

   use Drupal\node\Entity\Node;
   use Symfony\Component\Validator\Constraints\Length;
   use Symfony\Component\Validator\Context\ExecutionContextInterface;

   /**
    * Defines the Article bundle class.
    */
   class ArticleBundle extends Node {

     /**
      * {@inheritdoc}
      */
     public function validate(ExecutionContextInterface $context) {
       parent::validate($context);

       $title = $this->get('title')->value;
       $lengthConstraint = new Length(['min' => 10, 'max' => 100]);

       $validator = \Drupal::service('validator');
       $violations = $validator->validate($title, $lengthConstraint);

       if (count($violations) > 0) {
         foreach ($violations as $violation) {
           $context->addViolation($violation->getMessage());
         }
       }
     }
   }
   ```

   在这个示例中，`validate` 方法被覆盖以添加自定义的长度验证规则。

### 案例 3：自定义访问控制

假设你希望根据用户角色限制对 `article` 节点的访问。

#### 步骤：

1. **生成捆绑类**：

   使用 Drush 命令生成捆绑类。

2. **实现自定义访问控制逻辑**：

   编辑生成的 `ArticleBundle` 类，添加自定义的访问控制逻辑：

   ```php
   namespace Drupal\your_module\Entity\Node;

   use Drupal\node\Entity\Node;
   use Drupal\Core\Session\AccountInterface;

   /**
    * Defines the Article bundle class.
    */
   class ArticleBundle extends Node {

     /**
      * {@inheritdoc}
      */
     public function access($operation, AccountInterface $account, $return_as_object = FALSE) {
       // Custom access logic for article bundle.
       if ($operation === 'view' && !$account->hasPermission('view article content')) {
         return $return_as_object ? AccessResult::forbidden() : FALSE;
       }

       return parent::access($operation, $account, $return_as_object);
     }
   }
   ```

   在这个示例中，`access` 方法被覆盖以添加自定义的访问控制逻辑。

# 