
正如我们在上一单元中提到的，从 Drupal 8 开始，路由和菜单的概念被分开了，不再使用 `hook_menu()`。
在本单元中，我们将学习如何创建路由和控制器来实现编程页面。
除了简单路由和带参数的路由，我们还将研究其他类以便从代码的任何部分生成路由。
我们还将学习如何创建菜单链接、选项卡和操作链接等，以及如何通过创建特定权限来保护路由的访问。
### 本单元内容
- 17.1 路由和控制器
- 17.2 带参数的路由
- 17.3 用于处理路由的类
- 17.4 菜单链接
- 17.5 选项卡（本地任务） `是不是使用Menu, 然后通过调整样式更好`
- 17.6 操作链接
- 17.7 路由访问控制
- 17.8 在控制器类中注入服务
- 17.9 动态路由
- 17.10 从控制台执行

## 17.1 路由和控制器

正如我们在上一单元中提到的，从 Drupal 8 开始，路由和菜单的概念被分开了，不再使用 `hook_menu()`。
==路由在配置文件（`模块.routing.yml`）中定义，页面内容通过控制器类中的方法返回。==
Drupal 10 的路由系统基于 Symfony 的路由系统。虽然我们这里的讲解足以理解 Drupal 的路由系统，但你可以通过查阅 Symfony 的路由组件来扩展这方面的知识：
[Symfony 路由文档](http://symfony.com/doc/current/book/routing.html)

你也可以查阅 Drupal 的官方文档来获取更多信息：
[Drupal 路由系统概述](https://www.drupal.org/docs/drupal-apis/routing-system/routing-system-overview)

### Forcontu Pages 模块
在本单元中，我们将创建一个名为 Forcontu Pages (`forcontu_pages`) 的新模块，在其中实现不同类型的路由、菜单项、选项卡等。请回顾第 17 单元以创建模块定义文件 `forcontu_pages.info.yml`。

### 路由
在 Drupal 10 中，我们区分页面的 URL 或物理路径（在浏览器中使用）和路由名称（在编程中引用的系统名称）。这种区分可以避免在需要更改页面物理 URL 时出现问题，因为内部的路由名称保持不变。

要定义页面的路由，我们需要创建一个路由文件，名为 `forcontu_pages.routing.yml`。该文件位于模块根目录，与 `.info.yml` 文件同级。在这个文件中，将定义我们模块中创建的所有页面路由。

```yaml
forcontu_pages.simple:
  path: '/forcontu/pages/simple'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::simple'
    _title: 'Simple Page'
  requirements:
    _permission: 'access content'
```

路由定义由以下属性组成：
- `forcontu_pages.simple`: 路由的系统名称（机器名称）。通常使用模块名称作为前缀（`forcontu_pages`）。
- `path`: 页面的物理路径。这是在浏览器中加载页面时使用的路径，例如：`http://www.example.com/path`。在我们的示例中，创建的页面将可通过 URL `http://www.example.com/forcontu/pages/simple` 访问。
- `defaults`: 路由的默认属性：
  - `_controller`: 指向控制器类和用于返回页面内容的方法。如果与 Drupal 7 比较，相当于我们在 `hook_menu` 中定义的回调函数（`page callback`）。
  - `_title`: 页面标题。
- `requirements`: 用户访问路由必须满足的条件：
  - `_permission`: 指定用户访问页面所需的权限。稍后我们将学习如何在模块中定义自定义权限。

路由可以有其他属性，我们将在需要时逐步介绍。你可以在以下链接查阅所有适用于路由的属性：
[Drupal 路由结构](https://www.drupal.org/docs/drupal-apis/routing-system/structure-of-routes)

在 `.routing.yml` 文件中定义的路由是==静态路由==，即从模块安装时就固定的路由。稍后我们将学习如何定义在运行时创建的==动态路由==。
### 控制器类

接下来，我们需要创建一个控制器类，用于返回页面内容。
为了创建我们模块的控制器，我们将扩展核心中可用的 `ControllerBase` 类。你可以在以下链接查看该类的方法：
[ControllerBase 类文档](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Controller!ControllerBase.php/class/ControllerBase/10)

我们将在以下文件中定义控制器：
`\forcontu_pages\src\Controller\ForcontuPagesController.php`
我们需要在模块文件夹中创建子文件夹结构（`\src\Controller\`）。

让我们回到路由文件（`forcontu_pages.routing.yml`）中分析控制器的定义：
```yaml
forcontu_pages.simple:
  path: '/forcontu/pages/simple'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::simple'
    _title: 'Simple Page'
  requirements:
    _permission: 'access content'
```

控制器名称的第一部分（`::` 之前）指的是控制器类的位置和名称（`class ForcontuPagesController`）。第二部分（`::` 之后，`simple`）指的是类中负责返回该特定页面内容的方法或函数。

==如果在一个模块中定义了多个页面，将有一个控制器负责所有页面，每个页面在控制器类中有自己对应的方法。在接下来的部分中，我们将定义新的路由并在控制器中创建额外的方法。==

`simple()` 方法返回一个包含页面内容的可渲染数组。我们将在后续单元中详细讨论可渲染数组。现在，我们只需了解 `#markup` 属性用于指定 HTML 输出。在我们的示例中，生成的页面 HTML 将是：`<p>This is a simple page (with no arguments)</p>`（或其相应的翻译）。

```php
<?php
namespace Drupal\forcontu_pages\Controller;

use Drupal\Core\Controller\ControllerBase;

/**
 * Contains \Drupal\forcontu_pages\Controller\ForcontuPagesController.
 */
class ForcontuPagesController extends ControllerBase {
  public function simple() {
    return [
      '#markup' => '<p>' . $this->t('This is a simple page (with no arguments)') . '</p>',
    ];
  }
}
```

你可以在 Drupal API 中阅读更多关于可渲染数组的信息：
[可渲染数组文档](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Render!theme.api.php/group/theme_render/10)

正如我们在第 17 单元中提到的，模块中打印的文本应通过 `t()` 函数处理，以便可以翻译。在控制器函数中，可以使用 `t()` 方法，因此我们将这样使用它：
```php
$this->t('text')
```

在定义控制器类的文件（`ForcontuPagesController.php`）中，我们首先声明命名空间（`namespace`），然后使用 `use` 操作符引用需要使用的类。在我们的例子中，我们的控制器扩展了 `ControllerBase` 类，因此需要包含它。

```php
<?php
/**
 * @file
 * Contains \Drupal\forcontu_pages\Controller\ForcontuPagesController.
 */
namespace Drupal\forcontu_pages\Controller;

use Drupal\Core\Controller\ControllerBase;
```

如果需要使用其他类，也需要使用 `use` 操作符引用它们。在第 17.3 节中，我们将看到一个示例，其中需要包含 `Url` 类以在页面内生成链接。
## 17.2 带参数的路由

要定义带参数的路由，只需为参数指定名称，并将其包含在路由中的大括号内。以下是一些示例：
- `/example/{user}`：定义了参数 `{user}`。一个有效的路由可能是 `/example/12`，其中 `12` 对应用户的内部 ID。
- `/example/{country}/{city}`：定义了参数 `{country}` 和 `{city}`。一个有效的路由可能是：`/example/spain/madrid`。
- `/example/{param1}/foo/{param2}/bar`：在这个示例中，参数也可以与 URL 的其他固定片段交错。

作为带参数路由的完整示例，我们将定义以下 URL：
`/forcontu/pages/calculator/{num1}/{num2}`

```yaml
forcontu_pages.calculator:
  path: '/forcontu/pages/calculator/{num1}/{num2}'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::calculator'
  requirements:
    _permission: 'access content'
```

在我们将添加到模块控制器中的 `calculator()` 方法中，我们将传递这两个参数：`calculator($num1, $num2)`。在这个页面上，我们将使用参数 `$num1` 和 `$num2` 进行一些数学运算。我们遵循的步骤如下（已在代码中注释）：

a) 检查提供的值是否为数字。如果任一参数不是数字，则==抛出带有错误消息的异常==。在这种情况下，我们使用 `BadRequestHttpException` 异常，这需要添加相应的组件：
```php
use Symfony\Component\HttpKernel\Exception\BadRequestHttpException;
```

b) 创建一个数组，其中我们将逐行添加要显示的内容。在每一行中显示一个运算结果。

c) 为避免除零错误，`$num2` 不能为 0。如果为 0，我们将不进行除法运算，并指示值未定义（undefined）。

d) 创建一个可渲染数组 `$output`，其中我们将要在页面上显示的元素添加进去。在我们的示例中，我们只添加了一个元素 `forcontu_pages_calculator`，它将使用==模板 `item_list` 将数组 `$list` 转换为 HTML 列表（`ul`）==。我们将在后续单元中详细讨论可渲染数组和模板。

e) 最后，返回可渲染数组 `$output`。

```php
<?php
/**
 * @file
 * Contains \Drupal\forcontu_pages\Controller\ForcontuPagesController.
 */
namespace Drupal\forcontu_pages\Controller;

use Drupal\Core\Controller\ControllerBase;
use Symfony\Component\HttpKernel\Exception\BadRequestHttpException;

/**
 * Controlador para devolver el contenido de las páginas definidas.
 */
class ForcontuPagesController extends ControllerBase {
  public function simple() {
    //...
  }

  public function calculator($num1, $num2) {
    // a) 检查提供的值是否为数字，如果不是，则抛出异常
    if (!is_numeric($num1) || !is_numeric($num2)) {
      throw new BadRequestHttpException(t('No numeric arguments specified.'));
    }

    // b) 结果将以 HTML 列表（ul）格式显示。每个列表项添加到一个数组中
    $list[] = $this->t('@num1 + @num2 = @sum', [
      '@num1' => $num1,
      '@num2' => $num2,
      '@sum' => $num1 + $num2
    ]);
    $list[] = $this->t('@num1 - @num2 = @difference', [
      '@num1' => $num1,
      '@num2' => $num2,
      '@difference' => $num1 - $num2
    ]);
    $list[] = $this->t('@num1 x @num2 = @product', [
      '@num1' => $num1,
      '@num2' => $num2,
      '@product' => $num1 * $num2
    ]);

    // c) 避免除零错误
    if ($num2 != 0) {
      $list[] = $this->t('@num1 / @num2 = @division', [
        '@num1' => $num1,
        '@num2' => $num2,
        '@division' => $num1 / $num2
      ]);
    } else {
      $list[] = $this->t('@num1 / @num2 = undefined (division by zero)', [
        '@num1' => $num1,
        '@num2' => $num2
      ]);
    }

    // d) 将数组 $list 转换为 HTML 列表（ul）
    $output['forcontu_pages_calculator'] = [
      '#theme' => 'item_list',
      '#items' => $list,
      '#title' => $this->t('Operations:')
    ];

    // e) 返回包含输出的可渲染数组
    return $output;
  }
}
```

根据通过 URL 传递的参数，页面输出如下：
- 路由：`/forcontu/pages/calculator/50/2`，在这种情况下，将进行所有运算。
- 路由：`/forcontu/pages/calculator/50/0`，由于 `$num2` 为 0，不进行除法运算以避免除零错误。
- 路由：`/forcontu/pages/calculator/50/foo`，由于 `$num2` 是非数字值，系统返回错误。此错误记录在事件日志中。

我们将在后续单元中详细讨论错误处理和异常。
### ==可选参数==

如果我们希望路由参数是可选的，我们需要为这些参数添加默认值。这些默认值在 `.routing.yml` 文件中的 `defaults` 部分中为==每个参数分配==。在下面的代码中，我们将 `$num1` 设置为 `20`，将 `$num2` 设置为 `10`。这些默认值仅在 URL 中未指定其他值时使用。

```yaml
forcontu_pages.calculator:
  path: '/forcontu/pages/calculator/{num1}/{num2}'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::calculator'
    num1: 20
    num2: 10
  requirements:
    _permission: 'access content'
```

根据通过 URL 传递的参数，页面输出如下：
- 路由：`/forcontu/pages/calculator/50`，只传递了第一个参数，因此 `$num2` 为 `10`（默认值）。
- 路由：`/forcontu/pages/calculator`，未传递任何参数，因此 `$num1` 为 `20`，`$num2` 为 `10`（默认值）。
### 实体作为参数

当我们希望将实体的 ID 作为参数传递时，Drupal 会简化操作，使实体在控制器方法中已加载并可用。

在下面的示例中，我们定义了一个带有 `{user}` 参数的新路由。

```yaml
forcontu_pages.user:
  path: '/forcontu/pages/user/{user}'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::user'
  requirements:
    _permission: 'access content'
```

==在控制器的方法中，我们指定参数 `$user` 是一个实现 `UserInterface` 的对象，该接口扩展了 `User` 类。==

如果传递的参数==不是有效的uid==，返回的响应是 ==404==。

```php
public function user(UserInterface $user) {
```

为了使用 `UserInterface`，我们需要通过 `use` 操作符将其包含进来：

```php
use Drupal\user\UserInterface;
```

完整的控制器代码如下：

```php
<?php
/**
 * @file
 * Contains \Drupal\forcontu_pages\Controller\ForcontuPagesController.
 */
namespace Drupal\forcontu_pages\Controller;

use Drupal\Core\Controller\ControllerBase;
use Symfony\Component\HttpKernel\Exception\BadRequestHttpException;
use Drupal\user\UserInterface;

/**
 * Controlador para devolver el contenido de las páginas definidas.
 */
class ForcontuPagesController extends ControllerBase {
  public function simple() {
    //...
  }

  public function calculator($num1, $num2) {
    //...
  }

  public function user(UserInterface $user) {
    // 可以直接使用 $user 对象
    $list[] = $this->t("Username: @username", ['@username' => $user->getAccountName()]);
    $list[] = $this->t("Email: @email", ['@email' => $user->getEmail()]);
    $list[] = $this->t("Roles: @roles", ['@roles' => implode(', ', $user->getRoles())]);
    $list[] = $this->t("Last accessed time: @lastaccess", [
      '@lastaccess' => \Drupal::service('date.formatter')->format($user->getLastAccessedTime(), 'short')
    ]);
    
    $output['forcontu_pages_user'] = [
      '#theme' => 'item_list',
      '#items' => $list,
      '#title' => $this->t('User data:'),
    ];
    
    return $output;
  }
}
```

在控制器方法中，我们将 `$user` 作为对象使用，尽管在路由中我们指定的是用户的 `uid`。可以查看以下链接，了解可以与 `$user` 对象一起使用的方法：
[UserInterface 方法](https://api.drupal.org/api/drupal/core!modules!user!src!UserInterface.php/10)

继续我们的示例，我们完成了控制器方法，显示通过 URL 传递的用户信息。具体地，我们展示以下用户字段：

- 用户名：`$user->getAccountName()`
- 电子邮件：`$user->getEmail()`
- 角色：`$user->getRoles()`。由于该方法返回==一个数组，我们使用 `implode()` 将其转换为以逗号（`,`）分隔的字符串。==
- 最后访问时间：`$user->getLastAccessedTime()`。==该方法返回时间戳。为了格式化时间，我们调用 `\Drupal::service('date.formatter')->format()`。==

```php
class ForcontuPagesController extends ControllerBase {
  public function simple() {
    //...
  }

  public function calculator($num1, $num2) {
    //...
  }

  public function user(UserInterface $user) {
    $list[] = $this->t("Username: @username", ['@username' => $user->getAccountName()]);
    $list[] = $this->t("Email: @email", ['@email' => $user->getEmail()]);
    $list[] = $this->t("Roles: @roles", ['@roles' => implode(', ', $user->getRoles())]);
    $list[] = $this->t("Last accessed time: @lastaccess", [
      '@lastaccess' => \Drupal::service('date.formatter')->format($user->getLastAccessedTime(), 'short')
    ]);

    $output['forcontu_pages_user'] = [
      '#theme' => 'item_list',
      '#items' => $list,
      '#title' => $this->t('User data:'),
    ];

    return $output;
  }
}
```

与我们传递用户实体参数的方式类似，我们也可以传递其他类型的实体。例如，我们可以传递一个节点，方法是实现 `NodeInterface` 接口。
[NodeInterface 方法](https://api.drupal.org/api/drupal/core!modules!node!src!NodeInterface.php/interface/NodeInterface/10)
#### PS：设置默认时区
###### 通过Drupal管理界面设置时区
1. **登录到Drupal管理界面**。
2. **导航到区域和语言设置**：
    - 点击顶部的 `配置`。
    - 在 `区域和语言` 部分下，点击 `日期和时间格式`。
3. **设置默认时区**：
    - 点击 `配置区域和语言` 页面中的 `地区设置`。
    - 在 `默认时区` 下拉菜单中，选择你想要的时区。
如果当前用户设置了自己的时区，显示给他的时间将是其对应时区的时间，否则将是 UTC（默认）时区的时间。
## 17.3 路由相关类

### Url 和 Link

`Url` 和 `Link` 类可以协同工作，在内容中生成链接。==`Url` 类定义了一个包含 URL 信息（如路由名称、内部或外部路径、相对或绝对路径等）的对象，而 `Link` 类则负责生成基于该 URL 的 HTML 链接（`<a href>`），并附加指定的属性。==

==Link 是通过 URL 创建的。==
```PHP
$url1 = Url::fromRoute('block.admin_display');
$link1 = Link::fromTextAndUrl($this->t('Go to the Block administration page'), $url1);
```

你可以在以下链接查看 `Url` 类的文档：
[Url 类文档](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Url.php/class/Url/10)

你可以在以下链接查看 `Link` 类的文档：
[Link 类文档](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Link.php/class/Link/10)

为了展示如何在内容中生成链接，我们将在 Forcontu Pages 模块中创建一个新页面，并定义一个包含不同类型链接的列表。

```yaml
forcontu_pages.links:
  path: '/forcontu/pages/links'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::links'
  requirements:
    _permission: 'access content'
```

#### 示例 1：指向内部 URL 的链接（`/admin/structure/blocks`）

第一个链接将指向一个内部路由，即块管理页面（`/admin/structure/blocks`）。为了指向该页面，我们不仅需要知道其物理 URL，还需要知道其在路由文件（`.routing.yml`）中定义的路由名称。由于这是一个与块相关的链接，我们将在核心模块 Block 的路由文件中查找该路由：

`/core/modules/block/block.routing.yml`

在该文件中，我们查找具有已知 URL 的路由（`path: '/admin/structure/block'`）：

```yaml
block.admin_display:
  path: '/admin/structure/block'
  defaults:
    _controller: '\Drupal\block\Controller\BlockListController::listing'
    _title: 'Block layout'
  requirements:
    _permission: 'administer blocks'
```

因此，我们需要引用的路由名称是：`block.admin_display`。

```php
//...
use Drupal\Core\Url;
use Drupal\Core\Link;

class ForcontuPagesController extends ControllerBase {
  public function simple() {
    //...
  }

  public function calculator($num1, $num2) {
    //...
  }

  public function user(UserInterface $user) {
    //...
  }

  public function links() {
    // 链接到 /admin/structure/blocks
    $url1 = Url::fromRoute('block.admin_display');
    $link1 = Link::fromTextAndUrl($this->t('Go to the Block administration page'), $url1);
    $list[] = $link1;

    $output['forcontu_pages_links'] = [
      '#theme' => 'item_list',
      '#items' => $list,
      '#title' => $this->t('Examples of links:'),
    ];

    return $output;
  }
}
```

首先，我们根据内部路由名称生成一个 `Url` 对象。然后，从 `Url` 对象生成一个包含链接的 `Link` 对象。`Link::fromTextAndUrl()` 方法允许我们指定链接文本，并从之前的 `Url` 对象生成 URL。

不要忘记在文件开头使用相应的 `use` 语句包含 `Url` 和 `Link` 类：

```php
//...
use Drupal\Core\Url;
use Drupal\Core\Link;
```

结果将是一个显示块管理页面链接的页面。如果我们查看生成的 HTML 源代码，可以看到如下生成的 HTML 代码：

```html
<a href="/admin/structure/block">Go to the Block administration page</a>
```

稍后我们将学习如何为链接添加额外的属性。
#### 示例 2：包含在文本中的链接

在上一个示例中，我们直接将 `$link1` 对象添加到 `list` 数组中，该数组随后被渲染为一个列表。当我们需要将链接包含在文本中时，需要使用 `toString()` 方法将其转换为字符串。在下面的示例中，我们将链接插入到一段文本中，并通过 `t()` 函数使其可翻译。

```php
$list[] = $this->t('This text contains a link to %link. Just convert it to String to use it into a text.', [
  '%link' => $link1->toString(),
]);
```

由于我们仍在使用示例 1 中生成的 `$link1` 链接，因此文本和 URL 将与示例 1 相同，但它们被包含在一段文本中。

结果将是一个显示块管理页面链接的页面。生成的 HTML 代码如下：

```html
This text contains a link to <a href="/admin/structure/block">Go to the Block administration page</a>. Just convert it to String to use it into a text.
```

#### 示例 3：链接到站点首页（`<front>`）

要生成指向站点首页的链接，只需使用 `<front>` 作为路由名称。

```php
// 链接到 <front>
$url3 = Url::fromRoute('<front>');
$link3 = Link::fromTextAndUrl($this->t('Go to Front page'), $url3);
$list[] = $link3;
```

生成的链接 `$link3` 可以直接在元素列表中使用，如示例 1，或包含在文本中，如示例 2。

完整的控制器代码如下：

```php
<?php
/**
 * @file
 * Contains \Drupal\forcontu_pages\Controller\ForcontuPagesController.
 */
namespace Drupal\forcontu_pages\Controller;

use Drupal\Core\Controller\ControllerBase;
use Symfony\Component\HttpKernel\Exception\BadRequestHttpException;
use Drupal\user\UserInterface;
use Drupal\Core\Url;
use Drupal\Core\Link;

/**
 * Controlador para devolver el contenido de las páginas definidas.
 */
class ForcontuPagesController extends ControllerBase {
  public function simple() {
    //...
  }

  public function calculator($num1, $num2) {
    //...
  }

  public function user(UserInterface $user) {
    //...
  }

  public function links() {
    // 链接到 /admin/structure/blocks
    $url1 = Url::fromRoute('block.admin_display');
    $link1 = Link::fromTextAndUrl($this->t('Go to the Block administration page'), $url1);
    $list[] = $link1;

    // 包含在文本中的链接
    $list[] = $this->t('This text contains a link to %link. Just convert it to String to use it into a text.', [
      '%link' => $link1->toString(),
    ]);

    // 链接到 <front>
    $url3 = Url::fromRoute('<front>');
    $link3 = Link::fromTextAndUrl($this->t('Go to Front page'), $url3);
    $list[] = $link3;

    $output['forcontu_pages_links'] = [
      '#theme' => 'item_list',
      '#items' => $list,
      '#title' => $this->t('Examples of links:'),
    ];

    return $output;
  }
}
```

在文件开头，不要忘记包含 `Url` 和 `Link` 类：

```php
use Drupal\Core\Url;
use Drupal\Core\Link;
```

这样，我们就可以在页面中显示不同类型的链接，包括指向块管理页面的链接、包含在文本中的链接以及指向站点首页的链接。
#### 示例 4：==链接到节点==（`/node/1`）

要链接到节点或任何其他实体，==Drupal 定义了一些特殊的路由，这些路由适用于所有实体==。例如，对于节点，可以使用以下路由：
- `'entity.node.canonical'`：对应节点的主页面，`/node/{node}`
- `'entity.node.edit_form'`：对应节点的编辑表单页面，`/node/{node}/edit`
- `'entity.node.delete_form'`：对应节点的删除页面，`/node/{node}/delete`

这些路由也适用于其他实体。例如，要访问用户页面，可以使用路由 `'entity.user.canonical'`。

因此，要链接到系统 URL 为 `/node/1` 的节点，我们使用路由 `'entity.node.canonical'`，并通过参数指定 `node` 的值。

```php
// 链接到 /node/1
$url4 = Url::fromRoute('entity.node.canonical', ['node' => 1]);
$link4 = Link::fromTextAndUrl($this->t('Link to node/1'), $url4);
$list[] = $link4;
```

==虽然==我们==使用节点的内部路由==来引用其路径，但系统将生成包含节点 ==URL 别名（如果有）==的链接：

```html
<a href="/about-us">Link to node/1</a>
```

#### 示例 5：链接到节点的编辑表单（`/node/1/edit`）

如示例 4 所述，要生成与实体相关的链接，我们需要使用一些特殊的路由。对于节点的编辑表单页面，我们使用路由 `'entity.node.edit_form'`，并通过参数指定 `node` 的值（要编辑的节点 ID）。

```php
// 链接到 /node/1/edit
$url5 = Url::fromRoute('entity.node.edit_form', ['node' => 1]);
$link5 = Link::fromTextAndUrl($this->t('Link to edit node/1'), $url5);
$list[] = $link5;
```

#### 示例 6：链接到外部 URL（`https://www.forcontu.com`）

==要生成指向站点外部 URL 的链接，我们使用 `Url` 类的 `fromUri()` 方法。==

```php
// 链接到 https://www.forcontu.com
$url6 = Url::fromUri('https://www.forcontu.com');
$link6 = Link::fromTextAndUrl($this->t('Link to www.forcontu.com'), $url6);
$list[] = $link6;
```

稍后我们将学习如何为链接添加属性，例如在新窗口中打开链接。

#### 示例 7：链接到未注册的内部 URL

上述方法也适用于引用未注册的内部路径（==即在路由文件中未定义的内部路径==）。例如，如果我们想链接到核心主题 Bartik 的 CSS 文件，可以这样做：

```php
// 链接到内部 CSS 文件
$url7 = Url::fromUri('internal:/core/themes/bartik/css/layout.css');
$link7 = Link::fromTextAndUrl($this->t('Link to layout.css'), $url7);
$list[] = $link7;
```

==我们使用了 `internal:` 前缀来指明这是一个内部路径==，后面是文件的相对路径。
#### 示例 8：==为链接添加属性==

HTML 链接可以具有额外的属性（如 `name`、`rel`、`target`、`class` 等）。在 Drupal 8 中，我们可以在 `Url` 对象上添加这些属性，`Link` 对象会使用它们来生成带有这些属性的链接。

```php
// 链接到 https://www.drupal.org 并添加额外的属性
$url8 = Url::fromUri('https://www.drupal.org');
$link_options = [
  'attributes' => [
    'class' => [
      'external-link',
      'list'
    ],
    'target' => '_blank',
    'title' => 'Go to drupal.org',
  ],
];
$url8->setOptions($link_options);
$link8 = Link::fromTextAndUrl($this->t('Link to drupal.org'), $url8);
$list[] = $link8;
```

在这个示例中，我们定义了一个包含属性的数组，然后==使用 `setOptions` 方法将这些属性添加到 `Url` 对象中==。具体地，我们添加了两个类名到 `class` 属性，使链接在新窗口中打开（`target="_blank"`），并添加了 `title` 属性。生成的 HTML 如下：

```html
<a href="https://www.drupal.org" class="external-link list" target="_blank" title="Go to drupal.org">Link to drupal.org</a>
```

### ==Route、RouteMatch 和 CurrentRouteMatch==

`Route` 对象包含在路由 YML 文件中为特定路由指定的信息。它通常不单独使用，而是作为 `RouteMatch` 对象中的一个组成部分。

`RouteMatch` 对象包含路由名称、`Route` 对象（类型为 `Route`）以及用于生成特定路由的==参数==。

`CurrentRouteMatch` 是一个 `RouteMatch` 对象，但它包含当前路由的信息。

#### `RouteMatch` 的使用示例

我们可以在 `hook_help()` 的实现中看到 `RouteMatch` 的使用示例：
[hook_help()](https://api.drupal.org/api/drupal/core!modules!help!help.api.php/function/hook_help/10)

```php
hook_help($route_name, \Drupal\Core\Routing\RouteMatchInterface $route_match)
```

`hook_help()` 函数接收两个参数：路由名称 `$route_name` 和包含更多路由信息的 `RouteMatch` 对象（`RouteMatchInterface`），即 `$route_match`。==该对象包含 `Route` 对象和路由参数==。

通常，在 `hook_help()` 的实现中，检查路由名称（`$route_name`）即可在该页面上编写帮助信息。如果我们想根据路由的其他参数编写帮助信息，需要在 `$route_match` 对象中查询这些参数。下面是一个示例。

在我们的 Forcontu Pages 模块中，我们将实现 `hook_help`。我们将在 `forcontu_pages.module` 文件中实现它。

我们将在节点编辑页面上显示两个文本（Text A 和 Text B）。节点编辑页面的路由名称为 `entity.node.edit_form`。

- Text A 将显示在所有节点编辑页面上。
- Text B 仅在编辑类型为 "page"（基本页面）的节点时显示。

```php
<?php
/**
 * @file
 * Forcontu Pages module file.
 */
use Drupal\Core\Routing\RouteMatchInterface;

/**
 * Implements hook_help().
 */
function forcontu_pages_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'entity.node.edit_form':
      $node = $route_match->getParameter('node');
      $output = '';
      $output .= '<p>' . t('Text A. This text is shown in every node edit form. Current node is of type %type and its id is %id', [
        '%type' => $node->getType(),
        '%id' => $node->id()
      ]) . '</p>';
      if ($node->getType() == 'page') {
        $output .= '<p>' . t('Text B. This text is shown only in Basic pages nodes.') . '</p>';
      }
      return $output;
  }
}
```

首先，我们检查 `$route_name` 的值是否与我们的路由名称（`entity.node.edit_form`）匹配。

```php
switch ($route_name) {
  case 'entity.node.edit_form':
```

在两个文本中，我们都需要获取正在编辑的节点的附加值，因此下一步是加载节点。节点将作为 `$route_match` 对象的参数可用。我们需要使用 `getParameter()` 方法来获取指定的参数。

```php
$node = $route_match->getParameter('node');
```

现在我们有了一个 `$node` ==对象==，可以使用其相应的方法和属性：
[Node 类](https://api.drupal.org/api/drupal/core!modules!node!src!Entity!Node.php/class/Node/10)

例如，要获取节点类型，我们调用 `$node->getType()`；要获取节点 ID，我们调用 `$node->id()`。

在 Text A 中，我们将这些值用作文本中的变量（在 `t()` 函数中作为替换变量）。

```php
$output .= '<p>' . t('Text A. This text is shown in every node edit form. Current node is of type %type and its id is %id', [
  '%type' => $node->getType(),
  '%id' => $node->id()
]) . '</p>';
```

要显示 Text B，我们首先检查内容类型是否为 "page"，并且仅在满足条件时显示。

```php
if ($node->getType() == 'page') {
  $output .= '<p>' . t('Text B. This text is shown only in Basic pages nodes.') . '</p>';
}
```

当编辑类型为 "文章" 的内容时，仅显示 Text A。当编辑类型为 "基本页面" 的内容时，同时显示 Text A 和 Text B。
## 17.4 菜单链接

如前所述，页面路由的定义与菜单链接的定义已经分离。在本节及后续章节中，我们将学习如何添加菜单链接及其他相关元素，如标签和操作链接。

有关 Drupal 菜单系统的更多信息，请参见以下链接：
[Drupal 10 的菜单 API](https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Menu!menu.api.php/group/menu/10)

### 菜单链接

菜单链接==作为配置==定义在专门创建的 YML 文件中。定义菜单元素的==文件结构为== `模块名.links.menu.yml`。

在 Forcontu Hello 模块中，我们已经添加了一个菜单链接，创建了 `forcontu_hello.links.menu.yml` 文件，内容如下：

```yaml
forcontu_hello.hello:
  title: Hello Page
  description: 'Hello Page menu link'
  route_name: forcontu_hello.hello
  menu_name: main
  weight: 1
```

菜单元素的定义包含以下部分：

- `forcontu_hello.hello`：这是菜单元素的系统名称（machine name）。虽然与 `forcontu_hello.routing.yml` 中定义的路由系统名称相同，但不一定必须相同。
- `title`：菜单元素的标题。它是==显示==在菜单中的文本。
- `description`：菜单元素的描述。它是在鼠标==悬停==在链接上时显示的文本，对应 HTML 链接的 `title` 属性（`<a href="/forcontu/hello" title="Hello Page menu link">`）。
- `route_name`：路由的系统名称，如在 `routing.yml` 文件中定义的那样。
- `menu_name`：显示菜单元素的菜单名称。在我们的模块中，`main` 是主菜单的系统名称。如果省略菜单名称，则默认使用工具菜单（Tools）。
- `weight`：菜单元素的权重。用于与其他菜单元素的排序。

在接下来的示例中，我们将看到菜单元素定义中可以使用的其他属性。
### 管理菜单中的==链接==
![[Pasted image 20240619091827.png]]
在继续之前，我们将在==管理菜单中创建一个顶级链接==，与主要选项（内容、结构、外观等）并列。我们将使用这个新部分来链接在课程中进行的各种活动。

管理页面如结构和报告，是列出其包含的菜单项的特殊页面。一些二级选项，如配置中的类别（系统、用户、开发等），也具有这种行为。

由于我们希望新的 Forcontu 菜单部分具有这种功能，我们将查看系统定义的路由文件（`system.routing.yml`），以了解使用了哪种控制器：
[system.routing.yml](https://api.drupal.org/api/drupal/core!modules!system!system.routing.yml/10)

在 `system.routing.yml` 文件的代码片段中，我们可以看到如何定义 `/admin`、`/admin/structure` 和 `/admin/reports` 的管理路由。

```yaml
system.admin:
  path: '/admin'
  defaults:
    _controller: '\Drupal\system\Controller\SystemController::systemAdminMenuBlockPage'
    _title: 'Administration'
  requirements:
    _permission: 'access administration pages'

system.admin_structure:
  path: '/admin/structure'
  defaults:
    _controller: '\Drupal\system\Controller\SystemController::systemAdminMenuBlockPage'
    _title: 'Structure'
  requirements:
    _permission: 'access administration pages'

system.admin_reports:
  path: '/admin/reports'
  defaults:
    _controller: '\Drupal\system\Controller\SystemController::systemAdminMenuBlockPage'
    _title: 'Reports'
  requirements:
    _permission: 'access site reports'
```

所有这些路由都以相同的方式工作，显示其子菜单选项的列表。它们共同使用同一个控制器来创建页面内容：
`\Drupal\system\Controller\SystemController::systemAdminMenuBlockPage`

虽然我们不需要了解控制器的内部代码即可使用它，但查看 API 中的代码总是有帮助的：
[SystemController::systemAdminMenuBlockPage](https://api.drupal.org/api/drupal/core!modules!system!src!Controller!SystemController.php/function/SystemController%3A%3AsystemAdminMenuBlockPage/10)

这些元素的另一个共同点是管理元素的 URL 嵌套在 `/admin` 下。虽然定义嵌套 URL 不是强制性的，但我们将遵循这种格式。
#### Forcontu 菜单元素

以此为例，我们将在 Forcontu Pages 模块中添加 URL `/admin/forcontu`，作为一级菜单选项 Forcontu 的内容。由于我们正在创建路由，因此将其添加到模块的路由文件 `forcontu_pages.routing.yml` 中。
==PS：注意controller==
```yaml
forcontu_pages.admin_forcontu:
  path: '/admin/forcontu'
  defaults:
    _controller: '\Drupal\system\Controller\SystemController::systemAdminMenuBlockPage'
    _title: 'Forcontu'
  requirements:
    _access: 'TRUE'
```

这样我们就创建了页面。菜单元素将在 `forcontu_pages.links.menu.yml` 文件中创建：

```yaml
forcontu_pages.admin_forcontu:
  title: 'Forcontu'
  parent: system.admin
  route_name: forcontu_pages.admin_forcontu
  description: 'Links to pages created during this course'
  weight: -11
```

在此链接的定义中，我们使用了一个新属性 `parent`，用于指定==父菜单元素==。请注意，`system.admin` 是指菜单元素，如系统菜单链接文件中所示（而不是路由文件中的路径）。可以在以下链接中查看 `system.links.menu.yml` 文件的源代码：
[system.links.menu.yml](https://api.drupal.org/api/drupal/core!modules!system!system.links.menu.yml/10)

当我们的模块需要添加另一个模块创建的元素的子元素时，需要查看该模块的菜单链接文件。在 `parent` 属性中使用菜单元素的系统名称。

在我们的示例中，我们使用了权重（`weight`）-11，以便该元素位于“内容”之前，并位于 Admin Toolbar 模块（Admin Toolbar Extra Tools）添加的 Drupal 图标之后，如图所示。
##### ==PS：==添加这个 route 和 menu 是没有具体页面显示的，需要添加具体页面才行，直接访问：
![[Pasted image 20240619103033.png]]
#### Forcontu Pages 菜单元素

接下来，我们将在 Forcontu 中==添加一个子选项==，用于汇集为 Forcontu Pages 模块创建的链接。在后续章节中，我们将继续为实现的模块添加链接。

在 `forcontu_pages.routing.yml` 文件中，我们创建一个页面，使用==相同类型的控制器==，==自动生成==包含其子选项链接的页面。

```yaml
forcontu_pages.admin_forcontu_pages:
  path: '/admin/forcontu/forcontu_pages'
  defaults:
    _controller: '\Drupal\system\Controller\SystemController::systemAdminMenuBlockPage'
    _title: 'Forcontu Pages'
  requirements:
    _access: 'TRUE'
```

在 `forcontu_pages.links.menu.yml` 文件中添加新的菜单元素：

```yaml
forcontu_pages.admin_forcontu_pages:
  title: 'Forcontu Pages'
  parent: forcontu_pages.admin_forcontu
  route_name: forcontu_pages.admin_forcontu_pages
  description: 'Activities from Forcontu Pages module'
```

请注意，作为父元素（`parent`），我们引用了之前创建的 `/admin/forcontu` 页面菜单元素。
##### ==PS：==添加这个 route 和 menu 是没有具体页面显示的，需要添加具体页面才行，直接访问：
![[Pasted image 20240619103220.png]]
#### 为菜单元素添加图标

管理菜单的顶级选项有一个通过 CSS 添加的图标。图标和用于管理选项的 CSS 已被纳入核心的基础主题 stable。也可以在以下链接中查看使用的 CSS：
[toolbar.icons.theme.css](https://api.drupal.org/api/drupal/core!modules!toolbar!css!toolbar.icons.theme.css/10)

我们可以选择将菜单选项的图标和 CSS 添加到站点的主题或创建元素的模块中。为了使其独立于主题，我们将通过 Forcontu Pages 模块来实现，步骤如下：

##### 创建 CSS 文件

在 `forcontu_pages` 模块中创建一个 CSS 文件，名称和文件夹结构如下：

```
/forcontu_pages/css/forcontu_pages.css
```

文件内容如下：
```css
.toolbar-icon-forcontu-pages-admin-forcontu:before,
.toolbar-icon-forcontu-pages-admin-forcontu:active:before,
.toolbar-icon-forcontu-pages-admin-forcontu.is-active:before {
  background-image: url(images/forcontu-icon.svg);
}
```
我们使用的==类名是系统根据菜单链接的系统名称生成==的。可以通过检查菜单元素生成的源代码来验证。
![[Pasted image 20240619095541.png]]
##### 上传图标

可以从以下链接下载图标 `forcontu-icon.svg`：
[forcontu-icon.svg](https://www.forcontu.com/sites/default/files/forcontu-icon.svg)

将文件上传到以下文件夹：

```
/forcontu_pages/css/images/forcontu-icon.svg
```

##### 创建库

CSS（或 JS）文件通过定义库来添加。对于我们的模块，需要在根目录下定义库文件 `forcontu_pages.libraries.yml`，并定义名为 `forcontu_pages.css` 的库，如下所示：

```yaml
forcontu_pages.css:
  version: 1.x
  css:
    theme:
      css/forcontu_pages.css: {}
```
###### PS：==css/forcontu_pages.css==就是文件路径，从模块根目录开始找
![[Pasted image 20240619101203.png]]
和 `src` 同级：
![[Pasted image 20240619101358.png]]
#### 加载库

最后，为了将库作为==工具栏的附件加载==，我们将实现 `hook_toolbar_alter()` 函数：
[hook_toolbar_alter()](https://api.drupal.org/api/drupal/core!modules!toolbar!toolbar.api.php/function/hook_toolbar_alter/10)

实现将在 `.module` 文件中进行。对于我们的情况，将在 `forcontu_pages.module` 文件中实现，放在之前可能已经实现的其他函数之后：

```php
<?php
//...
/**
 * Implements hook_toolbar_alter().
 */
function forcontu_pages_toolbar_alter(&$items) {
  $items['administration']['#attached']['library'][] = 'forcontu_pages/forcontu_pages.css';
}
```

注意，我们引用库时使用的是模块名和库名（`'forcontu_pages/forcontu_pages.css'`），而不是直接引用文件路径。这使我们能够对库进行更改而不影响使用它们的代码。

虽然我们将在后续章节中学习更多关于库的内容，但可以==在以下链接中查阅更多信息==：
[添加样式表（CSS）和 JavaScript（JS）到 Drupal 模块](https://www.drupal.org/docs/creating-custom-modules/adding-stylesheets-css-and-javascript-js-to-a-drupal-module)

### 无参数的菜单链接

我们已经了解了如何将菜单链接添加到直接或简单的路由中，无参数。接下来，我们将在模块的菜单链接 `forcontu_pages.admin_forcontu_pages`（作为 `parent` 的值）中添加链接到之前创建的页面 `forcontu_pages.simple` 和 `forcontu_pages.links`（作为 `route_name` 的值）。由于页面已经创建，我们只需在 `forcontu_pages.links.menu.yml` 文件中定义链接：

```yaml
forcontu_pages.simple:
  title: 'Simple page'
  description: 'Simple page'
  route_name: forcontu_pages.simple
  parent: forcontu_pages.admin_forcontu_pages
  weight: 1

forcontu_pages.links:
  title: 'Links'
  description: 'Links'
  route_name: forcontu_pages.links
  parent: forcontu_pages.admin_forcontu_pages
  weight: 2
```

根据目前的定义，我们应该已经有了这样的菜单结构 。记得在每次对模块进行更改后清空缓存。你还需要通过界面翻译来翻译链接的标题。
##### ==PS：添加具体链接后就可以正常访问了==
![[Pasted image 20240619103446.png]]
![[Pasted image 20240619103637.png]]
### 带参数的菜单链接

我们已经了解了如何创建带参数的页面。例如，我们之前定义了接受参数 `num1` 和 `num2` 的路由 `forcontu_pages.calculator`：

URL: `/forcontu/pages/calculator/{num1}/{num2}`

如果我们想将此路由添加为==菜单链接==，==必须传递==一些特定的参数。

回到 `forcontu_pages.links.menu.yml` 文件，我们创建一个加载带有这些参数的计算器页面的链接：

```yaml
forcontu_pages.calculator:
  title: 'Calculator'
  description: 'Calculator'
  route_name: forcontu_pages.calculator
  route_parameters:
    num1: 14
    num2: 7
  parent: forcontu_pages.admin_forcontu_pages
  weight: 3
```

与创建简单页面链接的==唯一区别==是，我们==必须添加== `route_parameters` ==属性==，指明每个参数的值。参数名称来自于 `routing.yml` 文件中的路由定义。

同样，如果我们想添加一个链接到之前创建的页面 `forcontu_pages.user`，传递用户 ID 为 1 的参数（`/forcontu/pages/user/1`），可以这样做：

```yaml
forcontu_pages.user:
  title: 'User page'
  description: 'User page'
  route_name: forcontu_pages.user
  route_parameters:
    user: 1
  parent: forcontu_pages.admin_forcontu_pages
  weight: 4
```

这样，我们就可以为带参数的页面创建菜单链接。
## 17.5 标签页（本地任务）(local tasks)
**[参考链接](https://www.drupal.org/docs/drupal-apis/menu-api/providing-module-defined-local-tasks)**
可以创建页面组，并以标签页（tabs）的形式进行分组，在 Drupal 中称为本地任务（local tasks）。

在 Drupal 的管理区域中，我们可以看到许多这种标签页分组的示例。例如，站点中任何节点的查看、编辑和删除选项都以标签页的形式呈现。内容管理页面也有多个标签页（内容、评论、文件），在管理区域中还有许多其他类似的示例。
![[Pasted image 20240619105033.png]]
![[Pasted image 20240619105109.png]]
在本节中，我们将学习如何创建新的标签页组，以及如何在现有组中添加新标签页。

### 新的标签页组

首先，我们将创建一个包含标签页组的新页面，类似于下图所示的那样。
![[Pasted image 20240619105151.png]]

Tab1、Tab2 和 Tab3 将是三个独立的页面，我们需要首先创建它们。需要在路由文件中定义路径，并为每个页面创建控制器方法。

在 `forcontu_pages.routing.yml` 文件中：

```yaml
forcontu_pages.tab1:
  path: '/forcontu/pages/tabs/tab1'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::tab1'
  requirements:
    _permission: 'access content'

forcontu_pages.tab2:
  path: '/forcontu/pages/tabs/tab2'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::tab2'
  requirements:
    _permission: 'access content'

forcontu_pages.tab3:
  path: '/forcontu/pages/tabs/tab3'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::tab3'
  requirements:
    _permission: 'access content'
```

在控制器文件 `/src/Controller/ForcontuPagesController.php` 中：

```php
<?php

namespace Drupal\forcontu_pages\Controller;

use Drupal\Core\Controller\ControllerBase;

class ForcontuPagesController extends ControllerBase {
  //...
  public function tab1() {
    return [
      '#markup' => '<p>' . $this->t('This is the content of Tab 1') . '</p>',
    ];
  }

  public function tab2() {
    return [
      '#markup' => '<p>' . $this->t('This is the content of Tab 2') . '</p>',
    ];
  }

  public function tab3() {
    return [
      '#markup' => '<p>' . $this->t('This is the content of Tab 3') . '</p>',
    ];
  }
}
```

我们已经创建了三个页面，如果直接访问它们的 URL，它们可以独立工作。

为了==将这些页面分组为标签页==，我们需要创建一个新的 `.links.task.yml` 文件，在其中定义每个标签页。在我们的示例中，创建文件 `forcontu_pages.links.task.yml`：

```yaml
forcontu_pages.tab1:
  route_name: forcontu_pages.tab1
  title: Tab 1
  base_route: forcontu_pages.tab1
  weight: 10

forcontu_pages.tab2:
  route_name: forcontu_pages.tab2
  title: Tab 2
  base_route: forcontu_pages.tab1
  weight: 20

forcontu_pages.tab3:
  route_name: forcontu_pages.tab3
  title: Tab 3
  base_route: forcontu_pages.tab1
  weight: 30
```

第一个标签页（`forcontu_pages.tab1`）将作为==默认打开的标签页==，指向自身（`base_route: forcontu_pages.tab1`）。其他标签页将被视为==主标签页的子标签==，因此我们使用相同的 `base_route` 值。
### 子标签页

同样可以创建子标签页组，它们是上级标签页的子标签。在这种情况下，我们将==使用参数 `parent_id` 指定父标签==页。在我们的示例中，我们将创建 `Tab 3a` 和 `Tab 3b` 作为之前创建的 `Tab 3` 的子标签页：

```yaml
forcontu_pages.tab3a:
  route_name: forcontu_pages.tab3a
  title: Tab 3a
  parent_id: forcontu_pages.tab3
  weight: 10

forcontu_pages.tab3b:
  route_name: forcontu_pages.tab3b
  title: Tab 3b
  parent_id: forcontu_pages.tab3
  weight: 20
```

当然，对于 `Tab 3a` 和 `Tab 3b` 页面，我们也需要在 `.routing.yml` 文件中定义路由，并创建它们的控制器方法。

在 `forcontu_pages.routing.yml` 文件中：

```yaml
forcontu_pages.tab3a:
  path: '/forcontu/pages/tabs/tab3a'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::tab3a'
  requirements:
    _permission: 'access content'

forcontu_pages.tab3b:
  path: '/forcontu/pages/tabs/tab3b'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::tab3b'
  requirements:
    _permission: 'access content'
```

在控制器文件 `/src/Controller/ForcontuPagesController.php` 中：

```php
<?php

namespace Drupal\forcontu_pages\Controller;

use Drupal\Core\Controller\ControllerBase;

class ForcontuPagesController extends ControllerBase {
  //...
  public function tab3a() {
    return [
      '#markup' => '<p>' . $this->t('This is the content of Tab 3a') . '</p>',
    ];
  }

  public function tab3b() {
    return [
      '#markup' => '<p>' . $this->t('This is the content of Tab 3b') . '</p>',
    ];
  }
}
```

这样，我们就创建了子标签页 `Tab 3a` 和 `Tab 3b`，它们将显示在 `Tab 3` 标签页下，如图所示。
![[Pasted image 20240619111856.png]]
### 在现有标签页组中添加标签页

要在系统中现有的标签页组中添加标签页，我们需要知道主标签页的系统名称，以便正确设置 `base_route` 的值。这个值需要在定义标签页组的模块的 `.links.task.yml` 文件中查找。

例如，要在内容管理页面（`/admin/content`）中添加一个额外的标签页，我们需要查找 System 模块的文件 `system.links.task.yml`：

```yaml
system.admin_content:
  title: Content
  route_name: system.admin_content
  base_route: system.admin_content
```

注意：在这种情况下，我们可以很容易地推断出是哪条路由，所以我们可以直接在定义标签页的文件中找到它。如果找不到，我们可以先在 `.routing.yml` 文件中查找路由，搜索我们已知的唯一值，即 URL（`path: '/admin/content'`）。

一旦知道要使用的 `base_route` 值（`system.admin_content`），我们只需在 `forcontu_pages.links.task.yml` 文件中定义标签页：

```yaml
forcontu_pages.extratab:
  route_name: forcontu_pages.extratab
  title: Extra tab
  base_route: system.admin_content
  weight: 10
```

当然，我们需要为创建的 `Extra tab` 页面定义相应的路由和控制器。

在 `forcontu_pages.routing.yml` 文件中：

```yaml
forcontu_pages.extratab:
  path: '/admin/content/extra-tab'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::extratab'
  requirements:
    _permission: 'access content'
```

在控制器文件 `/src/Controller/ForcontuPagesController.php` 中：

```php
<?php

namespace Drupal\forcontu_pages\Controller;

use Drupal\Core\Controller\ControllerBase;

class ForcontuPagesController extends ControllerBase {
  //...
  public function extratab() {
    return [
      '#markup' => '<p>' . $this->t('This is the content of the Extra tab') . '</p>',
    ];
  }
}
```

这样，我们就在内容管理页面的标签页组中添加了一个额外的标签页 `Extra tab`，如图所示。
![[Pasted image 20240619114302.png]]
### 标签页和菜单元素

标签页也可以注册为菜单元素。只需在相应的 `.links.menu.yml` 文件中包含路由即可。

例如，在 `forcontu_pages.links.menu.yml` 文件中，我们定义了一个链接到管理菜单中的主标签页：

```yaml
forcontu_pages.tabs:
  title: 'Tabs'
  description: 'Tabs'
  route_name: forcontu_pages.tab1
  parent: forcontu_pages.admin_forcontu_pages
  weight: 5
```

我们还可以添加一个链接到之前创建的 `Extra tab`，即使它不是其标签页组的默认标签页：

```yaml
forcontu_pages.extratab:
  title: 'Extra tab'
  description: 'Extra Tab'
  route_name: forcontu_pages.extratab
  parent: forcontu_pages.admin_forcontu_pages
  weight: 6
```

这样，我们就在管理菜单中增加了指向 `Tabs` 和 `Extra tab` 的链接，如图所示。
![[Pasted image 20240619114728.png]]
有关标签页编程的更多信息，可以参考以下链接：
- [提供模块定义的本地任务](https://www.drupal.org/docs/drupal-apis/menu-api/providing-module-defined-local-tasks)
## 17.6 动作链接（Action Links）

动作链接用于在特定页面上添加操作按钮。例如，在用户管理页面 `/admin/people` 上，==按钮“+添加用户”就是一个动作链接。==
![[Pasted image 20240619114955.png]]
==动作链接在 `.links.action.yml` 文件中定义==，但在此之前，我们需要创建动作链接的目标路由，这将是一个在 `.routing.yml` 文件中定义的普通路由。

例如，在 `forcontu_pages.routing.yml` 文件中定义以下路由：

```yaml
forcontu_pages.action1:
  path: '/forcontu/pages/action1'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::action1'
  requirements:
    _permission: 'access content'
```

我们还需要在 `src/Controller/ForcontuPagesController.php` 文件中添加页面的控制器方法：

```php
<?php

namespace Drupal\forcontu_pages\Controller;

use Drupal\Core\Controller\ControllerBase;

class ForcontuPagesController extends ControllerBase {
  //...
  public function action1() {
    return [
      '#markup' => '<p>' . $this->t('This is the content of Action 1') . '</p>',
    ];
  }
}
```

最后，在 `forcontu_pages.links.action.yml` 文件中定义动作链接：

```yaml
forcontu_pages.link_action1:
  route_name: forcontu_pages.action1
  title: 'Add Something link 1'
  appears_on:
    - forcontu_pages.links
```

我们只需指明路由名称（`route_name`）、链接的标题或文本，以及==动作链接将显示在哪些页面上（`appears_on`）==。在这个例子中，我们将其添加到之前创建的 `forcontu_pages.links` 路由中。

动作链接可以添加到==任何现有页面==，无论该页面是否在我们的模块中创建。例如，如果我们想在“日志和错误”配置页面（`/admin/config/development/logging`）中添加一个动作链接，只需在 System 模块中找到页面的路由名称（`system.logging_settings`）：

```yaml
forcontu_pages.link_action2:
  route_name: forcontu_pages.action2
  title: 'Add Something link 2'
  appears_on:
    - system.logging_settings
```

请记住，对于这个新链接，也需要在路由文件中创建路由，并添加页面的控制器方法。

不同主题对按钮样式的差异，可以在 `core/themes/seven/seven.theme` 文件中看到。例如，Seven 管理主题为按钮添加了额外的类以应用不同的样式：

```php
<?php
//...
/**
 * Implements hook_preprocess_HOOK() for menu-local-action templates.
 */
function seven_preprocess_menu_local_action(array &$variables) {
  $variables['link']['#options']['attributes']['class'][] = 'button--primary';
  $variables['link']['#options']['attributes']['class'][] = 'button--small';
  // We require Modernizr's touch test for button styling.
  $variables['#attached']['library'][] = 'core/modernizr';
}
```

要了解更多关于动作链接编程的信息，可以参考以下页面：
[提供模块定义的行为链接](https://www.drupal.org/docs/drupal-apis/menu-api/providing-module-defined-local-actions)
## 17.7 路由的访问控制

Drupal 通过使用角色和权限来控制对站点某些路由的访问。其==工作原理==非常简单：一个路由将与特定的权限关联，这样只有拥有该权限的用户（通过用户角色检查）才能访问该路由。

#### 权限定义

模块的权限在 `.permissions.yml` 文件中定义。在我们的示例模块中，我们将创建 `forcontu_pages.permissions.yml` 文件，并定义以下权限：

```yaml
'access calculator':
  title: 'Access Calculator page'
  description: 'Allow users to access Calculator page'

'access tab2 page':
  title: 'Access Tab 2 page'
  description: 'Allow users to access Tab 2 page'
```

这些权限将显示在权限列表中：
`/admin/people/permissions`

为了测试权限的功能，我们将创建一个名为“Gestor”的角色，并仅为其分配“Access Tab 2 page”权限。同时，我们还将为其分配 Toolbar 模块的权限：“使用管理工具栏”。

最后，我们将“Gestor”角色分配给用户 `demouser`。

### 路由的访问控制

访问控制是在路由级别设置的。系统将根据当前用户是否具有适当的权限来决定是否==显示菜单链接、标签页或动作链接==。

我们将使用模块中创建的权限来限制对 `forcontu_pages.tab2` 和 `forcontu_pages.calculator` 路由的访问，修改 `forcontu_pages.routing.yml` 文件中的权限。只需在 `_permission` 中分配权限的系统名称（如在 `forcontu_pages.permissions.yml` 中定义的）。

在 `forcontu_pages.routing.yml` 文件中：

```yaml
forcontu_pages.tab2:
  path: '/forcontu/pages/tabs/tab2'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::tab2'
  requirements:
    _permission: 'access tab2 page'

forcontu_pages.calculator:
  path: '/forcontu/pages/calculator/{num1}/{num2}'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::calculator'
    num1: 20
    num2: 10
  requirements:
    _permission: 'access calculator'
```

作为 `demouser` 登录（记住你可以使用 Masquerade 模块进行用户切换），我们将看到 Forcontu 菜单组，但不会显示我们没有访问权限的链接，例如计算器。此外，如果尝试直接在浏览器中输入 URL 进行访问，系统将返回 403 错误，表示访问被拒绝 [F17.7b]。

如果用 `demouser` 访问标签页，我们将看到他确实有权访问这三个标签页。然而，如果以匿名用户访问 `/forcontu/pages/tabs/tab1`，我们将看到只显示了 Tab 1 和 Tab 3，因为我们没有访问 Tab 2 的权限 [F17.7c]。

在这些示例中，我们使用了基于权限的访问控制，但也可以基于角色进行控制：

```yaml
requirements:
  _role: 'gestor'
```

当一个路由是公开访问时，我们将使用 `_access` 指令设置为 TRUE：

```yaml
requirements:
  _access: 'TRUE'
```

在后续章节中，我们将看到其他控制路由访问的方法，例如 `_custom_access` 用于创建自定义检查函数，或 `_entity_access` 用于检查我们是否有权限访问路由中引用的实体。

你可以在以下链接查看所有可用的访问控制选项（requirements）：
[Drupal 路由系统文档](https://www.drupal.org/docs/drupal-apis/routing-system/structure-of-routes)
## 17.8 在控制器类中注入服务

Drupal 有一个服务容器，提供了系统中可重用的功能，包括核心模块、贡献模块和自定义模块。服务的例子有数据库访问、文本翻译、当前用户访问和邮件发送。

### 直接访问服务容器

一种==直接访问==这些服务的方法是通过全局类 `\Drupal`：
https://api.drupal.org/api/drupal/core!lib!Drupal.php/class/Drupal/10

例如，要访问当前用户并检查其是否具有特定权限，可以使用以下代码：

```php
if (\Drupal::currentUser()->hasPermission('administer nodes')) {
  //...
}
```

或者直接调用 `current_user` 服务：

```php
if (\Drupal::service('current_user')->hasPermission('administer nodes')) {
  //...
}
```

可用的服务在 `.services.yml` 文件中定义。例如，`current_user` 服务在 `core.services.yml` 文件中定义。

### 在控制器类中注入服务

与==直接访问全局 `Drupal` 类==不同，我们可以将服务注入到负责生成页面内容的控制器类中。这样，服务将自动可用于控制器类的所有方法，即所有由我们的模块创建的页面。

在文件 `/src/Controller/ForcontuPagesController.php` 中定义我们的控制器类（`class ForcontuPagesController`）。我们将定义一个==构造方法，通过该方法将服务注入到类中==：

- 定义一个新的属性 `$currentUser`，用于存储来自服务的用户对象。
- 在构造方法中添加参数 `AccountInterface $current_user`。这个类表示当前用户：
  https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Session!AccountInterface.php/interface/AccountInterface/10
- 在构造方法中，将服务的值（在实例化类时注入）分配给类的参数 `$currentUser`。
- 最后，定义 `create()` 方法，该方法负责访问服务容器并获取我们想要注入的服务。在方法内部调用 `new static()`，这只是对当前类构造方法的调用，因此需要分配与构造方法相同的参数，并按相同顺序。

```php
<?php
// ...
use Symfony\Component\DependencyInjection\ContainerInterface;
use Drupal\Core\Session\AccountInterface;

class ForcontuPagesController extends ControllerBase {
  protected $currentUser;

  public function __construct(AccountInterface $current_user) {
    $this->currentUser = $current_user;
  }

  public static function create(ContainerInterface $container) {
    return new static(
      $container->get('current_user')
    );
  }
  // ...
}
```

一旦注入服务，就可以在类中定义的任何方法中直接使用 `$this->currentUser` 属性。

作为示例，我们将修改第 17.4 节中创建的 Tab1 页面的内容。在负责输出此页面内容的方法中，我们将添加对当前用户权限的检查，现在可以通过 `$this->currentUser` 始终访问该用户。

文件：`forcontu_pages/src/Controller/ForcontuPagesController.php`

```php
<?php
//...
public function tab1() {
  $output = '<p>' . $this->t('This is the content of Tab 1') . '</p>';

  if ($this->currentUser->hasPermission('administer nodes')) {
    $output .= '<p>' . $this->t('This extra text is only displayed if the current user can administer nodes.') . '</p>';
  }

  return [
    '#markup' => $output,
  ];
}
//...
}
```

==可以使用的所有方法在 `AccountInterface` 接口的定义中找到==。在我们的例子中，我们需要调用 `hasPermission()` 方法，该方法根据用户是否具有指定权限返回 true 或 false。

权限的系统名称需要在每个模块的 `.permissions.yml` 文件中找到。使用的权限 `'administer nodes'` 是核心模块 `node` 的权限，因此在文件 `/core/modules/node/node.permissions.yml` 中创建。

要验证功能是否如预期那样工作，请以匿名用 和管理员用户 访问 Tab 1 页面（`/forcontu/pages/tabs/tab1`）。只有以管理员用户或具有分配了 `'administer nodes'` 权限的角色的其他用户访问时，才会显示额外文本。

#### 注入多个服务

以下是一个注入两个服务的代码示例：

```php
<?php
namespace Drupal\forcontu_console\Controller;

use Drupal\Core\Controller\ControllerBase;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Drupal\Core\Session\AccountProxy;
use Drupal\Core\Database\Driver\mysql\Connection;

class ForcontuConsoleController extends ControllerBase {
  protected $currentUser;
  protected $database;

  public function __construct(AccountProxy $current_user, Connection $database) {
    $this->currentUser = $current_user;
    $this->database = $database;
  }

  public static function create(ContainerInterface $container) {
    return new static(
      $container->get('current_user'),
      $container->get('database')
    );
  }
  //...
}
```

### 在控制器类中注入服务（==替代方法==），不推荐

以下是注入服务的替代方法。两种方法都是有效的，可以互换使用。

```php
<?php
namespace Drupal\forcontu_console\Controller;

use Drupal\Core\Controller\ControllerBase;
use Drupal\Core\Database\Driver\mysql\Connection;
use Drupal\Core\Session\AccountProxyInterface;
use Symfony\Component\DependencyInjection\ContainerInterface;

/**
 * Class ForcontuConsoleController.
 */
class ForcontuConsoleController extends ControllerBase {
  protected $database;
  protected $currentUser;

  public static function create(ContainerInterface $container) {
    $instance = parent::create($container);
    $instance->database = $container->get('database');
    $instance->currentUser = $container->get('current_user');
    return $instance;
  }
  //...
}
```
## 17.9 ==动态路由== dynamic

在前面的部分中，我们创建了==静态路由，即那些在模块安装时就已知的路由==，因此可以直接包含在路由文件中。在本节中，我们将了解如何创建动态路由，这些路由由一个回调函数来管理。

首先，在路由文件中添加 `route_callbacks` 条目。这个变量可以放在文件的==任何位置，但必须在顶层==。我们将在 `route_callbacks` 中包含一个用于管理路由的回调方法列表。格式类似于 `_controller` 中使用的格式，其中指定了类和类中的方法的“路径”：

文件：`forcontu_pages/forcontu_pages.routing.yml`

```yaml
route_callbacks:
  - '\Drupal\forcontu_pages\Routing\ForcontuPagesRoutes::routes'

forcontu_pages.simple:
  path: '/forcontu/pages/simple'
  defaults:
    _controller: '\Drupal\forcontu_pages\Controller\ForcontuPagesController::simple'
    _title: 'Simple Page'
  requirements:
    _permission: 'access content'
```

如上所述，我们需要==在 `/src/Routing` 中创建 `ForcontuPagesRoutes` 类==，并将其文件名与类名相同。

！！！！！！！！！！！！！！==Routing==要大写！！！！！！！！！！

我们的 `routes` 方法将返回一个路由数组，这些路由通过实例化 `Symfony\Component\Routing\Route` 类来定义：
`new Route($url, $definition)`

在 `$url` 中指定新路由的 URL。在 `$definition` 中，我们将以数组格式指定路由的所有参数。这些属性与我们在 `routing.yml` 文件中为每个路由包含的属性类似。

数组中每个路由的键对应于路由的名称。

文件：`forcontu_pages/src/Routing/ForcontuPagesRoutes.php`

```php
<?php

namespace Drupal\forcontu_pages\Routing;

use Symfony\Component\Routing\Route;

/**
 * Provides dynamic routes for forcontu_pages.
 */
class ForcontuPagesRoutes {
  /**
   * Returns an array of route objects.
   *
   * @return \Symfony\Component\Routing\Route[]
   *   An array of route objects.
   */
  public function routes() {
    $routes = [];
    $node_types = \Drupal::entityTypeManager()->getStorage('node_type')->loadMultiple();

    foreach ($node_types as $type) {
      $routes["forcontu_pages.{$type->id()}.help"] = new Route(
        '/forcontu/pages/node/' . $type->id() . '/help',
        [
          '_controller' => '\Drupal\forcontu_pages\Controller\ForcontuPagesController::contentTypeHelpPage',
          '_title' => 'Content Type ' . $type->label(),
        ],
        [
          '_permission' => 'access content',
        ]
      );
    }

    return $routes;
  }
}
```

在我们的示例中，我们为站点中定义的每种内容类型创建一个路由。URL 将是 `/forcontu/pages/node/内容类型/help` 形式：

- `/forcontu/pages/node/article/help`
- `/forcontu/pages/node/page/help`
- `/forcontu/pages/node/noticia/help`

要查看生成的 `$routes` 数组，可以在 `foreach` 之后添加一个 `dpm($routes)` [F17.9a]。

虽然路由是动态创建的，但我们至少需要一个控制器方法来处理这些路由。在我们的示例中，我们将在之前创建的控制器类（`ForcontuPagesController`）中添加 `contentTypeHelpPage()` 方法。

我们还注入了 `current_route_match` 服务，该服务返回当前路由的信息。这样我们就可以从路由中获取内容类型，并根据不同情况打印不同的信息：

文件：`forcontu_pages/src/Controller/ForcontuPagesController.php`

```php
<?php

namespace Drupal\forcontu_pages\Controller;

use Drupal\Core\Controller\ControllerBase;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Datetime\DateFormatter;
use Drupal\Core\Routing\RouteMatchInterface;

class ForcontuPagesController extends ControllerBase {
  protected $currentUser;
  protected $dateFormatter;
  protected $routeMatch;

  public function __construct(AccountInterface $current_user, DateFormatter $dateFormatter, RouteMatchInterface $routeMatch) {
    $this->currentUser = $current_user;
    $this->dateFormatter = $dateFormatter;
    $this->routeMatch = $routeMatch;
  }

  public static function create(ContainerInterface $container) {
    return new static(
      $container->get('current_user'),
      $container->get('date.formatter'),
      $container->get('current_route_match')
    );
  }

  public function contentTypeHelpPage() {
    return [
      '#markup' => '<p>' . $this->t('Content for route %route.', ['%route' => $this->routeMatch->getRouteName()]) . '</p>',
    ];
  }
}
```
### 扩展

在这个示例中，我们返回了一个路由数组。也可以返回一个 `\Symfony\Component\Routing\RouteCollection` 类型的单个对象。你可以在以下链接中查看示例：
[提供动态路由](https://www.drupal.org/docs/drupal-apis/routing-system/providing-dynamic-routes)

要查看其他动态路由的示例，可以在 Drupal 核心代码中搜索 `route_callbacks` 关键字。在这些示例中，你还可以看到如何在实现的路由类中注入服务：

- **Image 模块**：
  - `core/modules/image/image.routing.yml`
  - `core/modules/image/src/Routing/ImageStyleRoutes.php`

- **Search 模块**：
  - `core/modules/search/search.routing.yml`
  - `core/modules/search/src/Routing/SearchPageRoutes.php`

虽然代码稍微复杂一些，但视图模块也使用相同的动态路由方法来注册每个路由并渲染其输出。