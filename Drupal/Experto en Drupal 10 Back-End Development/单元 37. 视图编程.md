==单元内容==
==**37.1 视图编程简介**==
==**37.2 表的集成**==
==**37.3 字段**==
==**37.4 计算字段**==
==**37.5 排序**==
==**37.6 过滤器**==
==**37.7 参数**==
==**37.8 关系**==
==**37.9 视图结果的操作（批量操作）**==
==**37.10 视图的钩子**==
**37.11 从控制台操作**

# 37.1 视图编程简介
在Drupal 10网站建设专家课程（单元20、21、22和35）中，我们已经深入研究了从界面创建和配置视图的方法。在本单元中，我们将看到如何编程实现已经学习过的视图的所有元素（字段、排序、过滤器等）。

首先，让我们看看一些需要在视图层面进行编程的情况：
- **视图元素的编程（过滤器、排序等）**。当我们谈论视图编程时，并不是指从零创建视图，而是编程实现不同的元素，这些元素可以随后从界面添加到视图中。例如，如果我们需要的过滤器无法通过视图中可用的过滤器实现，我们可以编写一个自定义过滤器。在这部分，我们需要编写视图插件：
  [https://api.drupal.org/api/drupal/core!modules!views!views.api.php/group/views_plugins/10](https://api.drupal.org/api/drupal/core!modules!views!views.api.php/group/views_plugins/10)
- **外部数据**。如我们所知，==实体和Drupal的其他元素与视图有直接集成==。如果我们想要集成不由系统直接管理的元素，比如==“外部”表，我们需要编写它们与视图的集成==。为此，我们将实现 `hook_views_data`：
  [https://api.drupal.org/api/drupal/core!modules!views!views.api.php/function/hook_views_data/10](https://api.drupal.org/api/drupal/core!modules!views!views.api.php/function/hook_views_data/10)
- **修改其他视图**。通过钩子，我们可以修改其他视图或其他对视图起作用的元素的行为。视图API的完整钩子列表可以在此查阅：
  [https://api.drupal.org/api/drupal/core!modules!views!views.api.php/10](https://api.drupal.org/api/drupal/core!modules!views!views.api.php/10)

在本单元中，我们将创建Forcontu Views模块（forcontu_views），在Forcontu组内，添加以下元素：
- **表**。首先，我们将添加几个外部表，以便从视图中读取其信息。
- **字段**。将表的内容添加为视图的字段。
- **过滤器**。实现自定义过滤器，以便在这些内容上进行搜索。
- **排序**。添加基于新字段的排序。
- **参数**。编程新的参数以创建参数化视图。
- **关系**。添加关系以链接多个表。
- **操作**。编程新的操作以对视图结果执行操作（批量操作）。
- **钩子**。我们还将看到一些钩子，这些钩子允许我们拦截和修改其他模块创建的视图元素。

#### Forcontu Views模块
第一步是创建Forcontu Views模块（forcontu_views）。为了测试与视图的集成，我们将使用由Forcontu Forms模块实现的表`forcontu_node_highlighted`。因此，我们需要添加此依赖项并确保Forcontu Forms模块已激活。

```yaml
name: 'Forcontu Views'
type: module
description: 'Forcontu Views'
core_version_requirement: ^9
package: 'Forcontu'
dependencies:
  - forcontu_forms
```

`forcontu_node_highlighted`表具有以下字段：
- `nid`：节点ID。
- `highlighted`：布尔值（0/1），表示节点是否被标记为突出。

在之前的单元中，我们已经将此功能集成到站点中，可以从节点创建/编辑表单中将内容标记为突出。

在继续之前，请确认以下内容：
- Forcontu Forms模块是激活的；
- `forcontu_node_highlighted`表已创建；
- 表中至少有5个节点被标记为突出（highlighted = 1）。如果没有，请从内容管理中编辑一些节点并将其标记为突出。
# 37.2 表集成

#### `hook_views_data`
通过 `hook_views_data()`，我们向Views通知我们想要==集成到系统中的外部表==，描述它们的字段和关系。
[https://api.drupal.org/api/drupal/core!modules!views!views.api.php/function/hook_views_data/10](https://api.drupal.org/api/drupal/core!modules!views!views.api.php/function/hook_views_data/10)

钩子中包含了一个注释的实现示例，帮助我们理解预期的 `$data` 数组结构。让我们看看一些代码片段：
- 定义 `$data` 数组，每个条目代表一个表。在`table` 条目中定义了表的属性。

  ```php
  $data = [];
  $data['example_table'] = [];
  $data['example_table']['table'] = [];
  ```

- `group` 是在视图中搜索字段、过滤器等时显示的分组名称。
- `provider` 是实现此钩子的模块的系统名称，也是负责外部表的模块。

  ```php
  $data['example_table']['table']['group'] = t('Example table');
  $data['example_table']['table']['provider'] = 'example_module';
  ```

- 定义为 `base` 的表可以作为视图中的主表使用。未定义为基表的表只能通过与其他表的关系加入视图。

  ```php
  $data['example_table']['table']['base'] = [
    'field' => 'nid',
    'title' => t('Example table'),
    'help' => t('Example table contains example content and can be related to nodes.'),
    'weight' => -10,
  ];
  ```

- 通过 `join` 条目，我们可以将外部表与系统中的某个表链接。这样，每当将系统表添加到视图中时，也可以使用外部视图的信息。在示例代码中，`example_table` 表的 `nid` 字段（`left_field`）通过 `nid` 字段（`field`）链接到 `node_field_data` 表。

  ```php
  $data['example_table']['table']['join'] = [
    'node_field_data' => [
      // Primary key field in node_field_data to use in the join.
      'left_field' => 'nid',
      // Foreign key field in example_table to use in the join.
      'field' => 'nid',
      // 'extra' is an array of additional conditions on the join.
      'extra' => [
        0 => [
          // Adds AND node_field_data.published = TRUE to the join.
          'field' => 'published',
          'value' => TRUE,
        ],
        1 => [
          // Adds AND example_table.numeric_field = 1 to the join.
          'left_field' => 'numeric_field',
          'value' => 1,
          // If true, the value will not be surrounded in quotes.
          'numeric' => TRUE,
        ],
        2 => [
          // Adds AND example_table.boolean_field <> node_field_data.published to the join.
          'field' => 'published',
          'left_field' => 'boolean_field',
          // The operator used, Defaults to "=".
          'operator' => '!=',
        ],
      ],
    ],
  ];
  ```

- 在接下来的部分中，我们将看到如何使外部表的字段在视图中可用，作为字段、过滤器、排序等。这里是 `hook_views_data` 中定义的示例：

  ```php
  // Plain text field, exposed as a field, sort, filter, and argument.
  $data['example_table']['plain_text_field'] = [
    'title' => t('Plain text field'),
    'help' => t('Just a plain text field.'),
    'field' => [
      // ID of field handler plugin to use.
      'id' => 'standard',
    ],
    'sort' => [
      // ID of sort handler plugin to use.
      'id' => 'standard',
    ],
    'filter' => [
      // ID of filter handler plugin to use.
      'id' => 'string',
    ],
    'argument' => [
      // ID of argument handler plugin to use.
      'id' => 'string',
    ],
  ];
  ```

#### 核心示例
在继续开发我们的模块之前，我们将分析一个在核心模块中的实现示例。核心的 History 模块实现了包含 `uid`，`nid` 和 `timestamp` 字段的 `history` 表。
[https://api.drupal.org/api/drupal/core!modules!history!history.views.inc/function/history_views_data/10](https://api.drupal.org/api/drupal/core!modules!history!history.views.inc/function/history_views_data/10)

文件：`core/modules/history/history.views.inc`

```php
<?php
function history_views_data() {
  // History table
  $data['history']['table']['group'] = t('Content');
  // Explain how this table joins to others.
  $data['history']['table']['join'] = [
    // Directly links to node table.
    'node_field_data' => [
      'table' => 'history',
      'left_field' => 'nid',
      'field' => 'nid',
      'extra' => [
        [
          'field' => 'uid',
          'value' => '***CURRENT_USER***',
          'numeric' => TRUE,
        ],
      ],
    ],
  ];
  $data['history']['timestamp'] = [
    'title' => t('Has new content'),
    'field' => [
      'id' => 'history_user_timestamp',
      'help' => t('Show a marker if the content is new or updated.'),
    ],
    'filter' => [
      'help' => t('Show only content that is new or updated.'),
      'id' => 'history_user_timestamp',
    ],
  ];
  return $data;
}
```

`history` 表通过 `nid` 字段与 `node_field_data` 表关联。关系在数组的 `join` 条目中定义。`left_join` 条目指示系统表（`node_field_data`）中的哪个字段将与外部表（`history`）中的字段（`field`）链接。在本例中，两个字段名称相同，均为 `nid`。

在 `extra` 中添加额外的连接条件，相当于在SQL查询中添加AND。在本例中，相当于 "AND `node_field_data`.`uid` = `CURRENT_USER`"。这里我们也使用 `field` 来引用系统表中的字段，使用 `left_field` 来引用外部表中的字段。

```php
$data['history']['table']['join'] = [
  // Directly links to node table.
  'node_field_data' => [
    'table' => 'history',
    'left_field' => 'nid',
    'field' => 'nid',
    'extra' => [
      [
        'field' => 'uid',
        'value' => '***CURRENT_USER***',
        'numeric' => TRUE,
      ],
    ],
  ],
];
```

为了更好地了解 `hook_views_data` 返回的 `$data` 数组的结构，我们可以分析以下核心模块的其他示例：
- 核心 Book 模块中的实现：
  [https://api.drupal.org/api/drupal/core!modules!book!book.views.inc/function/book_views_data/10](https://api.drupal.org/api/drupal/core!modules!book!book.views.inc/function/book_views_data/10)
- 核心 Tracker 模块中的实现：
  [https://api.drupal.org/api/drupal/core!modules!tracker!tracker.views.inc/function/tracker_views_data/10](https://api.drupal.org/api/drupal/core!modules!tracker!tracker.views.inc/function/tracker_views_data/10)

#### 在 Forcontu Views 中实现 `hook_views_data`
现在我们在 Forcontu Views 模块中实现 `hook_views_data`。我们将注册 `forcontu_node_highlighted` 表，并将其链接（join）到核心表 `node_field_data`。我们将字段 `highlighted` 注册为布尔类型，使用布尔类型插件。

文件：`forcontu_views/forcontu_views.views.inc`

```php
<?php
/**
 * Implements hook_views_data().
 */
function forcontu_views_views_data() {
  $data = [];

  $data['forcontu_node_highlighted'] = [];
  $data['forcontu_node_highlighted']['table'] = [];
  $data['forcontu_node_highlighted']['table']['group'] = t('Forcontu Views');
  $data['forcontu_node_highlighted']['table']['provider'] = 'forcontu_views';
  $data['forcontu_node_highlighted']['table']['join'] = [
    'node_field_data' => [
      'left_field' => 'nid',
      'field' => 'nid',
    ],
  ];
  $data['forcontu_node_highlighted']['highlighted'] = [
    'title' => t('Highlighted content'),
    'help' => t('Boolean field for highlighted content.'),
    'field' => [
      'id' => 'boolean',
    ],
    'sort' => [
      'id' => 'standard',
    ],
    'filter' => [
      'id' => 'boolean',
      'label' => t('Highlighted'),
      'type' => 'yes-no',
      'use_equal' => TRUE,
    ],
  ];
  return $data;
}
```

从视图配置中，激活“显示SQL语句”选项。这样我们可以看到我们的代码对视图生成的查询所产生的变化。
我们将创建一个视图以显示突出内容。
![[Pasted image 20240713225544.png]]
下面显示的是初始的SQL查询，尚未添加 `Highlighted` 字段。我们看到只有核心表 `node_field_data` 参与其中：

```sql
SELECT "node_field_data"."created" AS "node_field_data_created",
"node_field_data"."nid" AS "nid"
FROM
{node_field_data} "node_field_data"
WHERE "node_field_data"."status" = '1'
ORDER BY "node_field_data_created" DESC
LIMIT 11 OFFSET 0
```

接下来我们将添加 `Highlighted content` 字段：
我们注意到在生成的SQL查询中添加了一个LEFT JOIN与forcontu_node_highlighted表:


```sql
SELECT 
"forcontu_node_highlighted"."highlighted" AS "forcontu_node_highlighted_highlighted", 
"node_field_data"."created" AS "node_field_data_created", 
"node_field_data"."nid" AS "nid"
FROM
{node_field_data} "node_field_data"
LEFT JOIN {forcontu_node_highlighted} "forcontu_node_highlighted" ON
node_field_data.nid = forcontu_node_highlighted.nid
WHERE "node_field_data"."status" = '1'
ORDER BY "node_field_data_created" DESC
LIMIT 11 OFFSET 0
```

视图的结果如图所示：
![[Pasted image 20240713230706.png]]
# 37.3 字段

#### 现有==字段插件==
视图的字段插件管理获取字段值的==查询及其展示==。我们可以在以下链接查询核心中所有可用的字段插件：
[https://api.drupal.org/api/drupal/core!modules!views!src!Plugin!views!field!FieldPluginBase.php/group/views_field_handlers/10](https://api.drupal.org/api/drupal/core!modules!views!src!Plugin!views!field!FieldPluginBase.php/group/views_field_handlers/10)

正如我们在前一部分中看到的，这些==插件可以在注册新字段时通过== `hook_views_data()` 进行引用。例如，我们将字段 `highlighted` 添加为 `boolean` 类型：
文件：`forcontu_views/forcontu_views.views.inc`

```php
<?php
/**
 * Implements hook_views_data().
 */
function forcontu_views_views_data() {
  // ...
  $data['forcontu_node_highlighted']['highlighted'] = [
    ...
    'field' => [  // 指定 View 字段创建（处理器）
      'id' => 'boolean',
    ],
    ...
  ];
  return $data;
}
```

`id`（`boolean`）是唯一的，在实现字段插件类型时通过注解 `@ViewsField("id_campo")` 声明。

如果我们分析 `Boolean` 类的源代码，会发现：
[https://api.drupal.org/api/drupal/core!modules!views!src!Plugin!views!field!Boolean.php/class/Boolean/10](https://api.drupal.org/api/drupal/core!modules!views!src!Plugin!views!field!Boolean.php/class/Boolean/10)
- 该类扩展了 `FieldPluginBase`，它将作为视图中所有字段插件的基础。
- 插件的 `id` 通过注解定义：`@ViewsField("boolean")`

文件：`core/modules/views/src/Plugin/views/field/Boolean.php`

```php
<?php
/**
 * A handler to provide proper displays for booleans.
 *
 * Allows for display of true/false, yes/no, on/off, enabled/disabled.
 *
 * Definition terms:
 * - output formats: An array where the first entry is displayed on boolean true
 *   and the second is displayed on boolean false. An example for sticky is:
 * @code
 * 'output formats' => array(
 *   'sticky' => array(t('Sticky'), ''),
 * ),
 * @endcode
 *
 * @ingroup views_field_handlers
 *
 * @ViewsField("boolean")
 */
class Boolean extends FieldPluginBase {
```

我们将在本节后面分析插件的方法，当我们实现一个自定义插件时。现在我们只需了解我们可以重用任何核心（或其他模块）的插件，只需知道其 `id`。

一些核心中可用的插件包括：
- `Boolean` ("boolean")。布尔值。
- `Date` ("date")。日期字段。
- `File` ("file")。文件链接。
- `Node` ("node")。节点链接。
- `NumericField` ("numeric")。数值字段。
- `Standard` ("standard")。默认的插件实现。
- `RenderedEntity`("rendered_entity")。根据指定的显示模式渲染实体。

#### 配置参数
当我们使用 `@ViewsField` 类型的插件时，还可以添加额外的配置参数。在以下示例中，注册了一个布尔类型的 `sticky` 字段，并添加了 `click sortable` 和 `output formats` 配置参数：

```php
$data['forum_index']['sticky'] = [
  'title' => t('Sticky'),
  'help' => t('Whether or not the content is sticky.'),
  'field' => [
    'id' => 'boolean',
    'click sortable' => TRUE,
    'output formats' => [
      'sticky' => [t('Sticky'), t('Not sticky')],
    ],
  ],
];
```

这些参数中的有些可能在实现插件的类中定义。在这种情况下，应在类定义前的注释部分中说明。查看前面的 `Boolean` 类，其中描述了可用的“定义术语”（output formats）。

其他参数是继承的，虽然最终类可能不直接使用，但其前置类可能使用了这些参数。例如，`click sortable` 在 `FieldPluginBase` 中使用，通过 `clickSortable` 方法实现。

在类中，这些额外参数存储在 `$this->definition` 数组中：
- `$this->definition['click sortable']`
- `$this->definition['output formats']`
- ...

例如，这是 `FieldPluginBase` 类中 `clickSortable()` 方法的代码，指示字段是否可点击排序：

```php
/**
 * {@inheritdoc}
 */
public function clickSortable() {
  return isset($this->definition['click sortable']) ? $this->definition['click sortable'] : TRUE;
}
```

#### ==实现自定义字段插件==
当我们通过 `hook_views_data` 添加一个表时，首先会在现有插件中查找最适合每个字段的插件。只有在没有适当实现的情况下，我们才需要实现一个新的 `@ViewsField` 类型插件。为此，我们可以采用以下两种方法之一：
- 扩展 `FieldPluginBase`。当你的字段与现有字段不相似时，使用此选项。
- 直接扩展一个 `@ViewsField` 类型插件。当你需要对现有字段进行变更，利用其基础代码时，使用此选项。

插件应创建在模块的 `src/Plugin/views/field` 文件夹中。

例如，下面展示了扩展 `Date` 类的 `comment_last_timestamp` 插件的代码。
文件：`\core\modules\comment\src\Plugin\views\field\LastTimestamp.php`

```php
<?php
namespace Drupal\comment\Plugin\views\field;

use Drupal\views\Plugin\views\field\Date;
use Drupal\views\Plugin\views\display\DisplayPluginBase;
use Drupal\views\ResultRow;
use Drupal\views\ViewExecutable;

/**
 * Field handler to display the timestamp of a comment with the count of comments.
 *
 * @ingroup views_field_handlers
 *
 * @ViewsField("comment_last_timestamp")
 */
class LastTimestamp extends Date {
  /**
   * {@inheritdoc}
   */
  public function init(ViewExecutable $view, DisplayPluginBase $display, array &$options = NULL) {
    parent::init($view, $display, $options);
    $this->additional_fields['comment_count'] = 'comment_count';
  }

  /**
   * {@inheritdoc}
   */
  public function render(ResultRow $values) {
    $comment_count = $this->getValue($values, 'comment_count');
    if (empty($this->options['empty_zero']) || $comment_count) {
      return parent::render($values);
    }
    else {
      return NULL;
    }
  }
}
```

在这两种情况下都没有强制性方法。基类 `FieldPluginBase` 已经实现了这些方法，因此我们只需实现那些需要修改的方法。==一些常用的方法包括==：
- `init()`。插件的初始化函数。例如，可以用于向查询中添加额外字段（`$this->additional_fields`）。
- `defineOptions()`。定义选项，相当于配置变量。这里也可以为这些变量指定默认值。
- `buildOptionsForm()`。插件的配置表单，用于设置选项或配置变量的值。
- `render()`。返回字段输出的函数。

#### ==实现== `BooleanIcon` ==字段插件==
现在回到 Forcontu Views 模块，来实现 `BooleanIcon` 字段插件，该插件将添加一个自定义输出格式，当字段值为真时显示图标。

在这个例子中，我们扩展 `Boolean` 类，因为我们想重用此类型的所有选项。我们将添加以下更改：
- `init()` 方法。将新格式 `icon` 添加到现有的 `$this->formats` 属性。
- `defineOptions()` 方法。添加一个配置选项 `type_icon_path_true`，用于指定图标路径。
- `buildOptionsForm()` 方法。添加一个表单，用于指定图标路径。仅当选择 `icon` 格式时才显示此字段。
- `render()` 方法。根据指定的图标路径，将字段输出渲染为图片。

文件：`forcontu_views/src/Plugin/views/field/BooleanIcon.php`

```php
<?php
namespace Drupal\forcontu_views\Plugin\views\field;

use Drupal\Core\Form\FormStateInterface;
use Drupal\views\Plugin\views\field\Boolean;
use Drupal\views\ResultRow;
use Drupal\views\ViewExecutable;
use Drupal\views\Plugin\views\display\DisplayPluginBase;

/**
 * Provides BooleanIcon field handler.
 *
 * @ViewsField("boolean_icon")
 */
class BooleanIcon extends Boolean {

  /**
   * {@inheritdoc}
   */
  public function init(ViewExecutable $view, DisplayPluginBase $display, array &$options = NULL) {
    parent::init($view, $display, $options);
    $new_format = ['icon' => [t('Icon')]];

    $this->formats = array_merge($this->formats, $new_format);
  }

  /**
   * {@inheritdoc}
   */
  protected function defineOptions() {
    $options = parent::defineOptions();

    $options['type_icon_path_true'] = [
      'default' => '',
    ];

    return $options;
  }

  /**
   * {@inheritdoc}
   */
  public function buildOptionsForm(&$form, FormStateInterface $form_state) {
    parent::buildOptionsForm($form, $form_state);
    $form['type_icon_path_true'] = [
      '#type' => 'textfield',
      '#title' => $this->t('Icon path'),
      '#default_value' => $this->options['type_icon_path_true'],
      '#description' => $this->t('URI format public:// or private://'),
      '#states' => [
        'visible' => [
          'select[name="options[type]"]' => [
            'value' => 'icon',
          ],
        ],
      ],
    ];
  }

  /**
   * {@inheritdoc}
   */
  public function render(ResultRow $values) {
    $value = $this->getValue($values);
    if ($this->options['type'] == 'icon') {
      $build = [
        '#theme' => 'image',
        '#uri' => $this->options['type_icon_path_true'],
        '#alt' => $this->t('Highlighted content'),
        '#title' => $this->t('Highlighted content'),
        '#width' => 16,
      ];

      return $value ? $build : NULL;
    } else {
      return parent::render($values);
    }
  }
}
```

接下来，我们将在 `hook_views_data` 中指定的字段插件 `id` 修改为新的插件 `boolean_icon`：
文件：`forcontu_views/forcontu_views.views.inc`

```php
<?php
/**
 * Implements hook_views_data().
 */
function forcontu_views_views_data() {
  // ...
  $data['forcontu_node_highlighted']['highlighted'] = [
    ...
    'field' => [
      'id' => 'boolean_icon',
    ],
    ...
  ];
  return $data;
}
```

清空缓存后，插件将可用，我们可以从视图编辑界面配置字段输出：
![[Pasted image 20240714071633.png]]
现在我们需要上传一个图标类型的图片到公共文件夹，并在字段配置中指定路径：
![[Pasted image 20240714071655.png]]
如果 `public` 方案对应于 `/sites/default/files`，则 URI `public://foo/bar/example.txt` 实际上指向：
```
/sites/default/files/foo/bar/example.txt
```
Reference: [[单元 32. 文件和图像 1]]

结果如图所示：
![[Pasted image 20240714071727.png]]
# 37.4 ==计算字段==（computed）

#### 实现 "计算" 字段插件
计算字段，也称为“计算字段”，是一个==不直接存在于表中的字段，而是根据其他值动态计算得出的==。我们需要注意以下两条规则：
- 通过 `hook_views_data()` 或 `hook_views_data_alter()` 将插件分配为表的字段。
- 由于列不存在，我们==需要覆盖==插件的 `query()` 方法，==并将其留空==。这样可以避免系统对不存在的列进行查询。

作为示例，我们将创建 `PublishedByOn` 插件，它将显示每个内容的以下文本：
- 由用户在创建日期发布

例如：
- 由 admin 在 2021年6月16日 12:05 发布

原则上，我们只需要实现以下方法：
- `render()` 方法。在这里计算值并显示输出。注意，可以使用查询返回的值，重要的是到达我们想要提取信息的节点（`$node = $values->_entity`）。
- `query()` 方法。正如我们所提到的，需要包含此空方法以覆盖基类的方法。

文件：`forcontu_views/src/Plugin/views/field/PublishedByOn.php`

```php
<?php
namespace Drupal\forcontu_views\Plugin\views\field;

use Drupal\views\ResultRow;
use Drupal\views\Plugin\views\field\FieldPluginBase;

/**
 * Provides PublishedByOn field handler.
 *
 * @ViewsField("published_by_on")
 */
class PublishedByOn extends FieldPluginBase {
  /**
   * {@inheritdoc}
   */
  public function render(ResultRow $values) {
    $node = $values->_entity;
    $author = $node->getOwner()->getDisplayName();
    $created_time = \Drupal::service('date.formatter')->format($node->getCreatedTime(), 'short');

    $build = [
      '#markup' => $this->t("Published by @user on @date", [
        '@user' => $author,
        '@date' => $created_time,
      ]),
    ];
    return $build;
  }

  /**
   * {@inheritdoc}
   */
  public function query() {
    // This function exists to override parent query function.
    // Do nothing.
  }
}
```

最后，==为了使用插件，我们需要将字段添加到一个表中。==由于我们将其分配给 `node_field_data` 表，而该表未在我们的模块中定义，我们需要使用 `hook_views_data_alter()`：

文件：`forcontu_views/forcontu_views.views.inc`

```php
<?php
/**
 * Implements hook_views_data_alter().
 */
function forcontu_views_views_data_alter(array &$data) {
  if (isset($data['node_field_data'])) {
    $data['node_field_data']['published_by_on'] = [
      'title' => t('Published by'),
      'field' => [
        'id' => 'published_by_on',
      ],
    ];
  }
}
```
![[Pasted image 20240714073126.png]]
==每当创建一个涉及 `node_field_data` 表的视图时==，我们的==计算字段将可用==。我们可以像添加视图中的任何其他字段一样添加该字段.

相关链接：
- [https://www.drupal.org/docs/drupal-apis/entity-api/dynamicvirtual-field-values-usingcomputed-field-property-classes#s-views-integration](https://www.drupal.org/docs/drupal-apis/entity-api/dynamicvirtual-field-values-usingcomputed-field-property-classes#s-views-integration)
# 37.5 排序

#### 现有排序插件
我们可以在以下链接查询核心中所有可用的排序插件：
[https://api.drupal.org/api/drupal/core!modules!views!src!Plugin!views!sort!SortPluginBase.php/group/views_sort_handlers/10](https://api.drupal.org/api/drupal/core!modules!views!src!Plugin!views!sort!SortPluginBase.php/group/views_sort_handlers/10)

与字段插件类似，排序插件也可以在注册新字段时通过 `hook_views_data()` 进行引用。例如，当添加 `highlighted` 字段时，我们指定排序为 `standard`：

文件：`forcontu_views/forcontu_views.views.inc`

```php
<?php
/**
 * Implements hook_views_data().
 */
function forcontu_views_views_data() {
  ...
  $data['forcontu_node_highlighted']['highlighted'] = [
    'title' => t('Highlighted content'),
    'help' => t('Boolean field for highlighted content.'),
    'field' => [
      'id' => 'boolean_icon',
    ],
    'sort' => [
      'id' => 'standard',
    ],
    ...
  ];
  return $data;
}
```

一些核心中可用的插件包括：
- `Standard` ("standard")。插件的默认实现，扩展 `SortPluginBase` 类而不进行任何修改。
- `Score` ("search_score")。按搜索评分排序。
- `Thread` ("comment_thread")。按评论线程排序。
- `Date` ("date" 和 "datetime")。按日期排序，具有粒度。
- `Random` ("random")。随机排序。

#### ==实现自定义排序插件==
当我们通过 `hook_views_data` 添加一个表时，首先会在现有插件中查找最适合管理每个字段排序的插件。只有在没有适当实现或需要为排序添加配置时，我们才需要实现一个新的 `@ViewsSort` 类型插件。为此，我们可以采用以下两种方法之一：
- 扩展 `SortPluginBase`。当排序不可用时，使用此选项。
- 直接扩展一个 `@ViewsSort` 类型插件。当需要对现有排序插件进行变更，利用其基础代码时，使用此选项。

这两种情况下都没有强制性方法。基类 `SortPluginBase` 已经实现了这些方法，因此我们只需实现那些需要修改的方法。一些常用的方法包括：
- `init()`。插件的初始化函数。
- `defineOptions()`。定义选项，相当于配置变量。这里也可以为这些变量指定默认值。
- `buildOptionsForm()`。插件的配置表单，用于设置选项或配置变量的值。
- `query()`。将排序添加到查询的函数。通常是调用 `$this->query->addOrderBy()`。

例如，我们展示 `date` 插件的实现，它允许通过配置粒度（从年到秒）来按日期排序。在 `Date` 类中，我们可以分析 `defineOptions()` 和 `buildOptionsForm()` 方法的实现，以配置粒度选项，以及 `query()` 方法，根据设定的粒度将排序添加到查询中：

文件：`core/modules/views/src/Plugin/views/sort/Date.php`

```php
<?php
namespace Drupal\views\Plugin\views\sort;

use Drupal\Core\Form\FormStateInterface;

/**
 * Basic sort handler for dates.
 *
 * This handler enables granularity, which is the ability to make dates
 * equivalent based upon nearness.
 *
 * @ViewsSort("date")
 */
class Date extends SortPluginBase {
  protected function defineOptions() {
    $options = parent::defineOptions();
    $options['granularity'] = ['default' => 'second'];
    return $options;
  }

  public function buildOptionsForm(&$form, FormStateInterface $form_state) {
    parent::buildOptionsForm($form, $form_state);
    $form['granularity'] = [
      '#type' => 'radios',
      '#title' => $this->t('Granularity'),
      '#options' => [
        'second' => $this->t('Second'),
        'minute' => $this->t('Minute'),
        'hour' => $this->t('Hour'),
        'day' => $this->t('Day'),
        'month' => $this->t('Month'),
        'year' => $this->t('Year'),
      ],
      '#description' => $this->t('The granularity is the smallest unit to use when determining whether two dates are the same; for example, if the granularity is "Year" then all dates in 1999, regardless of when they fall in 1999, will be considered the same date.'),
      '#default_value' => $this->options['granularity'],
    ];
  }

  /**
   * Called to add the sort to a query.
   */
  public function query() {
    $this->ensureMyTable();
    switch ($this->options['granularity']) {
      case 'second':
      default:
        $this->query->addOrderBy($this->tableAlias, $this->realField, $this->options['order']);
        return;
      case 'minute':
        $formula = $this->getDateFormat('YmdHi');
        break;
      case 'hour':
        $formula = $this->getDateFormat('YmdH');
        break;
      case 'day':
        $formula = $this->getDateFormat('Ymd');
        break;
      case 'month':
        $formula = $this->getDateFormat('Ym');
        break;
      case 'year':
        $formula = $this->getDateFormat('Y');
        break;
    }
    // Add the field.
    $this->query->addOrderBy(NULL, $formula, $this->options['order'], $this->tableAlias . '_' . $this->field . '_' . $this->options['granularity']);
  }
}
```

需要注意的是，生成的 `$query` 是视图的特殊SQL实现（插件 `@ViewsQuery`），我们可以在以下链接查询：
[https://api.drupal.org/api/drupal/core!modules!views!src!Plugin!views!query!Sql.php/class/Sql/10](https://api.drupal.org/api/drupal/core!modules!views!src!Plugin!views!query!Sql.php/class/Sql/10)

我们还应查询 `addOrderBy()` 方法及其参数：
```php
function addOrderBy($table, $field = NULL, $order = 'ASC', $alias = '', $params = [])
```
[https://api.drupal.org/api/drupal/core!modules!views!src!Plugin!views!query!Sql.php/function/Sql::addOrderBy/10](https://api.drupal.org/api/drupal/core!modules!views!src!Plugin!views!query!Sql.php/function/Sql::addOrderBy/10)

`addOrderBy()` 函数接受按字段或公式排序：
- `$table`。字段所在的表名。如果使用公式，$table 的值为 NULL。
- `$field`。用于排序的字段或公式。
- `$order`。'ASC'（升序）或 'DESC'（降序）。
- `$alias`。字段的别名。
- `$params`。附加参数。

值得注意的是，非常常用的 `$this->ensureMyTable()` 方法，它==确保处理器的主表正确添加到查询中==。

#### 实现 `highlighted_order` 排序插件
我们将实现一个与 Forcontu Views 模块的 `highlighted` 字段关联的自定义排序插件。该插件将添加双重排序：
- 首先显示突出内容。
- 按修改日期排序，升序或降序根据过滤器配置指定。

文件：`forcontu_views/src/Plugin/views/sort/HighlightedOrder.php`  ==注意目录、namespace，否则会提示缺失==

```php
<?php
namespace Drupal\forcontu_views\Plugin\views\sort;

use Drupal\views\Plugin\views\sort\SortPluginBase;

/**
 * Ordenación por destacado y fecha de modificación desc
 *
 * @ViewsSort("highlighted_order")
 */
class HighlightedOrder extends SortPluginBase {
  /**
   * Called to add the sort to a query.
   */
  public function query() {
    $this->ensureMyTable();
    // 突出显示的节点将始终首先显示
    $this->query->addOrderBy('forcontu_node_highlighted', 'highlighted', 'DESC');

    // 按日期排序在过滤器配置中设置
    $this->query->addOrderBy('node_field_data', 'changed', $this->options['order']);
  }
}
```

创建插件后，我们可以在 `hook_views_data` 中使用它：

文件：`forcontu_views/forcontu_views.views.inc`

```php
<?php
/**
 * Implements hook_views_data().
 */
function forcontu_views_views_data() {
  ...
  $data['forcontu_node_highlighted']['highlighted'] = [
    'title' => t('Highlighted content'),
    'help' => t('Boolean field for highlighted content.'),
    'field' => [
      'id' => 'boolean_icon',
    ],
    'sort' => [
      'id' => 'highlighted_order',
    ],
    ...
  ];
  return $data;
}
```

清空缓存后，我们可以从排序标准中添加过滤器，搜索字段名称：

在字段中我们可以选择排序类型，升序或降序。根据过滤器的编程，此排序仅影响排序的第二个条件（修改日期）。

在生成的查询中我们可以看到添加的 `ORDER BY` 子句：

```sql
SELECT "forcontu_node_highlighted"."highlighted" AS "forcontu_node_highlighted_highlighted", 
"node_field_data"."changed" AS "node_field_data_changed", 
"node_field_data"."nid" AS "nid"
FROM
{node_field_data} "node_field_data"
LEFT JOIN {forcontu_node_highlighted} "forcontu_node_highlighted" ON 
node_field_data.nid = forcontu_node_highlighted.nid
WHERE "node_field_data"."status" = '1'
ORDER BY "forcontu_node_highlighted_highlighted" DESC, "node_field_data_changed" ASC
```

结果显示节点按从旧到新的顺序排列，首先显示突出显示的节点：

相关链接：
- [Drupal 8 Views tutorial for developers. Part III — Sorts & Filters](https://medium.com/oleksandr-trotsenko/drupal-8-views-tutorial-for-developers-part-iii-sortsfilters-49baa40418de)
# 37.6 过滤器

#### 现有过滤插件
我们可以在以下链接查询核心中所有可用的过滤插件：
[https://api.drupal.org/api/drupal/core!modules!views!src!Plugin!views!filter!FilterPluginBase.php/group/views_filter_handlers/10](https://api.drupal.org/api/drupal/core!modules!views!src!Plugin!views!filter!FilterPluginBase.php/group/views_filter_handlers/10)

==与字段插件和排序插件类似，过滤插件==也可以在注册新字段时通过 `hook_views_data()` 进行引用。例如，当添加 `highlighted` 字段时，我们指定过滤为 `boolean`：

文件：`forcontu_views/forcontu_views.views.inc`

```php
<?php
/**
 * Implements hook_views_data().
 */
function forcontu_views_views_data() {
  ...
  $data['forcontu_node_highlighted']['highlighted'] = [
    'title' => t('Highlighted content'),
    'help' => t('Boolean field for highlighted content.'),
    'field' => [
      'id' => 'boolean_icon',
    ],
    'sort' => [
      'id' => 'highlighted_order',
    ],
    'filter' => [
      'id' => 'boolean',
      'label' => t('Highlighted'),
      'type' => 'yes-no',
      'use_equal' => TRUE,
    ],
  ];
  return $data;
}
```

一些核心中可用的过滤插件包括：
- `Standard` ("standard")。插件的默认实现，扩展 `FilterPluginBase` 类而不进行任何修改。
- `StringFilter` ("string")。字符串过滤器。
- `Status` ("node_status")。按内容发布状态过滤。
- `Current` ("current_user")。按当前用户过滤。
- `Permissions` ("user_permissions")。按用户角色过滤。
- `Date` ("date" 或 "datetime")。日期过滤器。

#### 实现自定义过滤插件
当我们通过 `hook_views_data` 添加一个表时，首先会在现有插件中查找最适合过滤每个字段的插件。只有在没有适当实现或需要为过滤器添加额外配置时，我们才需要实现一个新的 `@ViewsFilter` 类型插件。为此，我们可以采用以下两种方法之一：
- 扩展 `FilterPluginBase`。当过滤类型不可用时，使用此选项。
- 直接扩展一个 `@ViewsFilter` 类型插件。当需要对现有过滤插件进行变更，利用其基础代码时，使用此选项。

这两种情况下都没有强制性方法。基类 `FilterPluginBase` 已经实现了这些方法，因此我们只需实现那些需要修改的方法。一些常用的方法包括：
- `init()`。插件的初始化函数。
- `defineOptions()`。定义选项，相当于配置变量。这里也可以为这些变量指定默认值。
- `buildOptionsForm()`。插件的配置表单，用于设置选项或配置变量的值。
- `operatorOptions()`、`operatorForm()`、`operatorValidate()`、`operatorSubmit()`。与操作符配置相关的方法。
- `getCacheContexts()`。允许访问上下文或通用变量。例如，当前用户。
- `query()`。将过滤的 WHERE 子句添加到查询的函数。
- `canExpose()`。根据过滤器是否可暴露，返回 true 或 false。

例如，我们展示 `node_status` 插件的实现，它允许按内容的发布状态进行过滤。

文件：`core/modules/node/src/Plugin/views/filter/Status.php`

```php
<?php
namespace Drupal\node\Plugin\views\filter;

use Drupal\Core\Form\FormStateInterface;
use Drupal\views\Plugin\views\filter\FilterPluginBase;

/**
 * Filter by published status.
 *
 * @ingroup views_filter_handlers
 *
 * @ViewsFilter("node_status")
 */
class Status extends FilterPluginBase {
  public function adminSummary() {}
  protected function operatorForm(&$form, FormStateInterface $form_state) {}
  public function canExpose() {
    return FALSE;
  }
  public function query() {
    $table = $this->ensureMyTable();
    $snippet = "$table.status = 1 OR ($table.uid = ***CURRENT_USER*** AND ***CURRENT_USER*** <> 0 AND ***VIEW_OWN_UNPUBLISHED_NODES*** = 1) OR ***BYPASS_NODE_ACCESS*** = 1";
    if ($this->moduleHandler->moduleExists('content_moderation')) {
      $snippet .= ' OR ***VIEW_ANY_UNPUBLISHED_NODES*** = 1';
    }
    $this->query->addWhereExpression($this->options['group'], $snippet);
  }
  /**
   * {@inheritdoc}
   */
  public function getCacheContexts() {
    $contexts = parent::getCacheContexts();
    $contexts[] = 'user';
    return $contexts;
  }
}
```

如上代码所示，一些函数被实现为空。这允许我们覆盖默认功能，以防止其在我们的过滤器中执行。

#### 实现 `highlighted_recent` 过滤插件
我们将在 Forcontu Views 模块中实现 `highlighted_recent` 过滤插件，该插件将过滤最近3天内修改的突出内容。该过滤器不能暴露，也没有操作符配置选项。

文件：`forcontu_views/src/Plugin/views/filter/HighlightedRecent.php` ， 注意命名空间

```php
<?php
namespace Drupal\forcontu_views\Plugin\views\filter;

use Drupal\views\Plugin\views\filter\FilterPluginBase;
use Drupal\Core\Form\FormStateInterface;

/**
 *
 * @ViewsFilter("highlighted_recent")
 */
class HighlightedRecent extends FilterPluginBase {
  public function adminSummary() {}
  protected function operatorForm(&$form, FormStateInterface $form_state) {}
  public function canExpose() {
    return FALSE;
  }
  public function query() {
    $table = $this->ensureMyTable();
    $currentTime = \Drupal::time()->getCurrentTime();
    // 减去当前日期的3天
    $minTime = $currentTime - (3 * 24 * 3600);
    $snippet = "$table.highlighted = 1 AND node_field_data.changed > $minTime";
    $this->query->addWhereExpression($this->options['group'], $snippet);
  }
}
```

创建插件后，可以==在 `hook_views_data` 中使用它==。为了保持默认的布尔过滤器，我们将其添加为新字段。==该“字段”仅作为过滤器可用，因此只添加 `filter` 条目==：

文件：`forcontu_views/forcontu_views.views.inc`

```php
<?php
/**
 * Implements hook_views_data().
 */
function forcontu_views_views_data() {
  ...
  $data['forcontu_node_highlighted']['highlighted'] = [
    ...
  ];
  $data['forcontu_node_highlighted']['highlighted_recent'] = [
    'title' => t('Highlighted recent content'),
    'help' => t('Highlighted recent content.'),
    'filter' => [
      'id' => 'highlighted_recent',
      'label' => t('Highlighted recent'),
    ],
  ];
  return $data;
}
```

清空缓存后，我们可以从过滤标准中添加过滤器，搜索字段名称。在 Forcontu Views 类别中，将显示定义的两个过滤器。选择 `Highlighted recent content` 过滤器：
![[Pasted image 20240714085403.png]]

由于我们未定义配置选项，只能选择管理标题：
![[Pasted image 20240714085658.png]]

在生成的查询中可以看到添加的 WHERE 子句：

```sql
SELECT "forcontu_node_highlighted"."highlighted" AS "forcontu_node_highlighted_highlighted", 
"node_field_data"."changed" AS "node_field_data_changed", 
"node_field_data"."nid" AS "nid"
FROM
{node_field_data} "node_field_data"
LEFT JOIN {forcontu_node_highlighted} "forcontu_node_highlighted" ON 
node_field_data.nid = forcontu_node_highlighted.nid
WHERE ("node_field_data"."status" = '1') AND
((forcontu_node_highlighted.highlighted = 1 AND node_field_data.changed > 1626016218))
ORDER BY "forcontu_node_highlighted_highlighted" DESC, "node_field_data_changed" ASC
```

结果显示仅在最近3天内修改的突出节点。
# 37.7 参数

#### 现有参数插件
我们可以在以下链接查询核心中所有可用的参数插件：
[https://api.drupal.org/api/drupal/core!modules!views!src!Plugin!views!argument!ArgumentPluginBase.php/group/views_argument_handlers/10](https://api.drupal.org/api/drupal/core!modules!views!src!Plugin!views!argument!ArgumentPluginBase.php/group/views_argument_handlers/10)

查看 Site Building 单元 22 以更好地了解如何在上下文过滤器中使用参数。核心中可用的一些参数插件包括：
- `Standard` ("standard")。插件的默认实现，扩展 `ArgumentPluginBase` 类而不进行任何修改。
- `StringArgument` ("string")。字符串参数。
- `Date` ("date")。日期参数。
- `Uid` ("uid")。用户ID参数。
- `Taxonomy` ("taxonomy")。分类术语参数。

#### 实现自定义参数插件   没成功
我们可以采用以下两种方法之一：
- 扩展 `ArgumentPluginBase`。当参数类型不可用时，使用此选项。
- 直接扩展一个 `@ViewsArgument` 类型插件。当需要对现有参数插件进行变更，利用其基础代码时，使用此选项。

为了实现以下插件，我们参考了以下文章中的示例：[https://evolvingweb.ca/blog/how-create-custom-views-argument-plugin-drupal-8](https://evolvingweb.ca/blog/how-create-custom-views-argument-plugin-drupal-8)。

我们将实现一个参数插件，以接受“slugs”或友好路径作为参数，替换分类术语的ID。为此，我们将在站点的任何词汇表中创建一个名为 "field_slug" 的文本字段，并在每个术语中添加一个不包含特殊字符的字符串，以用作 URL 的一部分。

例如，如果我们有一个国家词汇表，可以有以下值：

| TID | 术语名称 | field_slug  |
| --- | ---- | ----------- |
| 3   | 西班牙  | espana      |
| 4   | 英国   | reino-unido |
| 5   | 秘鲁   | peru        |

这样，我们可以创建一个带有参数化 URL 的视图（/noticias/espana, /noticias/peru等），避免在 URL 中使用术语的ID（/noticias/3, /noticias/5等）。

尽管我们已经在 Site Building 单元 22 中看到如何在不编程的情况下实现此功能，但此示例将帮助我们更好地了解如何实现自定义参数插件。

从管理界面，我们将创建以下元素：
- 一个名为 "Países" 的新词汇表。
- 向该词汇表添加一个名为 "Slug"（field_slug）的字段。请务必遵守此系统名称，因为我们的插件实现将特定于此字段。
- 接下来，我们将创建几个国家名称术语及其对应的 slug 值。例如，对于西班牙，我们可以使用 "espana"。
- 在文章内容类型中，我们将创建一个国家字段，该字段是使用前述词汇表的分类术语引用类型。

现在我们可以实现 "term_slug" 插件。我们所做的只是将 URL 中的值（文本 slug）替换为其对应的术语ID。

文件：`forcontu_views/src/Plugin/views/argument/TermSlug.php`

```php
<?php
namespace Drupal\forcontu_views\Plugin\views\argument;

use Drupal\taxonomy\Plugin\views\argument\Taxonomy;

/**
 * Defines a filter for Taxonomy Term Slugs.
 *
 * @ViewsArgument("term_slug")
 */
class TermSlug extends Taxonomy {
  /**
   * {@inheritdoc}
   */
  public function setArgument($arg) {
    if ($this->isException($arg)) {
      return parent::setArgument($arg);
    }
    // 参数将是术语名称
    $tid = $this->convertSlugToTid($arg);
    $this->argument = (int) $tid;
    return $this->validateArgument($tid);
  }

  /**
   * Get taxonomy term ID from a slug.
   *
   * @return int
   *   Taxonomy term ID.
   */
  protected function convertSlugToTid($slug) {
    $query = $this->termStorage->getQuery()
      ->condition('field_slug', $slug);

    // 允许的词汇表
    if (isset($this->options['specify_validation']) && isset($this->options['validate_options']['bundles'])) {
      $query->condition('vid', $this->options['validate_options']['bundles']);
    }
    // 结果术语ID
    $tids = $query->execute();
    return $tids ? reset($tids) : FALSE;
  }
}
```

当我们在Drupal中创建实体（如内容或分类术语）时，会自动创建关联表，以便从视图中使用它们。查看所有可用表的一种方法是调试 `hook_views_data_alter()` 中的 `$data` 值（`dpm($data)`）。

我们将看到分类术语的 `field_slug` 字段已添加条目：
```php
$data['taxonomy_term__field_slug']
```
因此，我们将检查是否存在此条目，并将默认参数插件替换为我们定义的 `term_slug` 插件：

文件：`forcontu_views/forcontu_views.views.inc`

```php
/**
 * Implements hook_views_data_alter().
 */
function forcontu_views_views_data_alter(array &$data) {
  ...

  // 检查分类术语中是否存在 "field_slug" 字段。
  if (isset($data['taxonomy_term__field_slug'])) {
    $field_slug = $data['taxonomy_term__field_slug']['field_slug'];
    // 使用 term_slug 声明参数
    $data['taxonomy_term__field_slug']['field_slug_entity_id'] = [
      'group' => $field_slug['group'],
      'title' => t('Custom: Has taxonomy term with slug'),
      'title short' => t('Slug'),
      'help' => $field_slug['help'],
      'argument' => [
        'table' => 'taxonomy_term__field_slug',
        'field' => 'entity_id',
        'id' => 'term_slug',
        'zero is null' => TRUE,
      ],
    ];
  }
}
```

接下来，我们创建一个使用该参数的视图。创建名为 Noticias 的视图，URL 为 /noticias/%。为了查看其是否正常工作，我们可以以表格形式显示结果，并添加标题和国家字段。

然后，从 `field_pais` 字段中添加与分类术语的关系：

从上下文过滤器中，我们将看到创建的过滤器 "Custom: Has taxonomy term with slug"。该过滤器需要前面的关系，因此只有在我们已添加关系的情况下才会显示。

虽然原则上不需要修改过滤器的默认配置，但我们可以修改标题或验证标准等值。

我们的视图将配置如下所示：

如果我们测试类似 /noticias/espana 的 URL，将看到结果已过滤：
# 37.8 关系

==如果一个实体A的字段引用了另一个实体B，以实体A为数据源的View就可以添加到实体B的关系。==

为了说明在视图中实现关系，我们将创建一个包含用户相关信息的 `forcontu_views_users` 表：
- `id`：主键（自增）。
- `uid`：Drupal中的用户UID。我们将使用此字段将该表中的用户与站点中的用户关联。
- `employee_code`：员工代码。
- `job_title`：职位。

文件：`forcontu_views/forcontu_views.install`

```php
<?php
/**
 * Implements hook_schema().
 */
function forcontu_views_schema() {
  $schema['forcontu_views_users'] = [
    'description' => 'Tabla con información de usuarios',
    'fields' => [
      'id' => [
        'description' => 'id',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ],
      'uid' => [
        'description' => 'uid',
        'type' => 'int',
        'not null' => TRUE,
      ],
      'employee_code' => [
        'type' => 'varchar',
        'length' => 10,
        'not null' => TRUE,
        'default' => '',
        'description' => 'Employee code',
      ],
      'job_title' => [
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
        'description' => 'Job title',
      ],
    ],
    'primary key' => ['id'],
  ];

  return $schema;
}
```

要生成此表，先卸载 Forcontu Views 模块，然后重新安装该模块。接下来，检查表是否已创建，如果已创建，请添加几个具有有效UID的记录，这些UID应为站点中现有用户的UID。

然后，我们将通过 `hook_views_data()` 将此表添加到视图中，如我们在第37.2节中所做的那样。

文件：`forcontu_views/forcontu_views.views.inc`

```php
<?php
/**
 * Implements hook_views_data().
 */
function forcontu_views_views_data() {
  $data = [];

  $data['forcontu_node_highlighted'] = [];
  ...

  $data['forcontu_views_users'] = [];
  $data['forcontu_views_users']['table'] = [];
  $data['forcontu_views_users']['table']['group'] = t('Forcontu Views');
  $data['forcontu_views_users']['table']['provider'] = 'forcontu_views';

  // 将表添加为基础表，因此我们可以创建一个以“ Forcontu Views Users”作为基础元素的视图
  $data['forcontu_views_users']['table']['base'] = [
    'field' => 'id',
    'title' => t('Forcontu Views Users'),
    'help' => t('Employee additional data'),
  ];

  $data['forcontu_views_users']['table']['join'] = [
    'users' => [
      'left_field' => 'uid',
      'field' => 'uid',
    ]
  ];

  $data['forcontu_views_users']['id'] = [
    'title' => t('ID'),
    'help' => t('The unique ID.'),
    'field' => [
      'id' => 'numeric',
    ],
    'filter' => [
      'id' => 'numeric',
    ],
    'sort' => [
      'id' => 'standard',
    ],
    'argument' => [
      'id' => 'numeric',
    ],
  ];

  $data['forcontu_views_users']['employee_code'] = [
    'title' => t('Employee code'),
    'help' => t('Employee code'),
    'field' => [
      'id' => 'standard',
    ],
    'filter' => [
      'id' => 'string',
    ],
    'argument' => [
      'id' => 'string',
    ],
  ];

  $data['forcontu_views_users']['job_title'] = [
    'title' => t('Job title'),
    'help' => t('Job title'),
    'field' => [
      'id' => 'standard',
    ],
    'filter' => [
      'id' => 'string',
    ],
    'argument' => [
      'id' => 'string',
    ],
  ];

  $data['forcontu_views_users']['uid'] = [
    'title' => t('User'),
    'help' => t('User object'),
    'relationship' => [
      'group' => t('Users'),
      'label' => t('The user from forcontu_views_users table'),
      'title' => t('User from forcontu_views_users table'),
      'help' => t('Get user entity.'),
      'base' => 'users_field_data',
      'base field' => 'uid',
      'relationship field' => 'uid',
      'id' => 'standard',
    ],
  ];

  return $data;
}
```

上面的代码首先==将表添加为基础表，因此我们可以创建一个以“ Forcontu Views Users”作为基础元素的视图==。接下来，我们创建一个名为“ Empleados”的视图，使用表格格式的页面显示。添加ID、Employee code和Job Title字段。如果尚未添加数据，请通过phpMyAdmin添加数据。

到目前为止，我们只添加了该表的字段：

为了将员工与站点的用户关联，我们在 `uid` 字段和 `users_field_data` 表之间添加了一个关系，指明每个表中要关联的字段（`base field` => `uid`，`relationship field` => `uid`）。

从“添加关系”中，添加关系到视图中：

可以选择是否强制关系。如果强制关系，则只显示与站点用户相关联的员工。

现在我们可以添加使用前述关系的用户实体的其他字段：

#### 创建视图并添加关系
1. 创建视图：
   - 导航到 **结构 > Views > 添加视图**。
   - 设置视图名称，例如“用户信息”。
   - 选择 `forcontu_views_users` 作为基础表。
   - 选择显示格式，例如表格。

2. 添加字段：
   - 在视图配置中，添加 `employee_code` 和 `job_title` 字段。
   - 添加 `users_field_data` 表中的字段，例如 `name`（用户名）。

3. 添加关系：
   - 在视图配置中，导航到 **高级 > 添加 > 关系**。
   - 添加与 `users_field_data` 的关系，选择 `uid` 作为连接字段。

4. 保存视图并预览结果：
   - 保存视图，并预览结果以确保关系正确配置，并显示所有相关信息。

通过这种方式，我们在视图中实现了自定义表与 Drupal 用户表之间的关系，并能够显示所有相关信息。
# 37.9 视图结果上的操作（批量操作）

==什么是操作插件：==
![[Pasted image 20240714132138.png]]


在Site Building单元 22.5中，我们研究了如何在视图结果上进行批量操作。批量操作字段向视图结果添加复选框，用户可以对选中的结果执行不同的操作。在本节中，我们将看到如何添加自定义的额外操作。

每个操作都是一个 `@Action` 类型的插件，通过扩展以下基类之一来实现：
- `Drupal\Core\Action\ActionBase`。实现操作的通用基类。
- `Drupal\Core\Action\ConfigurableActionBase`。扩展 `ActionBase` 并添加实现可配置操作所需的依赖项。
- `Drupal\Core\Action\Plugin\Action\EntityActionBase`。用于创建基于实体的操作的基类。
- `Drupal\Core\Field\FieldUpdateActionBase`。用于创建更新一个或多个字段的操作的基类。

首先让我们看看核心中的一些操作示例。`PublishAction`（'entity:publish_action'）操作发布一个实体。它扩展了 `EntityActionBase` 基类，并实现了以下方法：
- `execute()`。执行操作。此示例非常简单，只需将实体标记为已发布（`$entity->setPublished()`）并保存（`$entity->save()`）。
- `access()`。检查用户是否有权限执行操作（更新实体）。

文件：`core/lib/Drupal/Core/Action/Plugin/Action/PublishAction.php`

```php
<?php
namespace Drupal\Core\Action\Plugin\Action;

use Drupal\Core\Session\AccountInterface;

/**
 * Publishes an entity.
 *
 * @Action(
 *   id = "entity:publish_action",
 *   action_label = @Translation("Publish"),
 *   deriver = "Drupal\Core\Action\Plugin\Action\Derivative\EntityPublishedActionDeriver",
 * )
 */
class PublishAction extends EntityActionBase {
  /**
   * {@inheritdoc}
   */
  public function execute($entity = NULL) {
    $entity->setPublished()->save();
  }

  /**
   * {@inheritdoc}
   */
  public function access($object, AccountInterface $account = NULL, $return_as_object = FALSE) {
    $key = $object->getEntityType()->getKey('published');
    /** @var \Drupal\Core\Entity\EntityInterface $object */
    $result = $object->access('update', $account, TRUE)
      ->andIf($object->$key->access('edit', $account, TRUE));
    return $return_as_object ? $result : $result->isAllowed();
  }
}
```

在 `@Action` 注解块中添加了以下参数：
- `id`。插件的ID。
- `action_label`。操作的标签，带有翻译，将在可用操作列表中显示。
- `deriver`。允许将操作派生到不同的实体类型，使同一操作可以多次实例化，但应用于不同的实体（节点、分类等）。
- `type`。当不派生插件时，我们必须指定元素或实体的类型（'system'，'node'，'user'等）。

除了插件，我们还需要创建一个配置对象，以便为操作添加上下文信息。例如，对于前面的插件，我们会找到以下配置：

文件：`core/modules/node/config/install/system.action.node_publish_action.yml`

```yaml
langcode: en
status: true
dependencies:
  module:
    - node
id: node_publish_action
label: 'Publish content'
type: node
plugin: entity:publish_action:node
configuration: { }
```

在此配置中，我们实例化了一个具体案例的插件。此操作将针对 `node` 实体。

同一个插件可以实例化以用于其他实体。例如，发布分类术语：

文件：`core/modules/taxonomy/config/install/system.action.taxonomy_term_publish_action.yml`

```yaml
langcode: en
status: true
dependencies:
  module:
    - taxonomy
id: taxonomy_term_publish_action
label: 'Publish taxonomy term'
type: taxonomy_term
plugin: entity:publish_action:taxonomy_term
configuration: { }
```

如前所述，这种实体选择可以通过实现 `EntityPublishedActionDeriver` 派生类来实现。更多关于插件派生的信息，请参阅：[https://www.drupal.org/docs/drupal-apis/plugin-api/plugin-derivatives](https://www.drupal.org/docs/drupal-apis/plugin-api/plugin-derivatives)。

另一个示例是 `PromoteNode`（'node_promote_action'）操作，提升一个节点。它扩展了 `FieldUpdateActionBase` 基类，并仅实现了以下方法：
- `getFieldsToUpdate()`。此方法返回一个数组，其中包含要更新的字段及其新值。在此示例中，仅返回 `promote`，其值为 TRUE，通过常量 `NodeInterface::PROMOTED`。

文件：`core/modules/node/src/Plugin/Action/PromoteNode.php`

```php
<?php
namespace Drupal\node\Plugin\Action;

use Drupal\Core\Field\FieldUpdateActionBase;
use Drupal\node\NodeInterface;

/**
 * Promotes a node.
 *
 * @Action(
 *   id = "node_promote_action",
 *   label = @Translation("Promote selected content to front page"),
 *   type = "node"
 * )
 */
class PromoteNode extends FieldUpdateActionBase {
  /**
   * {@inheritdoc}
   */
  protected function getFieldsToUpdate() {
    return ['promote' => NodeInterface::PROMOTED];
  }
}
```

这里直接实例化插件，无需派生，因此插件名称与 `@Action` 中定义的ID一致（`plugin: node_promote_action`）。

文件：`core/modules/node/config/install/system.action.node_promote_action.yml`

```yaml
langcode: en
status: true
dependencies:
  module:
    - node
id: node_promote_action
label: 'Promote content to front page'
type: node
plugin: node_promote_action
configuration: { }
```

#### 实现自定义操作插件

在 Forcontu Views 模块中，我们将实现 `forcontu_views_highlight_node` 操作，将节点标记为突出显示。

如前所述，在创建自定义插件时，我们需要根据要实现的操作类型扩展前面提到的基类之一。在此示例中，由于我们正在处理 `node` 类型的实体，因此我们扩展 `EntityActionBase`。需要注意的一些事项：
- 在插件的注解中指定实体类型（`type = "node"`）。
- 注入 `database` 服务以实现对表（`forcontu_node_highlighted`）的插入或更新。
- 基类 `EntityActionBase` 注入了 `entity_type.manager` 服务（`EntityTypeManager`）。尽管基类注入了该服务，但我们仍需要注入它，以便调用父类构造函数（`parent::__construct()`）。
- 在 `execute()` 方法中调用 `executeMultiple()` 方法，以对多个实体执行操作。
- 在 `executeMultiple()` 方法中执行 `upsert` 操作，以根据节点是否存在于表中更新或插入相应的条目。虽然我们没有直接修改实体，但仍需保存实体（`$entity->save()`），以便系统知道实体已修改，并更新修改日期及缓存。
- `access()` 方法是强制性的（基类中未实现，强制我们实现）。虽然可以添加权限控制，但在此示例中，我们简化为返回 `TRUE`，表示始终有权限执行操作。

文件：`forcontu_views/src/Plugin/Action/HighlightNodeAction.php`

```php
<?php
namespace Drupal\forcontu_views\Plugin\Action;

use Drupal\Core\Database\Connection;
use Drupal\Core\Entity\EntityTypeManagerInterface;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Drupal\Core\Action\Plugin\Action\EntityActionBase;
use Drupal\Core\Session\AccountInterface;

/**
 * Highlight a node.
 *
 * @Action(
 *   id = "forcontu_views_highlight_node",
 *   action_label = @Translation("Highlight node"),
 *   type = "node",
 * )
 */
class HighlightNodeAction extends EntityActionBase {
  /**
   * Database.
   *
   * @var \Drupal\Core\Database\Connection
   */
  protected $database;

  /**
   * Constructs the object by injecting services.
   */
  public function __construct(array $configuration, $plugin_id, $plugin_definition, EntityTypeManagerInterface $entity_type_manager, Connection $database) {
    $this->database = $database;

    parent::__construct($configuration, $plugin_id, $plugin_definition, $entity_type_manager);
  }

  /**
   * {@inheritdoc}
   */
  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
    return new static(
      $configuration,
      $plugin_id,
      $plugin_definition,
      $container->get('entity_type.manager'),
      $container->get('database')
    );
  }

  /**
   * {@inheritdoc}
   */
  public function executeMultiple(array $entities) {
    foreach ($entities as $entity) {
      $this->database->upsert('forcontu_node_highlighted')
        ->key('nid')
        ->fields(['nid', 'highlighted'])
        ->values([
          'nid' => $entity->id(),
          'highlighted' => 1,
        ])->execute();

      // 虽然我们没有直接修改实体，但仍需保存实体，以便系统知道实体已修改，并更新修改日期及缓存。
      $entity->save();
    }
  }

  /**
   * {@inheritdoc}
   */
  public function execute($object = NULL) {
    $this->executeMultiple([$object]);
  }

  /**
   * {@inheritdoc}
   */
  public function access($object, AccountInterface $account = NULL, $return_as_object = FALSE) {
    return TRUE;
  }
}
```
==PS: 直接操作数据库时，没有直接修改实体，但仍需保存实体，以便系统知道实体已修改，并更新修改日期及缓存。==
接下来创建一个配置文件以实例化插件：

文件：`forcontu_views/config/install/system.action.forcontu_views_highlight_node_action.yml`

```yaml
langcode: en
status: true
dependencies:
  module:
    - node
    - forcontu_forms
id: forcontu_views_highlight_node_action
label: 'Highlight content'
type: node
plugin: forcontu_views_highlight_node
configuration: { }
```

要让系统检测到插件，需要卸载并重新安装 Forcontu Views 模块。重新安装并清空缓存后，==编辑内容管理视图==（/admin/content），并检查节点批量操作表单中是否包含新操作（Highlight content），如图 [F37.9a] 所示。不应选中该操作，即表示显示所有操作，除了选中的。

接下来在内容管理视图中添加 `Highlighted content` 字段，并将其配置为显示图标。记得指定图标路径，如本单元前面所示。

保存视图并访问内容管理。选择多个内容并执行 `Highlight content` 操作 [F37.9c]。

操作执行后，节点将被标记为突出显示，并应看到相应的图标 [F37.9d]。
# 37.10 视图钩子

我们还可以通过钩子与视图进行交互。完整的钩子列表可以在以下链接查询：
[https://api.drupal.org/api/drupal/core!modules!views!views.api.php/10](https://api.drupal.org/api/drupal/core!modules!views!views.api.php/10)

==关于钩子的一个重要注意事项是，那些需要在每次执行视图时运行的钩子，应该放在 `module.views_execution.inc` 文件中，而不是 `module.views.inc` 文件中。==

钩子允许我们修改视图的任何元素，当需要修改行为或结果且无法直接通过视图配置完成时，尤其有用。

以下是一些重要的钩子：

#### `hook_views_query_alter`
允许在视图查询执行之前修改查询。

```php
function hook_views_query_alter(ViewExecutable $view, QueryPluginBase $query)
```

[https://api.drupal.org/api/drupal/core!modules!views!views.api.php/function/hook_views_query_alter/10](https://api.drupal.org/api/drupal/core!modules!views!views.api.php/function/hook_views_query_alter/10)

钩子接收视图和查询作为参数。请记住，该钩子会为所有视图执行，因此需要添加某种条件（例如 `$view->id()`）以指示应在哪些视图中生效。

对 `$query` 对象所做的所有修改将应用于最终结果。

#### `hook_views_pre_render`
允许在视图渲染之前进行操作。视图已执行，因此我们可以获得结果，这使其成为在主题级别修改视图的一个好选项。

还允许在视图之前和之后添加额外的输出：

- `$view->attachment_before`
- `$view->attachment_after`

```php
function hook_views_pre_render(ViewExecutable $view)
```

[https://api.drupal.org/api/drupal/core!modules!views!views.api.php/function/hook_views_pre_render/10](https://api.drupal.org/api/drupal/core!modules!views!views.api.php/function/hook_views_pre_render/10)

#### `hook_form_views_exposed_form_alter`
虽然这不是一个特定于视图的钩子，但 `hook_form_alter()` 的这个变体允许修改暴露过滤器的表单。

当我们希望修改表单字段的值或添加属性时，特别有用，始终记住这些是我们在之前单元中了解到的FORM API表单元素。

```php
function hook_form_views_exposed_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id)
```

```php
function mymodule_form_views_exposed_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  // 检查视图ID和显示ID。
  if ($form_state->getBuildInfo()['args'][0]->id() === 'my_view_id' && $form_state->getBuildInfo()['args'][0]->current_display === 'my_display_id') {
    // 修改暴露的过滤器表单字段。
    $form['field_name']['#attributes']['class'][] = 'my-custom-class';
  }
}
```

通过这些钩子，我们可以灵活地修改视图的查询、渲染前操作以及暴露过滤器表单，使视图更符合我们的需求。